
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Admins
 * 
 */
export type Admins = $Result.DefaultSelection<Prisma.$AdminsPayload>
/**
 * Model ConferenceBlacklists
 * 
 */
export type ConferenceBlacklists = $Result.DefaultSelection<Prisma.$ConferenceBlacklistsPayload>
/**
 * Model ConferenceCalendars
 * 
 */
export type ConferenceCalendars = $Result.DefaultSelection<Prisma.$ConferenceCalendarsPayload>
/**
 * Model ConferenceCrawlJobs
 * 
 */
export type ConferenceCrawlJobs = $Result.DefaultSelection<Prisma.$ConferenceCrawlJobsPayload>
/**
 * Model ConferenceDates
 * 
 */
export type ConferenceDates = $Result.DefaultSelection<Prisma.$ConferenceDatesPayload>
/**
 * Model ConferenceFeedbacks
 * 
 */
export type ConferenceFeedbacks = $Result.DefaultSelection<Prisma.$ConferenceFeedbacksPayload>
/**
 * Model ConferenceFollows
 * 
 */
export type ConferenceFollows = $Result.DefaultSelection<Prisma.$ConferenceFollowsPayload>
/**
 * Model ConferenceLikes
 * 
 */
export type ConferenceLikes = $Result.DefaultSelection<Prisma.$ConferenceLikesPayload>
/**
 * Model ConferenceOrganizations
 * 
 */
export type ConferenceOrganizations = $Result.DefaultSelection<Prisma.$ConferenceOrganizationsPayload>
/**
 * Model ConferenceRanks
 * 
 */
export type ConferenceRanks = $Result.DefaultSelection<Prisma.$ConferenceRanksPayload>
/**
 * Model ConferenceTopics
 * 
 */
export type ConferenceTopics = $Result.DefaultSelection<Prisma.$ConferenceTopicsPayload>
/**
 * Model Conferences
 * 
 */
export type Conferences = $Result.DefaultSelection<Prisma.$ConferencesPayload>
/**
 * Model FieldOfResearchs
 * 
 */
export type FieldOfResearchs = $Result.DefaultSelection<Prisma.$FieldOfResearchsPayload>
/**
 * Model JournalCrawlJobs
 * 
 */
export type JournalCrawlJobs = $Result.DefaultSelection<Prisma.$JournalCrawlJobsPayload>
/**
 * Model JournalFollows
 * 
 */
export type JournalFollows = $Result.DefaultSelection<Prisma.$JournalFollowsPayload>
/**
 * Model JournalLikes
 * 
 */
export type JournalLikes = $Result.DefaultSelection<Prisma.$JournalLikesPayload>
/**
 * Model JournalRanks
 * 
 */
export type JournalRanks = $Result.DefaultSelection<Prisma.$JournalRanksPayload>
/**
 * Model JournalTopics
 * 
 */
export type JournalTopics = $Result.DefaultSelection<Prisma.$JournalTopicsPayload>
/**
 * Model Journals
 * 
 */
export type Journals = $Result.DefaultSelection<Prisma.$JournalsPayload>
/**
 * Model Locations
 * 
 */
export type Locations = $Result.DefaultSelection<Prisma.$LocationsPayload>
/**
 * Model NotificationSettings
 * 
 */
export type NotificationSettings = $Result.DefaultSelection<Prisma.$NotificationSettingsPayload>
/**
 * Model Notifications
 * 
 */
export type Notifications = $Result.DefaultSelection<Prisma.$NotificationsPayload>
/**
 * Model NotificationsTypes
 * 
 */
export type NotificationsTypes = $Result.DefaultSelection<Prisma.$NotificationsTypesPayload>
/**
 * Model Passenger
 * 
 */
export type Passenger = $Result.DefaultSelection<Prisma.$PassengerPayload>
/**
 * Model Ranks
 * 
 */
export type Ranks = $Result.DefaultSelection<Prisma.$RanksPayload>
/**
 * Model Sources
 * 
 */
export type Sources = $Result.DefaultSelection<Prisma.$SourcesPayload>
/**
 * Model TopicUserInteresteds
 * 
 */
export type TopicUserInteresteds = $Result.DefaultSelection<Prisma.$TopicUserInterestedsPayload>
/**
 * Model Topics
 * 
 */
export type Topics = $Result.DefaultSelection<Prisma.$TopicsPayload>
/**
 * Model UserVerification
 * 
 */
export type UserVerification = $Result.DefaultSelection<Prisma.$UserVerificationPayload>
/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Admins
 * const admins = await prisma.admins.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Admins
   * const admins = await prisma.admins.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.admins`: Exposes CRUD operations for the **Admins** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admins.findMany()
    * ```
    */
  get admins(): Prisma.AdminsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conferenceBlacklists`: Exposes CRUD operations for the **ConferenceBlacklists** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConferenceBlacklists
    * const conferenceBlacklists = await prisma.conferenceBlacklists.findMany()
    * ```
    */
  get conferenceBlacklists(): Prisma.ConferenceBlacklistsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conferenceCalendars`: Exposes CRUD operations for the **ConferenceCalendars** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConferenceCalendars
    * const conferenceCalendars = await prisma.conferenceCalendars.findMany()
    * ```
    */
  get conferenceCalendars(): Prisma.ConferenceCalendarsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conferenceCrawlJobs`: Exposes CRUD operations for the **ConferenceCrawlJobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConferenceCrawlJobs
    * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.findMany()
    * ```
    */
  get conferenceCrawlJobs(): Prisma.ConferenceCrawlJobsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conferenceDates`: Exposes CRUD operations for the **ConferenceDates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConferenceDates
    * const conferenceDates = await prisma.conferenceDates.findMany()
    * ```
    */
  get conferenceDates(): Prisma.ConferenceDatesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conferenceFeedbacks`: Exposes CRUD operations for the **ConferenceFeedbacks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConferenceFeedbacks
    * const conferenceFeedbacks = await prisma.conferenceFeedbacks.findMany()
    * ```
    */
  get conferenceFeedbacks(): Prisma.ConferenceFeedbacksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conferenceFollows`: Exposes CRUD operations for the **ConferenceFollows** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConferenceFollows
    * const conferenceFollows = await prisma.conferenceFollows.findMany()
    * ```
    */
  get conferenceFollows(): Prisma.ConferenceFollowsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conferenceLikes`: Exposes CRUD operations for the **ConferenceLikes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConferenceLikes
    * const conferenceLikes = await prisma.conferenceLikes.findMany()
    * ```
    */
  get conferenceLikes(): Prisma.ConferenceLikesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conferenceOrganizations`: Exposes CRUD operations for the **ConferenceOrganizations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConferenceOrganizations
    * const conferenceOrganizations = await prisma.conferenceOrganizations.findMany()
    * ```
    */
  get conferenceOrganizations(): Prisma.ConferenceOrganizationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conferenceRanks`: Exposes CRUD operations for the **ConferenceRanks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConferenceRanks
    * const conferenceRanks = await prisma.conferenceRanks.findMany()
    * ```
    */
  get conferenceRanks(): Prisma.ConferenceRanksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conferenceTopics`: Exposes CRUD operations for the **ConferenceTopics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConferenceTopics
    * const conferenceTopics = await prisma.conferenceTopics.findMany()
    * ```
    */
  get conferenceTopics(): Prisma.ConferenceTopicsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conferences`: Exposes CRUD operations for the **Conferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conferences
    * const conferences = await prisma.conferences.findMany()
    * ```
    */
  get conferences(): Prisma.ConferencesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fieldOfResearchs`: Exposes CRUD operations for the **FieldOfResearchs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FieldOfResearchs
    * const fieldOfResearchs = await prisma.fieldOfResearchs.findMany()
    * ```
    */
  get fieldOfResearchs(): Prisma.FieldOfResearchsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journalCrawlJobs`: Exposes CRUD operations for the **JournalCrawlJobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalCrawlJobs
    * const journalCrawlJobs = await prisma.journalCrawlJobs.findMany()
    * ```
    */
  get journalCrawlJobs(): Prisma.JournalCrawlJobsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journalFollows`: Exposes CRUD operations for the **JournalFollows** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalFollows
    * const journalFollows = await prisma.journalFollows.findMany()
    * ```
    */
  get journalFollows(): Prisma.JournalFollowsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journalLikes`: Exposes CRUD operations for the **JournalLikes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalLikes
    * const journalLikes = await prisma.journalLikes.findMany()
    * ```
    */
  get journalLikes(): Prisma.JournalLikesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journalRanks`: Exposes CRUD operations for the **JournalRanks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalRanks
    * const journalRanks = await prisma.journalRanks.findMany()
    * ```
    */
  get journalRanks(): Prisma.JournalRanksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journalTopics`: Exposes CRUD operations for the **JournalTopics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalTopics
    * const journalTopics = await prisma.journalTopics.findMany()
    * ```
    */
  get journalTopics(): Prisma.JournalTopicsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journals`: Exposes CRUD operations for the **Journals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Journals
    * const journals = await prisma.journals.findMany()
    * ```
    */
  get journals(): Prisma.JournalsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.locations`: Exposes CRUD operations for the **Locations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.locations.findMany()
    * ```
    */
  get locations(): Prisma.LocationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationSettings`: Exposes CRUD operations for the **NotificationSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationSettings
    * const notificationSettings = await prisma.notificationSettings.findMany()
    * ```
    */
  get notificationSettings(): Prisma.NotificationSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **Notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.NotificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationsTypes`: Exposes CRUD operations for the **NotificationsTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationsTypes
    * const notificationsTypes = await prisma.notificationsTypes.findMany()
    * ```
    */
  get notificationsTypes(): Prisma.NotificationsTypesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passenger`: Exposes CRUD operations for the **Passenger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Passengers
    * const passengers = await prisma.passenger.findMany()
    * ```
    */
  get passenger(): Prisma.PassengerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ranks`: Exposes CRUD operations for the **Ranks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ranks
    * const ranks = await prisma.ranks.findMany()
    * ```
    */
  get ranks(): Prisma.RanksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sources`: Exposes CRUD operations for the **Sources** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sources
    * const sources = await prisma.sources.findMany()
    * ```
    */
  get sources(): Prisma.SourcesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.topicUserInteresteds`: Exposes CRUD operations for the **TopicUserInteresteds** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TopicUserInteresteds
    * const topicUserInteresteds = await prisma.topicUserInteresteds.findMany()
    * ```
    */
  get topicUserInteresteds(): Prisma.TopicUserInterestedsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.topics`: Exposes CRUD operations for the **Topics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Topics
    * const topics = await prisma.topics.findMany()
    * ```
    */
  get topics(): Prisma.TopicsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userVerification`: Exposes CRUD operations for the **UserVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserVerifications
    * const userVerifications = await prisma.userVerification.findMany()
    * ```
    */
  get userVerification(): Prisma.UserVerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.5.0
   * Query Engine version: 173f8d54f8d52e692c7e27e72a88314ec7aeff60
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Admins: 'Admins',
    ConferenceBlacklists: 'ConferenceBlacklists',
    ConferenceCalendars: 'ConferenceCalendars',
    ConferenceCrawlJobs: 'ConferenceCrawlJobs',
    ConferenceDates: 'ConferenceDates',
    ConferenceFeedbacks: 'ConferenceFeedbacks',
    ConferenceFollows: 'ConferenceFollows',
    ConferenceLikes: 'ConferenceLikes',
    ConferenceOrganizations: 'ConferenceOrganizations',
    ConferenceRanks: 'ConferenceRanks',
    ConferenceTopics: 'ConferenceTopics',
    Conferences: 'Conferences',
    FieldOfResearchs: 'FieldOfResearchs',
    JournalCrawlJobs: 'JournalCrawlJobs',
    JournalFollows: 'JournalFollows',
    JournalLikes: 'JournalLikes',
    JournalRanks: 'JournalRanks',
    JournalTopics: 'JournalTopics',
    Journals: 'Journals',
    Locations: 'Locations',
    NotificationSettings: 'NotificationSettings',
    Notifications: 'Notifications',
    NotificationsTypes: 'NotificationsTypes',
    Passenger: 'Passenger',
    Ranks: 'Ranks',
    Sources: 'Sources',
    TopicUserInteresteds: 'TopicUserInteresteds',
    Topics: 'Topics',
    UserVerification: 'UserVerification',
    Users: 'Users'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "admins" | "conferenceBlacklists" | "conferenceCalendars" | "conferenceCrawlJobs" | "conferenceDates" | "conferenceFeedbacks" | "conferenceFollows" | "conferenceLikes" | "conferenceOrganizations" | "conferenceRanks" | "conferenceTopics" | "conferences" | "fieldOfResearchs" | "journalCrawlJobs" | "journalFollows" | "journalLikes" | "journalRanks" | "journalTopics" | "journals" | "locations" | "notificationSettings" | "notifications" | "notificationsTypes" | "passenger" | "ranks" | "sources" | "topicUserInteresteds" | "topics" | "userVerification" | "users"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Admins: {
        payload: Prisma.$AdminsPayload<ExtArgs>
        fields: Prisma.AdminsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload>
          }
          findFirst: {
            args: Prisma.AdminsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload>
          }
          findMany: {
            args: Prisma.AdminsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload>[]
          }
          create: {
            args: Prisma.AdminsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload>
          }
          createMany: {
            args: Prisma.AdminsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload>[]
          }
          delete: {
            args: Prisma.AdminsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload>
          }
          update: {
            args: Prisma.AdminsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload>
          }
          deleteMany: {
            args: Prisma.AdminsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload>[]
          }
          upsert: {
            args: Prisma.AdminsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload>
          }
          aggregate: {
            args: Prisma.AdminsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmins>
          }
          groupBy: {
            args: Prisma.AdminsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminsCountArgs<ExtArgs>
            result: $Utils.Optional<AdminsCountAggregateOutputType> | number
          }
        }
      }
      ConferenceBlacklists: {
        payload: Prisma.$ConferenceBlacklistsPayload<ExtArgs>
        fields: Prisma.ConferenceBlacklistsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferenceBlacklistsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceBlacklistsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferenceBlacklistsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceBlacklistsPayload>
          }
          findFirst: {
            args: Prisma.ConferenceBlacklistsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceBlacklistsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferenceBlacklistsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceBlacklistsPayload>
          }
          findMany: {
            args: Prisma.ConferenceBlacklistsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceBlacklistsPayload>[]
          }
          create: {
            args: Prisma.ConferenceBlacklistsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceBlacklistsPayload>
          }
          createMany: {
            args: Prisma.ConferenceBlacklistsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferenceBlacklistsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceBlacklistsPayload>[]
          }
          delete: {
            args: Prisma.ConferenceBlacklistsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceBlacklistsPayload>
          }
          update: {
            args: Prisma.ConferenceBlacklistsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceBlacklistsPayload>
          }
          deleteMany: {
            args: Prisma.ConferenceBlacklistsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferenceBlacklistsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferenceBlacklistsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceBlacklistsPayload>[]
          }
          upsert: {
            args: Prisma.ConferenceBlacklistsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceBlacklistsPayload>
          }
          aggregate: {
            args: Prisma.ConferenceBlacklistsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferenceBlacklists>
          }
          groupBy: {
            args: Prisma.ConferenceBlacklistsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferenceBlacklistsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferenceBlacklistsCountArgs<ExtArgs>
            result: $Utils.Optional<ConferenceBlacklistsCountAggregateOutputType> | number
          }
        }
      }
      ConferenceCalendars: {
        payload: Prisma.$ConferenceCalendarsPayload<ExtArgs>
        fields: Prisma.ConferenceCalendarsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferenceCalendarsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCalendarsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferenceCalendarsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCalendarsPayload>
          }
          findFirst: {
            args: Prisma.ConferenceCalendarsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCalendarsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferenceCalendarsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCalendarsPayload>
          }
          findMany: {
            args: Prisma.ConferenceCalendarsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCalendarsPayload>[]
          }
          create: {
            args: Prisma.ConferenceCalendarsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCalendarsPayload>
          }
          createMany: {
            args: Prisma.ConferenceCalendarsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferenceCalendarsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCalendarsPayload>[]
          }
          delete: {
            args: Prisma.ConferenceCalendarsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCalendarsPayload>
          }
          update: {
            args: Prisma.ConferenceCalendarsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCalendarsPayload>
          }
          deleteMany: {
            args: Prisma.ConferenceCalendarsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferenceCalendarsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferenceCalendarsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCalendarsPayload>[]
          }
          upsert: {
            args: Prisma.ConferenceCalendarsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCalendarsPayload>
          }
          aggregate: {
            args: Prisma.ConferenceCalendarsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferenceCalendars>
          }
          groupBy: {
            args: Prisma.ConferenceCalendarsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferenceCalendarsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferenceCalendarsCountArgs<ExtArgs>
            result: $Utils.Optional<ConferenceCalendarsCountAggregateOutputType> | number
          }
        }
      }
      ConferenceCrawlJobs: {
        payload: Prisma.$ConferenceCrawlJobsPayload<ExtArgs>
        fields: Prisma.ConferenceCrawlJobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferenceCrawlJobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCrawlJobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferenceCrawlJobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCrawlJobsPayload>
          }
          findFirst: {
            args: Prisma.ConferenceCrawlJobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCrawlJobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferenceCrawlJobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCrawlJobsPayload>
          }
          findMany: {
            args: Prisma.ConferenceCrawlJobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCrawlJobsPayload>[]
          }
          create: {
            args: Prisma.ConferenceCrawlJobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCrawlJobsPayload>
          }
          createMany: {
            args: Prisma.ConferenceCrawlJobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferenceCrawlJobsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCrawlJobsPayload>[]
          }
          delete: {
            args: Prisma.ConferenceCrawlJobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCrawlJobsPayload>
          }
          update: {
            args: Prisma.ConferenceCrawlJobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCrawlJobsPayload>
          }
          deleteMany: {
            args: Prisma.ConferenceCrawlJobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferenceCrawlJobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferenceCrawlJobsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCrawlJobsPayload>[]
          }
          upsert: {
            args: Prisma.ConferenceCrawlJobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCrawlJobsPayload>
          }
          aggregate: {
            args: Prisma.ConferenceCrawlJobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferenceCrawlJobs>
          }
          groupBy: {
            args: Prisma.ConferenceCrawlJobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferenceCrawlJobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferenceCrawlJobsCountArgs<ExtArgs>
            result: $Utils.Optional<ConferenceCrawlJobsCountAggregateOutputType> | number
          }
        }
      }
      ConferenceDates: {
        payload: Prisma.$ConferenceDatesPayload<ExtArgs>
        fields: Prisma.ConferenceDatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferenceDatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceDatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferenceDatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceDatesPayload>
          }
          findFirst: {
            args: Prisma.ConferenceDatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceDatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferenceDatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceDatesPayload>
          }
          findMany: {
            args: Prisma.ConferenceDatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceDatesPayload>[]
          }
          create: {
            args: Prisma.ConferenceDatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceDatesPayload>
          }
          createMany: {
            args: Prisma.ConferenceDatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferenceDatesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceDatesPayload>[]
          }
          delete: {
            args: Prisma.ConferenceDatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceDatesPayload>
          }
          update: {
            args: Prisma.ConferenceDatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceDatesPayload>
          }
          deleteMany: {
            args: Prisma.ConferenceDatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferenceDatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferenceDatesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceDatesPayload>[]
          }
          upsert: {
            args: Prisma.ConferenceDatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceDatesPayload>
          }
          aggregate: {
            args: Prisma.ConferenceDatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferenceDates>
          }
          groupBy: {
            args: Prisma.ConferenceDatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferenceDatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferenceDatesCountArgs<ExtArgs>
            result: $Utils.Optional<ConferenceDatesCountAggregateOutputType> | number
          }
        }
      }
      ConferenceFeedbacks: {
        payload: Prisma.$ConferenceFeedbacksPayload<ExtArgs>
        fields: Prisma.ConferenceFeedbacksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferenceFeedbacksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbacksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferenceFeedbacksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbacksPayload>
          }
          findFirst: {
            args: Prisma.ConferenceFeedbacksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbacksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferenceFeedbacksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbacksPayload>
          }
          findMany: {
            args: Prisma.ConferenceFeedbacksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbacksPayload>[]
          }
          create: {
            args: Prisma.ConferenceFeedbacksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbacksPayload>
          }
          createMany: {
            args: Prisma.ConferenceFeedbacksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferenceFeedbacksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbacksPayload>[]
          }
          delete: {
            args: Prisma.ConferenceFeedbacksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbacksPayload>
          }
          update: {
            args: Prisma.ConferenceFeedbacksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbacksPayload>
          }
          deleteMany: {
            args: Prisma.ConferenceFeedbacksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferenceFeedbacksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferenceFeedbacksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbacksPayload>[]
          }
          upsert: {
            args: Prisma.ConferenceFeedbacksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbacksPayload>
          }
          aggregate: {
            args: Prisma.ConferenceFeedbacksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferenceFeedbacks>
          }
          groupBy: {
            args: Prisma.ConferenceFeedbacksGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferenceFeedbacksGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferenceFeedbacksCountArgs<ExtArgs>
            result: $Utils.Optional<ConferenceFeedbacksCountAggregateOutputType> | number
          }
        }
      }
      ConferenceFollows: {
        payload: Prisma.$ConferenceFollowsPayload<ExtArgs>
        fields: Prisma.ConferenceFollowsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferenceFollowsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFollowsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferenceFollowsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFollowsPayload>
          }
          findFirst: {
            args: Prisma.ConferenceFollowsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFollowsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferenceFollowsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFollowsPayload>
          }
          findMany: {
            args: Prisma.ConferenceFollowsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFollowsPayload>[]
          }
          create: {
            args: Prisma.ConferenceFollowsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFollowsPayload>
          }
          createMany: {
            args: Prisma.ConferenceFollowsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferenceFollowsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFollowsPayload>[]
          }
          delete: {
            args: Prisma.ConferenceFollowsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFollowsPayload>
          }
          update: {
            args: Prisma.ConferenceFollowsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFollowsPayload>
          }
          deleteMany: {
            args: Prisma.ConferenceFollowsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferenceFollowsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferenceFollowsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFollowsPayload>[]
          }
          upsert: {
            args: Prisma.ConferenceFollowsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFollowsPayload>
          }
          aggregate: {
            args: Prisma.ConferenceFollowsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferenceFollows>
          }
          groupBy: {
            args: Prisma.ConferenceFollowsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferenceFollowsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferenceFollowsCountArgs<ExtArgs>
            result: $Utils.Optional<ConferenceFollowsCountAggregateOutputType> | number
          }
        }
      }
      ConferenceLikes: {
        payload: Prisma.$ConferenceLikesPayload<ExtArgs>
        fields: Prisma.ConferenceLikesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferenceLikesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceLikesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferenceLikesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceLikesPayload>
          }
          findFirst: {
            args: Prisma.ConferenceLikesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceLikesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferenceLikesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceLikesPayload>
          }
          findMany: {
            args: Prisma.ConferenceLikesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceLikesPayload>[]
          }
          create: {
            args: Prisma.ConferenceLikesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceLikesPayload>
          }
          createMany: {
            args: Prisma.ConferenceLikesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferenceLikesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceLikesPayload>[]
          }
          delete: {
            args: Prisma.ConferenceLikesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceLikesPayload>
          }
          update: {
            args: Prisma.ConferenceLikesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceLikesPayload>
          }
          deleteMany: {
            args: Prisma.ConferenceLikesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferenceLikesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferenceLikesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceLikesPayload>[]
          }
          upsert: {
            args: Prisma.ConferenceLikesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceLikesPayload>
          }
          aggregate: {
            args: Prisma.ConferenceLikesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferenceLikes>
          }
          groupBy: {
            args: Prisma.ConferenceLikesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferenceLikesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferenceLikesCountArgs<ExtArgs>
            result: $Utils.Optional<ConferenceLikesCountAggregateOutputType> | number
          }
        }
      }
      ConferenceOrganizations: {
        payload: Prisma.$ConferenceOrganizationsPayload<ExtArgs>
        fields: Prisma.ConferenceOrganizationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferenceOrganizationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceOrganizationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferenceOrganizationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceOrganizationsPayload>
          }
          findFirst: {
            args: Prisma.ConferenceOrganizationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceOrganizationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferenceOrganizationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceOrganizationsPayload>
          }
          findMany: {
            args: Prisma.ConferenceOrganizationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceOrganizationsPayload>[]
          }
          create: {
            args: Prisma.ConferenceOrganizationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceOrganizationsPayload>
          }
          createMany: {
            args: Prisma.ConferenceOrganizationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferenceOrganizationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceOrganizationsPayload>[]
          }
          delete: {
            args: Prisma.ConferenceOrganizationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceOrganizationsPayload>
          }
          update: {
            args: Prisma.ConferenceOrganizationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceOrganizationsPayload>
          }
          deleteMany: {
            args: Prisma.ConferenceOrganizationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferenceOrganizationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferenceOrganizationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceOrganizationsPayload>[]
          }
          upsert: {
            args: Prisma.ConferenceOrganizationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceOrganizationsPayload>
          }
          aggregate: {
            args: Prisma.ConferenceOrganizationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferenceOrganizations>
          }
          groupBy: {
            args: Prisma.ConferenceOrganizationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferenceOrganizationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferenceOrganizationsCountArgs<ExtArgs>
            result: $Utils.Optional<ConferenceOrganizationsCountAggregateOutputType> | number
          }
        }
      }
      ConferenceRanks: {
        payload: Prisma.$ConferenceRanksPayload<ExtArgs>
        fields: Prisma.ConferenceRanksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferenceRanksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceRanksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferenceRanksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceRanksPayload>
          }
          findFirst: {
            args: Prisma.ConferenceRanksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceRanksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferenceRanksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceRanksPayload>
          }
          findMany: {
            args: Prisma.ConferenceRanksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceRanksPayload>[]
          }
          create: {
            args: Prisma.ConferenceRanksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceRanksPayload>
          }
          createMany: {
            args: Prisma.ConferenceRanksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferenceRanksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceRanksPayload>[]
          }
          delete: {
            args: Prisma.ConferenceRanksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceRanksPayload>
          }
          update: {
            args: Prisma.ConferenceRanksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceRanksPayload>
          }
          deleteMany: {
            args: Prisma.ConferenceRanksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferenceRanksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferenceRanksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceRanksPayload>[]
          }
          upsert: {
            args: Prisma.ConferenceRanksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceRanksPayload>
          }
          aggregate: {
            args: Prisma.ConferenceRanksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferenceRanks>
          }
          groupBy: {
            args: Prisma.ConferenceRanksGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferenceRanksGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferenceRanksCountArgs<ExtArgs>
            result: $Utils.Optional<ConferenceRanksCountAggregateOutputType> | number
          }
        }
      }
      ConferenceTopics: {
        payload: Prisma.$ConferenceTopicsPayload<ExtArgs>
        fields: Prisma.ConferenceTopicsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferenceTopicsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceTopicsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferenceTopicsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceTopicsPayload>
          }
          findFirst: {
            args: Prisma.ConferenceTopicsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceTopicsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferenceTopicsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceTopicsPayload>
          }
          findMany: {
            args: Prisma.ConferenceTopicsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceTopicsPayload>[]
          }
          create: {
            args: Prisma.ConferenceTopicsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceTopicsPayload>
          }
          createMany: {
            args: Prisma.ConferenceTopicsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferenceTopicsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceTopicsPayload>[]
          }
          delete: {
            args: Prisma.ConferenceTopicsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceTopicsPayload>
          }
          update: {
            args: Prisma.ConferenceTopicsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceTopicsPayload>
          }
          deleteMany: {
            args: Prisma.ConferenceTopicsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferenceTopicsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferenceTopicsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceTopicsPayload>[]
          }
          upsert: {
            args: Prisma.ConferenceTopicsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceTopicsPayload>
          }
          aggregate: {
            args: Prisma.ConferenceTopicsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferenceTopics>
          }
          groupBy: {
            args: Prisma.ConferenceTopicsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferenceTopicsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferenceTopicsCountArgs<ExtArgs>
            result: $Utils.Optional<ConferenceTopicsCountAggregateOutputType> | number
          }
        }
      }
      Conferences: {
        payload: Prisma.$ConferencesPayload<ExtArgs>
        fields: Prisma.ConferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencesPayload>
          }
          findFirst: {
            args: Prisma.ConferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencesPayload>
          }
          findMany: {
            args: Prisma.ConferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencesPayload>[]
          }
          create: {
            args: Prisma.ConferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencesPayload>
          }
          createMany: {
            args: Prisma.ConferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencesPayload>[]
          }
          delete: {
            args: Prisma.ConferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencesPayload>
          }
          update: {
            args: Prisma.ConferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencesPayload>
          }
          deleteMany: {
            args: Prisma.ConferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferencesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencesPayload>[]
          }
          upsert: {
            args: Prisma.ConferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencesPayload>
          }
          aggregate: {
            args: Prisma.ConferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferences>
          }
          groupBy: {
            args: Prisma.ConferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferencesCountArgs<ExtArgs>
            result: $Utils.Optional<ConferencesCountAggregateOutputType> | number
          }
        }
      }
      FieldOfResearchs: {
        payload: Prisma.$FieldOfResearchsPayload<ExtArgs>
        fields: Prisma.FieldOfResearchsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FieldOfResearchsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOfResearchsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FieldOfResearchsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOfResearchsPayload>
          }
          findFirst: {
            args: Prisma.FieldOfResearchsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOfResearchsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FieldOfResearchsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOfResearchsPayload>
          }
          findMany: {
            args: Prisma.FieldOfResearchsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOfResearchsPayload>[]
          }
          create: {
            args: Prisma.FieldOfResearchsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOfResearchsPayload>
          }
          createMany: {
            args: Prisma.FieldOfResearchsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FieldOfResearchsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOfResearchsPayload>[]
          }
          delete: {
            args: Prisma.FieldOfResearchsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOfResearchsPayload>
          }
          update: {
            args: Prisma.FieldOfResearchsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOfResearchsPayload>
          }
          deleteMany: {
            args: Prisma.FieldOfResearchsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FieldOfResearchsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FieldOfResearchsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOfResearchsPayload>[]
          }
          upsert: {
            args: Prisma.FieldOfResearchsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOfResearchsPayload>
          }
          aggregate: {
            args: Prisma.FieldOfResearchsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFieldOfResearchs>
          }
          groupBy: {
            args: Prisma.FieldOfResearchsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FieldOfResearchsGroupByOutputType>[]
          }
          count: {
            args: Prisma.FieldOfResearchsCountArgs<ExtArgs>
            result: $Utils.Optional<FieldOfResearchsCountAggregateOutputType> | number
          }
        }
      }
      JournalCrawlJobs: {
        payload: Prisma.$JournalCrawlJobsPayload<ExtArgs>
        fields: Prisma.JournalCrawlJobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalCrawlJobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalCrawlJobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalCrawlJobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalCrawlJobsPayload>
          }
          findFirst: {
            args: Prisma.JournalCrawlJobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalCrawlJobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalCrawlJobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalCrawlJobsPayload>
          }
          findMany: {
            args: Prisma.JournalCrawlJobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalCrawlJobsPayload>[]
          }
          create: {
            args: Prisma.JournalCrawlJobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalCrawlJobsPayload>
          }
          createMany: {
            args: Prisma.JournalCrawlJobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalCrawlJobsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalCrawlJobsPayload>[]
          }
          delete: {
            args: Prisma.JournalCrawlJobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalCrawlJobsPayload>
          }
          update: {
            args: Prisma.JournalCrawlJobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalCrawlJobsPayload>
          }
          deleteMany: {
            args: Prisma.JournalCrawlJobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalCrawlJobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalCrawlJobsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalCrawlJobsPayload>[]
          }
          upsert: {
            args: Prisma.JournalCrawlJobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalCrawlJobsPayload>
          }
          aggregate: {
            args: Prisma.JournalCrawlJobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalCrawlJobs>
          }
          groupBy: {
            args: Prisma.JournalCrawlJobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalCrawlJobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalCrawlJobsCountArgs<ExtArgs>
            result: $Utils.Optional<JournalCrawlJobsCountAggregateOutputType> | number
          }
        }
      }
      JournalFollows: {
        payload: Prisma.$JournalFollowsPayload<ExtArgs>
        fields: Prisma.JournalFollowsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalFollowsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFollowsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalFollowsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFollowsPayload>
          }
          findFirst: {
            args: Prisma.JournalFollowsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFollowsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalFollowsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFollowsPayload>
          }
          findMany: {
            args: Prisma.JournalFollowsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFollowsPayload>[]
          }
          create: {
            args: Prisma.JournalFollowsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFollowsPayload>
          }
          createMany: {
            args: Prisma.JournalFollowsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalFollowsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFollowsPayload>[]
          }
          delete: {
            args: Prisma.JournalFollowsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFollowsPayload>
          }
          update: {
            args: Prisma.JournalFollowsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFollowsPayload>
          }
          deleteMany: {
            args: Prisma.JournalFollowsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalFollowsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalFollowsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFollowsPayload>[]
          }
          upsert: {
            args: Prisma.JournalFollowsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFollowsPayload>
          }
          aggregate: {
            args: Prisma.JournalFollowsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalFollows>
          }
          groupBy: {
            args: Prisma.JournalFollowsGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalFollowsGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalFollowsCountArgs<ExtArgs>
            result: $Utils.Optional<JournalFollowsCountAggregateOutputType> | number
          }
        }
      }
      JournalLikes: {
        payload: Prisma.$JournalLikesPayload<ExtArgs>
        fields: Prisma.JournalLikesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalLikesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLikesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalLikesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLikesPayload>
          }
          findFirst: {
            args: Prisma.JournalLikesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLikesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalLikesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLikesPayload>
          }
          findMany: {
            args: Prisma.JournalLikesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLikesPayload>[]
          }
          create: {
            args: Prisma.JournalLikesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLikesPayload>
          }
          createMany: {
            args: Prisma.JournalLikesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalLikesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLikesPayload>[]
          }
          delete: {
            args: Prisma.JournalLikesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLikesPayload>
          }
          update: {
            args: Prisma.JournalLikesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLikesPayload>
          }
          deleteMany: {
            args: Prisma.JournalLikesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalLikesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalLikesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLikesPayload>[]
          }
          upsert: {
            args: Prisma.JournalLikesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLikesPayload>
          }
          aggregate: {
            args: Prisma.JournalLikesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalLikes>
          }
          groupBy: {
            args: Prisma.JournalLikesGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalLikesGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalLikesCountArgs<ExtArgs>
            result: $Utils.Optional<JournalLikesCountAggregateOutputType> | number
          }
        }
      }
      JournalRanks: {
        payload: Prisma.$JournalRanksPayload<ExtArgs>
        fields: Prisma.JournalRanksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalRanksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalRanksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalRanksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalRanksPayload>
          }
          findFirst: {
            args: Prisma.JournalRanksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalRanksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalRanksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalRanksPayload>
          }
          findMany: {
            args: Prisma.JournalRanksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalRanksPayload>[]
          }
          create: {
            args: Prisma.JournalRanksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalRanksPayload>
          }
          createMany: {
            args: Prisma.JournalRanksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalRanksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalRanksPayload>[]
          }
          delete: {
            args: Prisma.JournalRanksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalRanksPayload>
          }
          update: {
            args: Prisma.JournalRanksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalRanksPayload>
          }
          deleteMany: {
            args: Prisma.JournalRanksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalRanksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalRanksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalRanksPayload>[]
          }
          upsert: {
            args: Prisma.JournalRanksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalRanksPayload>
          }
          aggregate: {
            args: Prisma.JournalRanksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalRanks>
          }
          groupBy: {
            args: Prisma.JournalRanksGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalRanksGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalRanksCountArgs<ExtArgs>
            result: $Utils.Optional<JournalRanksCountAggregateOutputType> | number
          }
        }
      }
      JournalTopics: {
        payload: Prisma.$JournalTopicsPayload<ExtArgs>
        fields: Prisma.JournalTopicsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalTopicsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTopicsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalTopicsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTopicsPayload>
          }
          findFirst: {
            args: Prisma.JournalTopicsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTopicsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalTopicsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTopicsPayload>
          }
          findMany: {
            args: Prisma.JournalTopicsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTopicsPayload>[]
          }
          create: {
            args: Prisma.JournalTopicsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTopicsPayload>
          }
          createMany: {
            args: Prisma.JournalTopicsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalTopicsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTopicsPayload>[]
          }
          delete: {
            args: Prisma.JournalTopicsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTopicsPayload>
          }
          update: {
            args: Prisma.JournalTopicsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTopicsPayload>
          }
          deleteMany: {
            args: Prisma.JournalTopicsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalTopicsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalTopicsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTopicsPayload>[]
          }
          upsert: {
            args: Prisma.JournalTopicsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTopicsPayload>
          }
          aggregate: {
            args: Prisma.JournalTopicsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalTopics>
          }
          groupBy: {
            args: Prisma.JournalTopicsGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalTopicsGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalTopicsCountArgs<ExtArgs>
            result: $Utils.Optional<JournalTopicsCountAggregateOutputType> | number
          }
        }
      }
      Journals: {
        payload: Prisma.$JournalsPayload<ExtArgs>
        fields: Prisma.JournalsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalsPayload>
          }
          findFirst: {
            args: Prisma.JournalsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalsPayload>
          }
          findMany: {
            args: Prisma.JournalsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalsPayload>[]
          }
          create: {
            args: Prisma.JournalsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalsPayload>
          }
          createMany: {
            args: Prisma.JournalsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalsPayload>[]
          }
          delete: {
            args: Prisma.JournalsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalsPayload>
          }
          update: {
            args: Prisma.JournalsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalsPayload>
          }
          deleteMany: {
            args: Prisma.JournalsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalsPayload>[]
          }
          upsert: {
            args: Prisma.JournalsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalsPayload>
          }
          aggregate: {
            args: Prisma.JournalsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournals>
          }
          groupBy: {
            args: Prisma.JournalsGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalsGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalsCountArgs<ExtArgs>
            result: $Utils.Optional<JournalsCountAggregateOutputType> | number
          }
        }
      }
      Locations: {
        payload: Prisma.$LocationsPayload<ExtArgs>
        fields: Prisma.LocationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>
          }
          findFirst: {
            args: Prisma.LocationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>
          }
          findMany: {
            args: Prisma.LocationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>[]
          }
          create: {
            args: Prisma.LocationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>
          }
          createMany: {
            args: Prisma.LocationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>[]
          }
          delete: {
            args: Prisma.LocationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>
          }
          update: {
            args: Prisma.LocationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>
          }
          deleteMany: {
            args: Prisma.LocationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>[]
          }
          upsert: {
            args: Prisma.LocationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>
          }
          aggregate: {
            args: Prisma.LocationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocations>
          }
          groupBy: {
            args: Prisma.LocationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationsCountArgs<ExtArgs>
            result: $Utils.Optional<LocationsCountAggregateOutputType> | number
          }
        }
      }
      NotificationSettings: {
        payload: Prisma.$NotificationSettingsPayload<ExtArgs>
        fields: Prisma.NotificationSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          findFirst: {
            args: Prisma.NotificationSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          findMany: {
            args: Prisma.NotificationSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          create: {
            args: Prisma.NotificationSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          createMany: {
            args: Prisma.NotificationSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          delete: {
            args: Prisma.NotificationSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          update: {
            args: Prisma.NotificationSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          deleteMany: {
            args: Prisma.NotificationSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          upsert: {
            args: Prisma.NotificationSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          aggregate: {
            args: Prisma.NotificationSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationSettings>
          }
          groupBy: {
            args: Prisma.NotificationSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationSettingsCountAggregateOutputType> | number
          }
        }
      }
      Notifications: {
        payload: Prisma.$NotificationsPayload<ExtArgs>
        fields: Prisma.NotificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          findFirst: {
            args: Prisma.NotificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          findMany: {
            args: Prisma.NotificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>[]
          }
          create: {
            args: Prisma.NotificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          createMany: {
            args: Prisma.NotificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>[]
          }
          delete: {
            args: Prisma.NotificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          update: {
            args: Prisma.NotificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          deleteMany: {
            args: Prisma.NotificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>[]
          }
          upsert: {
            args: Prisma.NotificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.NotificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      NotificationsTypes: {
        payload: Prisma.$NotificationsTypesPayload<ExtArgs>
        fields: Prisma.NotificationsTypesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationsTypesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsTypesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationsTypesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsTypesPayload>
          }
          findFirst: {
            args: Prisma.NotificationsTypesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsTypesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationsTypesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsTypesPayload>
          }
          findMany: {
            args: Prisma.NotificationsTypesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsTypesPayload>[]
          }
          create: {
            args: Prisma.NotificationsTypesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsTypesPayload>
          }
          createMany: {
            args: Prisma.NotificationsTypesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationsTypesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsTypesPayload>[]
          }
          delete: {
            args: Prisma.NotificationsTypesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsTypesPayload>
          }
          update: {
            args: Prisma.NotificationsTypesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsTypesPayload>
          }
          deleteMany: {
            args: Prisma.NotificationsTypesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationsTypesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationsTypesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsTypesPayload>[]
          }
          upsert: {
            args: Prisma.NotificationsTypesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsTypesPayload>
          }
          aggregate: {
            args: Prisma.NotificationsTypesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationsTypes>
          }
          groupBy: {
            args: Prisma.NotificationsTypesGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsTypesGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationsTypesCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsTypesCountAggregateOutputType> | number
          }
        }
      }
      Passenger: {
        payload: Prisma.$PassengerPayload<ExtArgs>
        fields: Prisma.PassengerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PassengerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PassengerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          findFirst: {
            args: Prisma.PassengerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PassengerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          findMany: {
            args: Prisma.PassengerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>[]
          }
          create: {
            args: Prisma.PassengerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          createMany: {
            args: Prisma.PassengerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PassengerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>[]
          }
          delete: {
            args: Prisma.PassengerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          update: {
            args: Prisma.PassengerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          deleteMany: {
            args: Prisma.PassengerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PassengerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PassengerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>[]
          }
          upsert: {
            args: Prisma.PassengerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          aggregate: {
            args: Prisma.PassengerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePassenger>
          }
          groupBy: {
            args: Prisma.PassengerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PassengerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PassengerCountArgs<ExtArgs>
            result: $Utils.Optional<PassengerCountAggregateOutputType> | number
          }
        }
      }
      Ranks: {
        payload: Prisma.$RanksPayload<ExtArgs>
        fields: Prisma.RanksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RanksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RanksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RanksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RanksPayload>
          }
          findFirst: {
            args: Prisma.RanksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RanksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RanksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RanksPayload>
          }
          findMany: {
            args: Prisma.RanksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RanksPayload>[]
          }
          create: {
            args: Prisma.RanksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RanksPayload>
          }
          createMany: {
            args: Prisma.RanksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RanksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RanksPayload>[]
          }
          delete: {
            args: Prisma.RanksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RanksPayload>
          }
          update: {
            args: Prisma.RanksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RanksPayload>
          }
          deleteMany: {
            args: Prisma.RanksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RanksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RanksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RanksPayload>[]
          }
          upsert: {
            args: Prisma.RanksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RanksPayload>
          }
          aggregate: {
            args: Prisma.RanksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRanks>
          }
          groupBy: {
            args: Prisma.RanksGroupByArgs<ExtArgs>
            result: $Utils.Optional<RanksGroupByOutputType>[]
          }
          count: {
            args: Prisma.RanksCountArgs<ExtArgs>
            result: $Utils.Optional<RanksCountAggregateOutputType> | number
          }
        }
      }
      Sources: {
        payload: Prisma.$SourcesPayload<ExtArgs>
        fields: Prisma.SourcesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SourcesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SourcesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcesPayload>
          }
          findFirst: {
            args: Prisma.SourcesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SourcesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcesPayload>
          }
          findMany: {
            args: Prisma.SourcesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcesPayload>[]
          }
          create: {
            args: Prisma.SourcesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcesPayload>
          }
          createMany: {
            args: Prisma.SourcesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SourcesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcesPayload>[]
          }
          delete: {
            args: Prisma.SourcesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcesPayload>
          }
          update: {
            args: Prisma.SourcesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcesPayload>
          }
          deleteMany: {
            args: Prisma.SourcesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SourcesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SourcesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcesPayload>[]
          }
          upsert: {
            args: Prisma.SourcesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcesPayload>
          }
          aggregate: {
            args: Prisma.SourcesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSources>
          }
          groupBy: {
            args: Prisma.SourcesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SourcesGroupByOutputType>[]
          }
          count: {
            args: Prisma.SourcesCountArgs<ExtArgs>
            result: $Utils.Optional<SourcesCountAggregateOutputType> | number
          }
        }
      }
      TopicUserInteresteds: {
        payload: Prisma.$TopicUserInterestedsPayload<ExtArgs>
        fields: Prisma.TopicUserInterestedsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TopicUserInterestedsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicUserInterestedsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TopicUserInterestedsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicUserInterestedsPayload>
          }
          findFirst: {
            args: Prisma.TopicUserInterestedsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicUserInterestedsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TopicUserInterestedsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicUserInterestedsPayload>
          }
          findMany: {
            args: Prisma.TopicUserInterestedsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicUserInterestedsPayload>[]
          }
          create: {
            args: Prisma.TopicUserInterestedsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicUserInterestedsPayload>
          }
          createMany: {
            args: Prisma.TopicUserInterestedsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TopicUserInterestedsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicUserInterestedsPayload>[]
          }
          delete: {
            args: Prisma.TopicUserInterestedsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicUserInterestedsPayload>
          }
          update: {
            args: Prisma.TopicUserInterestedsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicUserInterestedsPayload>
          }
          deleteMany: {
            args: Prisma.TopicUserInterestedsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TopicUserInterestedsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TopicUserInterestedsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicUserInterestedsPayload>[]
          }
          upsert: {
            args: Prisma.TopicUserInterestedsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicUserInterestedsPayload>
          }
          aggregate: {
            args: Prisma.TopicUserInterestedsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTopicUserInteresteds>
          }
          groupBy: {
            args: Prisma.TopicUserInterestedsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TopicUserInterestedsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TopicUserInterestedsCountArgs<ExtArgs>
            result: $Utils.Optional<TopicUserInterestedsCountAggregateOutputType> | number
          }
        }
      }
      Topics: {
        payload: Prisma.$TopicsPayload<ExtArgs>
        fields: Prisma.TopicsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TopicsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TopicsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicsPayload>
          }
          findFirst: {
            args: Prisma.TopicsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TopicsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicsPayload>
          }
          findMany: {
            args: Prisma.TopicsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicsPayload>[]
          }
          create: {
            args: Prisma.TopicsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicsPayload>
          }
          createMany: {
            args: Prisma.TopicsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TopicsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicsPayload>[]
          }
          delete: {
            args: Prisma.TopicsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicsPayload>
          }
          update: {
            args: Prisma.TopicsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicsPayload>
          }
          deleteMany: {
            args: Prisma.TopicsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TopicsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TopicsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicsPayload>[]
          }
          upsert: {
            args: Prisma.TopicsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicsPayload>
          }
          aggregate: {
            args: Prisma.TopicsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTopics>
          }
          groupBy: {
            args: Prisma.TopicsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TopicsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TopicsCountArgs<ExtArgs>
            result: $Utils.Optional<TopicsCountAggregateOutputType> | number
          }
        }
      }
      UserVerification: {
        payload: Prisma.$UserVerificationPayload<ExtArgs>
        fields: Prisma.UserVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserVerificationPayload>
          }
          findFirst: {
            args: Prisma.UserVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserVerificationPayload>
          }
          findMany: {
            args: Prisma.UserVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserVerificationPayload>[]
          }
          create: {
            args: Prisma.UserVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserVerificationPayload>
          }
          createMany: {
            args: Prisma.UserVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserVerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserVerificationPayload>[]
          }
          delete: {
            args: Prisma.UserVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserVerificationPayload>
          }
          update: {
            args: Prisma.UserVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserVerificationPayload>
          }
          deleteMany: {
            args: Prisma.UserVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserVerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserVerificationPayload>[]
          }
          upsert: {
            args: Prisma.UserVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserVerificationPayload>
          }
          aggregate: {
            args: Prisma.UserVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserVerification>
          }
          groupBy: {
            args: Prisma.UserVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<UserVerificationCountAggregateOutputType> | number
          }
        }
      }
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    admins?: AdminsOmit
    conferenceBlacklists?: ConferenceBlacklistsOmit
    conferenceCalendars?: ConferenceCalendarsOmit
    conferenceCrawlJobs?: ConferenceCrawlJobsOmit
    conferenceDates?: ConferenceDatesOmit
    conferenceFeedbacks?: ConferenceFeedbacksOmit
    conferenceFollows?: ConferenceFollowsOmit
    conferenceLikes?: ConferenceLikesOmit
    conferenceOrganizations?: ConferenceOrganizationsOmit
    conferenceRanks?: ConferenceRanksOmit
    conferenceTopics?: ConferenceTopicsOmit
    conferences?: ConferencesOmit
    fieldOfResearchs?: FieldOfResearchsOmit
    journalCrawlJobs?: JournalCrawlJobsOmit
    journalFollows?: JournalFollowsOmit
    journalLikes?: JournalLikesOmit
    journalRanks?: JournalRanksOmit
    journalTopics?: JournalTopicsOmit
    journals?: JournalsOmit
    locations?: LocationsOmit
    notificationSettings?: NotificationSettingsOmit
    notifications?: NotificationsOmit
    notificationsTypes?: NotificationsTypesOmit
    passenger?: PassengerOmit
    ranks?: RanksOmit
    sources?: SourcesOmit
    topicUserInteresteds?: TopicUserInterestedsOmit
    topics?: TopicsOmit
    userVerification?: UserVerificationOmit
    users?: UsersOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AdminsCountOutputType
   */

  export type AdminsCountOutputType = {
    Conferences: number
  }

  export type AdminsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | AdminsCountOutputTypeCountConferencesArgs
  }

  // Custom InputTypes
  /**
   * AdminsCountOutputType without action
   */
  export type AdminsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminsCountOutputType
     */
    select?: AdminsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminsCountOutputType without action
   */
  export type AdminsCountOutputTypeCountConferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferencesWhereInput
  }


  /**
   * Count Type ConferenceOrganizationsCountOutputType
   */

  export type ConferenceOrganizationsCountOutputType = {
    ConferenceDates: number
    ConferenceTopics: number
    Locations: number
  }

  export type ConferenceOrganizationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConferenceDates?: boolean | ConferenceOrganizationsCountOutputTypeCountConferenceDatesArgs
    ConferenceTopics?: boolean | ConferenceOrganizationsCountOutputTypeCountConferenceTopicsArgs
    Locations?: boolean | ConferenceOrganizationsCountOutputTypeCountLocationsArgs
  }

  // Custom InputTypes
  /**
   * ConferenceOrganizationsCountOutputType without action
   */
  export type ConferenceOrganizationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizationsCountOutputType
     */
    select?: ConferenceOrganizationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConferenceOrganizationsCountOutputType without action
   */
  export type ConferenceOrganizationsCountOutputTypeCountConferenceDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceDatesWhereInput
  }

  /**
   * ConferenceOrganizationsCountOutputType without action
   */
  export type ConferenceOrganizationsCountOutputTypeCountConferenceTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceTopicsWhereInput
  }

  /**
   * ConferenceOrganizationsCountOutputType without action
   */
  export type ConferenceOrganizationsCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationsWhereInput
  }


  /**
   * Count Type ConferencesCountOutputType
   */

  export type ConferencesCountOutputType = {
    ConferenceBlacklists: number
    ConferenceCalendars: number
    ConferenceCrawlJobs: number
    ConferenceFeedbacks: number
    ConferenceFollows: number
    ConferenceLikes: number
    ConferenceOrganizations: number
    ConferenceRanks: number
  }

  export type ConferencesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConferenceBlacklists?: boolean | ConferencesCountOutputTypeCountConferenceBlacklistsArgs
    ConferenceCalendars?: boolean | ConferencesCountOutputTypeCountConferenceCalendarsArgs
    ConferenceCrawlJobs?: boolean | ConferencesCountOutputTypeCountConferenceCrawlJobsArgs
    ConferenceFeedbacks?: boolean | ConferencesCountOutputTypeCountConferenceFeedbacksArgs
    ConferenceFollows?: boolean | ConferencesCountOutputTypeCountConferenceFollowsArgs
    ConferenceLikes?: boolean | ConferencesCountOutputTypeCountConferenceLikesArgs
    ConferenceOrganizations?: boolean | ConferencesCountOutputTypeCountConferenceOrganizationsArgs
    ConferenceRanks?: boolean | ConferencesCountOutputTypeCountConferenceRanksArgs
  }

  // Custom InputTypes
  /**
   * ConferencesCountOutputType without action
   */
  export type ConferencesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferencesCountOutputType
     */
    select?: ConferencesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConferencesCountOutputType without action
   */
  export type ConferencesCountOutputTypeCountConferenceBlacklistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceBlacklistsWhereInput
  }

  /**
   * ConferencesCountOutputType without action
   */
  export type ConferencesCountOutputTypeCountConferenceCalendarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceCalendarsWhereInput
  }

  /**
   * ConferencesCountOutputType without action
   */
  export type ConferencesCountOutputTypeCountConferenceCrawlJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceCrawlJobsWhereInput
  }

  /**
   * ConferencesCountOutputType without action
   */
  export type ConferencesCountOutputTypeCountConferenceFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceFeedbacksWhereInput
  }

  /**
   * ConferencesCountOutputType without action
   */
  export type ConferencesCountOutputTypeCountConferenceFollowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceFollowsWhereInput
  }

  /**
   * ConferencesCountOutputType without action
   */
  export type ConferencesCountOutputTypeCountConferenceLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceLikesWhereInput
  }

  /**
   * ConferencesCountOutputType without action
   */
  export type ConferencesCountOutputTypeCountConferenceOrganizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceOrganizationsWhereInput
  }

  /**
   * ConferencesCountOutputType without action
   */
  export type ConferencesCountOutputTypeCountConferenceRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceRanksWhereInput
  }


  /**
   * Count Type FieldOfResearchsCountOutputType
   */

  export type FieldOfResearchsCountOutputType = {
    ConferenceRanks: number
    JournalRanks: number
  }

  export type FieldOfResearchsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConferenceRanks?: boolean | FieldOfResearchsCountOutputTypeCountConferenceRanksArgs
    JournalRanks?: boolean | FieldOfResearchsCountOutputTypeCountJournalRanksArgs
  }

  // Custom InputTypes
  /**
   * FieldOfResearchsCountOutputType without action
   */
  export type FieldOfResearchsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchsCountOutputType
     */
    select?: FieldOfResearchsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FieldOfResearchsCountOutputType without action
   */
  export type FieldOfResearchsCountOutputTypeCountConferenceRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceRanksWhereInput
  }

  /**
   * FieldOfResearchsCountOutputType without action
   */
  export type FieldOfResearchsCountOutputTypeCountJournalRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalRanksWhereInput
  }


  /**
   * Count Type JournalsCountOutputType
   */

  export type JournalsCountOutputType = {
    JournalCrawlJobs: number
    JournalFollows: number
    JournalLikes: number
    JournalRanks: number
    JournalTopics: number
  }

  export type JournalsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    JournalCrawlJobs?: boolean | JournalsCountOutputTypeCountJournalCrawlJobsArgs
    JournalFollows?: boolean | JournalsCountOutputTypeCountJournalFollowsArgs
    JournalLikes?: boolean | JournalsCountOutputTypeCountJournalLikesArgs
    JournalRanks?: boolean | JournalsCountOutputTypeCountJournalRanksArgs
    JournalTopics?: boolean | JournalsCountOutputTypeCountJournalTopicsArgs
  }

  // Custom InputTypes
  /**
   * JournalsCountOutputType without action
   */
  export type JournalsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalsCountOutputType
     */
    select?: JournalsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JournalsCountOutputType without action
   */
  export type JournalsCountOutputTypeCountJournalCrawlJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalCrawlJobsWhereInput
  }

  /**
   * JournalsCountOutputType without action
   */
  export type JournalsCountOutputTypeCountJournalFollowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalFollowsWhereInput
  }

  /**
   * JournalsCountOutputType without action
   */
  export type JournalsCountOutputTypeCountJournalLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalLikesWhereInput
  }

  /**
   * JournalsCountOutputType without action
   */
  export type JournalsCountOutputTypeCountJournalRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalRanksWhereInput
  }

  /**
   * JournalsCountOutputType without action
   */
  export type JournalsCountOutputTypeCountJournalTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalTopicsWhereInput
  }


  /**
   * Count Type NotificationsTypesCountOutputType
   */

  export type NotificationsTypesCountOutputType = {
    NotificationSettings: number
    Notifications: number
  }

  export type NotificationsTypesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    NotificationSettings?: boolean | NotificationsTypesCountOutputTypeCountNotificationSettingsArgs
    Notifications?: boolean | NotificationsTypesCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * NotificationsTypesCountOutputType without action
   */
  export type NotificationsTypesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationsTypesCountOutputType
     */
    select?: NotificationsTypesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotificationsTypesCountOutputType without action
   */
  export type NotificationsTypesCountOutputTypeCountNotificationSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationSettingsWhereInput
  }

  /**
   * NotificationsTypesCountOutputType without action
   */
  export type NotificationsTypesCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationsWhereInput
  }


  /**
   * Count Type RanksCountOutputType
   */

  export type RanksCountOutputType = {
    ConferenceRanks: number
    JournalRanks: number
  }

  export type RanksCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConferenceRanks?: boolean | RanksCountOutputTypeCountConferenceRanksArgs
    JournalRanks?: boolean | RanksCountOutputTypeCountJournalRanksArgs
  }

  // Custom InputTypes
  /**
   * RanksCountOutputType without action
   */
  export type RanksCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RanksCountOutputType
     */
    select?: RanksCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RanksCountOutputType without action
   */
  export type RanksCountOutputTypeCountConferenceRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceRanksWhereInput
  }

  /**
   * RanksCountOutputType without action
   */
  export type RanksCountOutputTypeCountJournalRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalRanksWhereInput
  }


  /**
   * Count Type SourcesCountOutputType
   */

  export type SourcesCountOutputType = {
    Ranks: number
  }

  export type SourcesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Ranks?: boolean | SourcesCountOutputTypeCountRanksArgs
  }

  // Custom InputTypes
  /**
   * SourcesCountOutputType without action
   */
  export type SourcesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourcesCountOutputType
     */
    select?: SourcesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SourcesCountOutputType without action
   */
  export type SourcesCountOutputTypeCountRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RanksWhereInput
  }


  /**
   * Count Type TopicsCountOutputType
   */

  export type TopicsCountOutputType = {
    ConferenceTopics: number
    JournalTopics: number
    TopicUserInteresteds: number
  }

  export type TopicsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConferenceTopics?: boolean | TopicsCountOutputTypeCountConferenceTopicsArgs
    JournalTopics?: boolean | TopicsCountOutputTypeCountJournalTopicsArgs
    TopicUserInteresteds?: boolean | TopicsCountOutputTypeCountTopicUserInterestedsArgs
  }

  // Custom InputTypes
  /**
   * TopicsCountOutputType without action
   */
  export type TopicsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicsCountOutputType
     */
    select?: TopicsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TopicsCountOutputType without action
   */
  export type TopicsCountOutputTypeCountConferenceTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceTopicsWhereInput
  }

  /**
   * TopicsCountOutputType without action
   */
  export type TopicsCountOutputTypeCountJournalTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalTopicsWhereInput
  }

  /**
   * TopicsCountOutputType without action
   */
  export type TopicsCountOutputTypeCountTopicUserInterestedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicUserInterestedsWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    ConferenceBlacklists: number
    ConferenceCalendars: number
    ConferenceFeedbacks: number
    ConferenceFollows: number
    ConferenceLikes: number
    Conferences: number
    JournalFollows: number
    JournalLikes: number
    Journals: number
    NotificationSettings: number
    Notifications: number
    TopicUserInteresteds: number
    UserVerification: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConferenceBlacklists?: boolean | UsersCountOutputTypeCountConferenceBlacklistsArgs
    ConferenceCalendars?: boolean | UsersCountOutputTypeCountConferenceCalendarsArgs
    ConferenceFeedbacks?: boolean | UsersCountOutputTypeCountConferenceFeedbacksArgs
    ConferenceFollows?: boolean | UsersCountOutputTypeCountConferenceFollowsArgs
    ConferenceLikes?: boolean | UsersCountOutputTypeCountConferenceLikesArgs
    Conferences?: boolean | UsersCountOutputTypeCountConferencesArgs
    JournalFollows?: boolean | UsersCountOutputTypeCountJournalFollowsArgs
    JournalLikes?: boolean | UsersCountOutputTypeCountJournalLikesArgs
    Journals?: boolean | UsersCountOutputTypeCountJournalsArgs
    NotificationSettings?: boolean | UsersCountOutputTypeCountNotificationSettingsArgs
    Notifications?: boolean | UsersCountOutputTypeCountNotificationsArgs
    TopicUserInteresteds?: boolean | UsersCountOutputTypeCountTopicUserInterestedsArgs
    UserVerification?: boolean | UsersCountOutputTypeCountUserVerificationArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountConferenceBlacklistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceBlacklistsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountConferenceCalendarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceCalendarsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountConferenceFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceFeedbacksWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountConferenceFollowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceFollowsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountConferenceLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceLikesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountConferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferencesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountJournalFollowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalFollowsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountJournalLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalLikesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountJournalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotificationSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationSettingsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTopicUserInterestedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicUserInterestedsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUserVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserVerificationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Admins
   */

  export type AggregateAdmins = {
    _count: AdminsCountAggregateOutputType | null
    _min: AdminsMinAggregateOutputType | null
    _max: AdminsMaxAggregateOutputType | null
  }

  export type AdminsMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    fullName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminsMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    fullName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminsCountAggregateOutputType = {
    id: number
    email: number
    password: number
    fullName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminsMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    fullName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminsMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    fullName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminsCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    fullName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to aggregate.
     */
    where?: AdminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminsOrderByWithRelationInput | AdminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminsMaxAggregateInputType
  }

  export type GetAdminsAggregateType<T extends AdminsAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmins]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmins[P]>
      : GetScalarType<T[P], AggregateAdmins[P]>
  }




  export type AdminsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminsWhereInput
    orderBy?: AdminsOrderByWithAggregationInput | AdminsOrderByWithAggregationInput[]
    by: AdminsScalarFieldEnum[] | AdminsScalarFieldEnum
    having?: AdminsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminsCountAggregateInputType | true
    _min?: AdminsMinAggregateInputType
    _max?: AdminsMaxAggregateInputType
  }

  export type AdminsGroupByOutputType = {
    id: string
    email: string
    password: string
    fullName: string
    createdAt: Date
    updatedAt: Date
    _count: AdminsCountAggregateOutputType | null
    _min: AdminsMinAggregateOutputType | null
    _max: AdminsMaxAggregateOutputType | null
  }

  type GetAdminsGroupByPayload<T extends AdminsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminsGroupByOutputType[P]>
            : GetScalarType<T[P], AdminsGroupByOutputType[P]>
        }
      >
    >


  export type AdminsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    fullName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Conferences?: boolean | Admins$ConferencesArgs<ExtArgs>
    _count?: boolean | AdminsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admins"]>

  export type AdminsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    fullName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["admins"]>

  export type AdminsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    fullName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["admins"]>

  export type AdminsSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    fullName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "fullName" | "createdAt" | "updatedAt", ExtArgs["result"]["admins"]>
  export type AdminsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | Admins$ConferencesArgs<ExtArgs>
    _count?: boolean | AdminsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AdminsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdminsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admins"
    objects: {
      Conferences: Prisma.$ConferencesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      fullName: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admins"]>
    composites: {}
  }

  type AdminsGetPayload<S extends boolean | null | undefined | AdminsDefaultArgs> = $Result.GetResult<Prisma.$AdminsPayload, S>

  type AdminsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminsCountAggregateInputType | true
    }

  export interface AdminsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admins'], meta: { name: 'Admins' } }
    /**
     * Find zero or one Admins that matches the filter.
     * @param {AdminsFindUniqueArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminsFindUniqueArgs>(args: SelectSubset<T, AdminsFindUniqueArgs<ExtArgs>>): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admins that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminsFindUniqueOrThrowArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminsFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsFindFirstArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminsFindFirstArgs>(args?: SelectSubset<T, AdminsFindFirstArgs<ExtArgs>>): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admins that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsFindFirstOrThrowArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminsFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admins.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admins.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminsWithIdOnly = await prisma.admins.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminsFindManyArgs>(args?: SelectSubset<T, AdminsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admins.
     * @param {AdminsCreateArgs} args - Arguments to create a Admins.
     * @example
     * // Create one Admins
     * const Admins = await prisma.admins.create({
     *   data: {
     *     // ... data to create a Admins
     *   }
     * })
     * 
     */
    create<T extends AdminsCreateArgs>(args: SelectSubset<T, AdminsCreateArgs<ExtArgs>>): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminsCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admins = await prisma.admins.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminsCreateManyArgs>(args?: SelectSubset<T, AdminsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminsCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admins = await prisma.admins.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminsWithIdOnly = await prisma.admins.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminsCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admins.
     * @param {AdminsDeleteArgs} args - Arguments to delete one Admins.
     * @example
     * // Delete one Admins
     * const Admins = await prisma.admins.delete({
     *   where: {
     *     // ... filter to delete one Admins
     *   }
     * })
     * 
     */
    delete<T extends AdminsDeleteArgs>(args: SelectSubset<T, AdminsDeleteArgs<ExtArgs>>): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admins.
     * @param {AdminsUpdateArgs} args - Arguments to update one Admins.
     * @example
     * // Update one Admins
     * const admins = await prisma.admins.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminsUpdateArgs>(args: SelectSubset<T, AdminsUpdateArgs<ExtArgs>>): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminsDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admins.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminsDeleteManyArgs>(args?: SelectSubset<T, AdminsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admins = await prisma.admins.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminsUpdateManyArgs>(args: SelectSubset<T, AdminsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminsUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admins = await prisma.admins.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminsWithIdOnly = await prisma.admins.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminsUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admins.
     * @param {AdminsUpsertArgs} args - Arguments to update or create a Admins.
     * @example
     * // Update or create a Admins
     * const admins = await prisma.admins.upsert({
     *   create: {
     *     // ... data to create a Admins
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admins we want to update
     *   }
     * })
     */
    upsert<T extends AdminsUpsertArgs>(args: SelectSubset<T, AdminsUpsertArgs<ExtArgs>>): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admins.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminsCountArgs>(
      args?: Subset<T, AdminsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminsAggregateArgs>(args: Subset<T, AdminsAggregateArgs>): Prisma.PrismaPromise<GetAdminsAggregateType<T>>

    /**
     * Group by Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminsGroupByArgs['orderBy'] }
        : { orderBy?: AdminsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admins model
   */
  readonly fields: AdminsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admins.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Conferences<T extends Admins$ConferencesArgs<ExtArgs> = {}>(args?: Subset<T, Admins$ConferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admins model
   */ 
  interface AdminsFieldRefs {
    readonly id: FieldRef<"Admins", 'String'>
    readonly email: FieldRef<"Admins", 'String'>
    readonly password: FieldRef<"Admins", 'String'>
    readonly fullName: FieldRef<"Admins", 'String'>
    readonly createdAt: FieldRef<"Admins", 'DateTime'>
    readonly updatedAt: FieldRef<"Admins", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admins findUnique
   */
  export type AdminsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admins
     */
    omit?: AdminsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where: AdminsWhereUniqueInput
  }

  /**
   * Admins findUniqueOrThrow
   */
  export type AdminsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admins
     */
    omit?: AdminsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where: AdminsWhereUniqueInput
  }

  /**
   * Admins findFirst
   */
  export type AdminsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admins
     */
    omit?: AdminsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminsOrderByWithRelationInput | AdminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminsScalarFieldEnum | AdminsScalarFieldEnum[]
  }

  /**
   * Admins findFirstOrThrow
   */
  export type AdminsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admins
     */
    omit?: AdminsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminsOrderByWithRelationInput | AdminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminsScalarFieldEnum | AdminsScalarFieldEnum[]
  }

  /**
   * Admins findMany
   */
  export type AdminsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admins
     */
    omit?: AdminsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminsOrderByWithRelationInput | AdminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminsScalarFieldEnum | AdminsScalarFieldEnum[]
  }

  /**
   * Admins create
   */
  export type AdminsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admins
     */
    omit?: AdminsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * The data needed to create a Admins.
     */
    data: XOR<AdminsCreateInput, AdminsUncheckedCreateInput>
  }

  /**
   * Admins createMany
   */
  export type AdminsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminsCreateManyInput | AdminsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admins createManyAndReturn
   */
  export type AdminsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admins
     */
    omit?: AdminsOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminsCreateManyInput | AdminsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admins update
   */
  export type AdminsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admins
     */
    omit?: AdminsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * The data needed to update a Admins.
     */
    data: XOR<AdminsUpdateInput, AdminsUncheckedUpdateInput>
    /**
     * Choose, which Admins to update.
     */
    where: AdminsWhereUniqueInput
  }

  /**
   * Admins updateMany
   */
  export type AdminsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminsUpdateManyMutationInput, AdminsUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminsWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admins updateManyAndReturn
   */
  export type AdminsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admins
     */
    omit?: AdminsOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminsUpdateManyMutationInput, AdminsUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminsWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admins upsert
   */
  export type AdminsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admins
     */
    omit?: AdminsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * The filter to search for the Admins to update in case it exists.
     */
    where: AdminsWhereUniqueInput
    /**
     * In case the Admins found by the `where` argument doesn't exist, create a new Admins with this data.
     */
    create: XOR<AdminsCreateInput, AdminsUncheckedCreateInput>
    /**
     * In case the Admins was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminsUpdateInput, AdminsUncheckedUpdateInput>
  }

  /**
   * Admins delete
   */
  export type AdminsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admins
     */
    omit?: AdminsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * Filter which Admins to delete.
     */
    where: AdminsWhereUniqueInput
  }

  /**
   * Admins deleteMany
   */
  export type AdminsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminsWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admins.Conferences
   */
  export type Admins$ConferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesInclude<ExtArgs> | null
    where?: ConferencesWhereInput
    orderBy?: ConferencesOrderByWithRelationInput | ConferencesOrderByWithRelationInput[]
    cursor?: ConferencesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferencesScalarFieldEnum | ConferencesScalarFieldEnum[]
  }

  /**
   * Admins without action
   */
  export type AdminsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admins
     */
    omit?: AdminsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
  }


  /**
   * Model ConferenceBlacklists
   */

  export type AggregateConferenceBlacklists = {
    _count: ConferenceBlacklistsCountAggregateOutputType | null
    _min: ConferenceBlacklistsMinAggregateOutputType | null
    _max: ConferenceBlacklistsMaxAggregateOutputType | null
  }

  export type ConferenceBlacklistsMinAggregateOutputType = {
    id: string | null
    conferenceId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceBlacklistsMaxAggregateOutputType = {
    id: string | null
    conferenceId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceBlacklistsCountAggregateOutputType = {
    id: number
    conferenceId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConferenceBlacklistsMinAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceBlacklistsMaxAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceBlacklistsCountAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConferenceBlacklistsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceBlacklists to aggregate.
     */
    where?: ConferenceBlacklistsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceBlacklists to fetch.
     */
    orderBy?: ConferenceBlacklistsOrderByWithRelationInput | ConferenceBlacklistsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferenceBlacklistsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceBlacklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceBlacklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConferenceBlacklists
    **/
    _count?: true | ConferenceBlacklistsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferenceBlacklistsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferenceBlacklistsMaxAggregateInputType
  }

  export type GetConferenceBlacklistsAggregateType<T extends ConferenceBlacklistsAggregateArgs> = {
        [P in keyof T & keyof AggregateConferenceBlacklists]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferenceBlacklists[P]>
      : GetScalarType<T[P], AggregateConferenceBlacklists[P]>
  }




  export type ConferenceBlacklistsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceBlacklistsWhereInput
    orderBy?: ConferenceBlacklistsOrderByWithAggregationInput | ConferenceBlacklistsOrderByWithAggregationInput[]
    by: ConferenceBlacklistsScalarFieldEnum[] | ConferenceBlacklistsScalarFieldEnum
    having?: ConferenceBlacklistsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferenceBlacklistsCountAggregateInputType | true
    _min?: ConferenceBlacklistsMinAggregateInputType
    _max?: ConferenceBlacklistsMaxAggregateInputType
  }

  export type ConferenceBlacklistsGroupByOutputType = {
    id: string
    conferenceId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: ConferenceBlacklistsCountAggregateOutputType | null
    _min: ConferenceBlacklistsMinAggregateOutputType | null
    _max: ConferenceBlacklistsMaxAggregateOutputType | null
  }

  type GetConferenceBlacklistsGroupByPayload<T extends ConferenceBlacklistsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferenceBlacklistsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferenceBlacklistsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferenceBlacklistsGroupByOutputType[P]>
            : GetScalarType<T[P], ConferenceBlacklistsGroupByOutputType[P]>
        }
      >
    >


  export type ConferenceBlacklistsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceBlacklists"]>

  export type ConferenceBlacklistsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceBlacklists"]>

  export type ConferenceBlacklistsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceBlacklists"]>

  export type ConferenceBlacklistsSelectScalar = {
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConferenceBlacklistsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conferenceId" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["conferenceBlacklists"]>
  export type ConferenceBlacklistsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ConferenceBlacklistsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ConferenceBlacklistsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $ConferenceBlacklistsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConferenceBlacklists"
    objects: {
      Conferences: Prisma.$ConferencesPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conferenceId: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conferenceBlacklists"]>
    composites: {}
  }

  type ConferenceBlacklistsGetPayload<S extends boolean | null | undefined | ConferenceBlacklistsDefaultArgs> = $Result.GetResult<Prisma.$ConferenceBlacklistsPayload, S>

  type ConferenceBlacklistsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferenceBlacklistsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferenceBlacklistsCountAggregateInputType | true
    }

  export interface ConferenceBlacklistsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConferenceBlacklists'], meta: { name: 'ConferenceBlacklists' } }
    /**
     * Find zero or one ConferenceBlacklists that matches the filter.
     * @param {ConferenceBlacklistsFindUniqueArgs} args - Arguments to find a ConferenceBlacklists
     * @example
     * // Get one ConferenceBlacklists
     * const conferenceBlacklists = await prisma.conferenceBlacklists.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferenceBlacklistsFindUniqueArgs>(args: SelectSubset<T, ConferenceBlacklistsFindUniqueArgs<ExtArgs>>): Prisma__ConferenceBlacklistsClient<$Result.GetResult<Prisma.$ConferenceBlacklistsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConferenceBlacklists that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferenceBlacklistsFindUniqueOrThrowArgs} args - Arguments to find a ConferenceBlacklists
     * @example
     * // Get one ConferenceBlacklists
     * const conferenceBlacklists = await prisma.conferenceBlacklists.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferenceBlacklistsFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferenceBlacklistsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferenceBlacklistsClient<$Result.GetResult<Prisma.$ConferenceBlacklistsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceBlacklists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceBlacklistsFindFirstArgs} args - Arguments to find a ConferenceBlacklists
     * @example
     * // Get one ConferenceBlacklists
     * const conferenceBlacklists = await prisma.conferenceBlacklists.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferenceBlacklistsFindFirstArgs>(args?: SelectSubset<T, ConferenceBlacklistsFindFirstArgs<ExtArgs>>): Prisma__ConferenceBlacklistsClient<$Result.GetResult<Prisma.$ConferenceBlacklistsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceBlacklists that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceBlacklistsFindFirstOrThrowArgs} args - Arguments to find a ConferenceBlacklists
     * @example
     * // Get one ConferenceBlacklists
     * const conferenceBlacklists = await prisma.conferenceBlacklists.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferenceBlacklistsFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferenceBlacklistsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferenceBlacklistsClient<$Result.GetResult<Prisma.$ConferenceBlacklistsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConferenceBlacklists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceBlacklistsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConferenceBlacklists
     * const conferenceBlacklists = await prisma.conferenceBlacklists.findMany()
     * 
     * // Get first 10 ConferenceBlacklists
     * const conferenceBlacklists = await prisma.conferenceBlacklists.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferenceBlacklistsWithIdOnly = await prisma.conferenceBlacklists.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferenceBlacklistsFindManyArgs>(args?: SelectSubset<T, ConferenceBlacklistsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceBlacklistsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConferenceBlacklists.
     * @param {ConferenceBlacklistsCreateArgs} args - Arguments to create a ConferenceBlacklists.
     * @example
     * // Create one ConferenceBlacklists
     * const ConferenceBlacklists = await prisma.conferenceBlacklists.create({
     *   data: {
     *     // ... data to create a ConferenceBlacklists
     *   }
     * })
     * 
     */
    create<T extends ConferenceBlacklistsCreateArgs>(args: SelectSubset<T, ConferenceBlacklistsCreateArgs<ExtArgs>>): Prisma__ConferenceBlacklistsClient<$Result.GetResult<Prisma.$ConferenceBlacklistsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConferenceBlacklists.
     * @param {ConferenceBlacklistsCreateManyArgs} args - Arguments to create many ConferenceBlacklists.
     * @example
     * // Create many ConferenceBlacklists
     * const conferenceBlacklists = await prisma.conferenceBlacklists.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferenceBlacklistsCreateManyArgs>(args?: SelectSubset<T, ConferenceBlacklistsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConferenceBlacklists and returns the data saved in the database.
     * @param {ConferenceBlacklistsCreateManyAndReturnArgs} args - Arguments to create many ConferenceBlacklists.
     * @example
     * // Create many ConferenceBlacklists
     * const conferenceBlacklists = await prisma.conferenceBlacklists.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConferenceBlacklists and only return the `id`
     * const conferenceBlacklistsWithIdOnly = await prisma.conferenceBlacklists.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferenceBlacklistsCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferenceBlacklistsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceBlacklistsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConferenceBlacklists.
     * @param {ConferenceBlacklistsDeleteArgs} args - Arguments to delete one ConferenceBlacklists.
     * @example
     * // Delete one ConferenceBlacklists
     * const ConferenceBlacklists = await prisma.conferenceBlacklists.delete({
     *   where: {
     *     // ... filter to delete one ConferenceBlacklists
     *   }
     * })
     * 
     */
    delete<T extends ConferenceBlacklistsDeleteArgs>(args: SelectSubset<T, ConferenceBlacklistsDeleteArgs<ExtArgs>>): Prisma__ConferenceBlacklistsClient<$Result.GetResult<Prisma.$ConferenceBlacklistsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConferenceBlacklists.
     * @param {ConferenceBlacklistsUpdateArgs} args - Arguments to update one ConferenceBlacklists.
     * @example
     * // Update one ConferenceBlacklists
     * const conferenceBlacklists = await prisma.conferenceBlacklists.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferenceBlacklistsUpdateArgs>(args: SelectSubset<T, ConferenceBlacklistsUpdateArgs<ExtArgs>>): Prisma__ConferenceBlacklistsClient<$Result.GetResult<Prisma.$ConferenceBlacklistsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConferenceBlacklists.
     * @param {ConferenceBlacklistsDeleteManyArgs} args - Arguments to filter ConferenceBlacklists to delete.
     * @example
     * // Delete a few ConferenceBlacklists
     * const { count } = await prisma.conferenceBlacklists.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferenceBlacklistsDeleteManyArgs>(args?: SelectSubset<T, ConferenceBlacklistsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceBlacklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceBlacklistsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConferenceBlacklists
     * const conferenceBlacklists = await prisma.conferenceBlacklists.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferenceBlacklistsUpdateManyArgs>(args: SelectSubset<T, ConferenceBlacklistsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceBlacklists and returns the data updated in the database.
     * @param {ConferenceBlacklistsUpdateManyAndReturnArgs} args - Arguments to update many ConferenceBlacklists.
     * @example
     * // Update many ConferenceBlacklists
     * const conferenceBlacklists = await prisma.conferenceBlacklists.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConferenceBlacklists and only return the `id`
     * const conferenceBlacklistsWithIdOnly = await prisma.conferenceBlacklists.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferenceBlacklistsUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferenceBlacklistsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceBlacklistsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConferenceBlacklists.
     * @param {ConferenceBlacklistsUpsertArgs} args - Arguments to update or create a ConferenceBlacklists.
     * @example
     * // Update or create a ConferenceBlacklists
     * const conferenceBlacklists = await prisma.conferenceBlacklists.upsert({
     *   create: {
     *     // ... data to create a ConferenceBlacklists
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConferenceBlacklists we want to update
     *   }
     * })
     */
    upsert<T extends ConferenceBlacklistsUpsertArgs>(args: SelectSubset<T, ConferenceBlacklistsUpsertArgs<ExtArgs>>): Prisma__ConferenceBlacklistsClient<$Result.GetResult<Prisma.$ConferenceBlacklistsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConferenceBlacklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceBlacklistsCountArgs} args - Arguments to filter ConferenceBlacklists to count.
     * @example
     * // Count the number of ConferenceBlacklists
     * const count = await prisma.conferenceBlacklists.count({
     *   where: {
     *     // ... the filter for the ConferenceBlacklists we want to count
     *   }
     * })
    **/
    count<T extends ConferenceBlacklistsCountArgs>(
      args?: Subset<T, ConferenceBlacklistsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferenceBlacklistsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConferenceBlacklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceBlacklistsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferenceBlacklistsAggregateArgs>(args: Subset<T, ConferenceBlacklistsAggregateArgs>): Prisma.PrismaPromise<GetConferenceBlacklistsAggregateType<T>>

    /**
     * Group by ConferenceBlacklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceBlacklistsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferenceBlacklistsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferenceBlacklistsGroupByArgs['orderBy'] }
        : { orderBy?: ConferenceBlacklistsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferenceBlacklistsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferenceBlacklistsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConferenceBlacklists model
   */
  readonly fields: ConferenceBlacklistsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConferenceBlacklists.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferenceBlacklistsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Conferences<T extends ConferencesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferencesDefaultArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConferenceBlacklists model
   */ 
  interface ConferenceBlacklistsFieldRefs {
    readonly id: FieldRef<"ConferenceBlacklists", 'String'>
    readonly conferenceId: FieldRef<"ConferenceBlacklists", 'String'>
    readonly userId: FieldRef<"ConferenceBlacklists", 'String'>
    readonly createdAt: FieldRef<"ConferenceBlacklists", 'DateTime'>
    readonly updatedAt: FieldRef<"ConferenceBlacklists", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConferenceBlacklists findUnique
   */
  export type ConferenceBlacklistsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceBlacklists
     */
    select?: ConferenceBlacklistsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceBlacklists
     */
    omit?: ConferenceBlacklistsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceBlacklistsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceBlacklists to fetch.
     */
    where: ConferenceBlacklistsWhereUniqueInput
  }

  /**
   * ConferenceBlacklists findUniqueOrThrow
   */
  export type ConferenceBlacklistsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceBlacklists
     */
    select?: ConferenceBlacklistsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceBlacklists
     */
    omit?: ConferenceBlacklistsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceBlacklistsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceBlacklists to fetch.
     */
    where: ConferenceBlacklistsWhereUniqueInput
  }

  /**
   * ConferenceBlacklists findFirst
   */
  export type ConferenceBlacklistsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceBlacklists
     */
    select?: ConferenceBlacklistsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceBlacklists
     */
    omit?: ConferenceBlacklistsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceBlacklistsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceBlacklists to fetch.
     */
    where?: ConferenceBlacklistsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceBlacklists to fetch.
     */
    orderBy?: ConferenceBlacklistsOrderByWithRelationInput | ConferenceBlacklistsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceBlacklists.
     */
    cursor?: ConferenceBlacklistsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceBlacklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceBlacklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceBlacklists.
     */
    distinct?: ConferenceBlacklistsScalarFieldEnum | ConferenceBlacklistsScalarFieldEnum[]
  }

  /**
   * ConferenceBlacklists findFirstOrThrow
   */
  export type ConferenceBlacklistsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceBlacklists
     */
    select?: ConferenceBlacklistsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceBlacklists
     */
    omit?: ConferenceBlacklistsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceBlacklistsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceBlacklists to fetch.
     */
    where?: ConferenceBlacklistsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceBlacklists to fetch.
     */
    orderBy?: ConferenceBlacklistsOrderByWithRelationInput | ConferenceBlacklistsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceBlacklists.
     */
    cursor?: ConferenceBlacklistsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceBlacklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceBlacklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceBlacklists.
     */
    distinct?: ConferenceBlacklistsScalarFieldEnum | ConferenceBlacklistsScalarFieldEnum[]
  }

  /**
   * ConferenceBlacklists findMany
   */
  export type ConferenceBlacklistsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceBlacklists
     */
    select?: ConferenceBlacklistsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceBlacklists
     */
    omit?: ConferenceBlacklistsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceBlacklistsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceBlacklists to fetch.
     */
    where?: ConferenceBlacklistsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceBlacklists to fetch.
     */
    orderBy?: ConferenceBlacklistsOrderByWithRelationInput | ConferenceBlacklistsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConferenceBlacklists.
     */
    cursor?: ConferenceBlacklistsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceBlacklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceBlacklists.
     */
    skip?: number
    distinct?: ConferenceBlacklistsScalarFieldEnum | ConferenceBlacklistsScalarFieldEnum[]
  }

  /**
   * ConferenceBlacklists create
   */
  export type ConferenceBlacklistsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceBlacklists
     */
    select?: ConferenceBlacklistsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceBlacklists
     */
    omit?: ConferenceBlacklistsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceBlacklistsInclude<ExtArgs> | null
    /**
     * The data needed to create a ConferenceBlacklists.
     */
    data: XOR<ConferenceBlacklistsCreateInput, ConferenceBlacklistsUncheckedCreateInput>
  }

  /**
   * ConferenceBlacklists createMany
   */
  export type ConferenceBlacklistsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConferenceBlacklists.
     */
    data: ConferenceBlacklistsCreateManyInput | ConferenceBlacklistsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConferenceBlacklists createManyAndReturn
   */
  export type ConferenceBlacklistsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceBlacklists
     */
    select?: ConferenceBlacklistsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceBlacklists
     */
    omit?: ConferenceBlacklistsOmit<ExtArgs> | null
    /**
     * The data used to create many ConferenceBlacklists.
     */
    data: ConferenceBlacklistsCreateManyInput | ConferenceBlacklistsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceBlacklistsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceBlacklists update
   */
  export type ConferenceBlacklistsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceBlacklists
     */
    select?: ConferenceBlacklistsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceBlacklists
     */
    omit?: ConferenceBlacklistsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceBlacklistsInclude<ExtArgs> | null
    /**
     * The data needed to update a ConferenceBlacklists.
     */
    data: XOR<ConferenceBlacklistsUpdateInput, ConferenceBlacklistsUncheckedUpdateInput>
    /**
     * Choose, which ConferenceBlacklists to update.
     */
    where: ConferenceBlacklistsWhereUniqueInput
  }

  /**
   * ConferenceBlacklists updateMany
   */
  export type ConferenceBlacklistsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConferenceBlacklists.
     */
    data: XOR<ConferenceBlacklistsUpdateManyMutationInput, ConferenceBlacklistsUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceBlacklists to update
     */
    where?: ConferenceBlacklistsWhereInput
    /**
     * Limit how many ConferenceBlacklists to update.
     */
    limit?: number
  }

  /**
   * ConferenceBlacklists updateManyAndReturn
   */
  export type ConferenceBlacklistsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceBlacklists
     */
    select?: ConferenceBlacklistsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceBlacklists
     */
    omit?: ConferenceBlacklistsOmit<ExtArgs> | null
    /**
     * The data used to update ConferenceBlacklists.
     */
    data: XOR<ConferenceBlacklistsUpdateManyMutationInput, ConferenceBlacklistsUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceBlacklists to update
     */
    where?: ConferenceBlacklistsWhereInput
    /**
     * Limit how many ConferenceBlacklists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceBlacklistsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceBlacklists upsert
   */
  export type ConferenceBlacklistsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceBlacklists
     */
    select?: ConferenceBlacklistsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceBlacklists
     */
    omit?: ConferenceBlacklistsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceBlacklistsInclude<ExtArgs> | null
    /**
     * The filter to search for the ConferenceBlacklists to update in case it exists.
     */
    where: ConferenceBlacklistsWhereUniqueInput
    /**
     * In case the ConferenceBlacklists found by the `where` argument doesn't exist, create a new ConferenceBlacklists with this data.
     */
    create: XOR<ConferenceBlacklistsCreateInput, ConferenceBlacklistsUncheckedCreateInput>
    /**
     * In case the ConferenceBlacklists was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferenceBlacklistsUpdateInput, ConferenceBlacklistsUncheckedUpdateInput>
  }

  /**
   * ConferenceBlacklists delete
   */
  export type ConferenceBlacklistsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceBlacklists
     */
    select?: ConferenceBlacklistsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceBlacklists
     */
    omit?: ConferenceBlacklistsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceBlacklistsInclude<ExtArgs> | null
    /**
     * Filter which ConferenceBlacklists to delete.
     */
    where: ConferenceBlacklistsWhereUniqueInput
  }

  /**
   * ConferenceBlacklists deleteMany
   */
  export type ConferenceBlacklistsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceBlacklists to delete
     */
    where?: ConferenceBlacklistsWhereInput
    /**
     * Limit how many ConferenceBlacklists to delete.
     */
    limit?: number
  }

  /**
   * ConferenceBlacklists without action
   */
  export type ConferenceBlacklistsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceBlacklists
     */
    select?: ConferenceBlacklistsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceBlacklists
     */
    omit?: ConferenceBlacklistsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceBlacklistsInclude<ExtArgs> | null
  }


  /**
   * Model ConferenceCalendars
   */

  export type AggregateConferenceCalendars = {
    _count: ConferenceCalendarsCountAggregateOutputType | null
    _min: ConferenceCalendarsMinAggregateOutputType | null
    _max: ConferenceCalendarsMaxAggregateOutputType | null
  }

  export type ConferenceCalendarsMinAggregateOutputType = {
    id: string | null
    conferenceId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceCalendarsMaxAggregateOutputType = {
    id: string | null
    conferenceId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceCalendarsCountAggregateOutputType = {
    id: number
    conferenceId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConferenceCalendarsMinAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceCalendarsMaxAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceCalendarsCountAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConferenceCalendarsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceCalendars to aggregate.
     */
    where?: ConferenceCalendarsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceCalendars to fetch.
     */
    orderBy?: ConferenceCalendarsOrderByWithRelationInput | ConferenceCalendarsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferenceCalendarsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceCalendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConferenceCalendars
    **/
    _count?: true | ConferenceCalendarsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferenceCalendarsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferenceCalendarsMaxAggregateInputType
  }

  export type GetConferenceCalendarsAggregateType<T extends ConferenceCalendarsAggregateArgs> = {
        [P in keyof T & keyof AggregateConferenceCalendars]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferenceCalendars[P]>
      : GetScalarType<T[P], AggregateConferenceCalendars[P]>
  }




  export type ConferenceCalendarsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceCalendarsWhereInput
    orderBy?: ConferenceCalendarsOrderByWithAggregationInput | ConferenceCalendarsOrderByWithAggregationInput[]
    by: ConferenceCalendarsScalarFieldEnum[] | ConferenceCalendarsScalarFieldEnum
    having?: ConferenceCalendarsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferenceCalendarsCountAggregateInputType | true
    _min?: ConferenceCalendarsMinAggregateInputType
    _max?: ConferenceCalendarsMaxAggregateInputType
  }

  export type ConferenceCalendarsGroupByOutputType = {
    id: string
    conferenceId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: ConferenceCalendarsCountAggregateOutputType | null
    _min: ConferenceCalendarsMinAggregateOutputType | null
    _max: ConferenceCalendarsMaxAggregateOutputType | null
  }

  type GetConferenceCalendarsGroupByPayload<T extends ConferenceCalendarsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferenceCalendarsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferenceCalendarsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferenceCalendarsGroupByOutputType[P]>
            : GetScalarType<T[P], ConferenceCalendarsGroupByOutputType[P]>
        }
      >
    >


  export type ConferenceCalendarsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceCalendars"]>

  export type ConferenceCalendarsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceCalendars"]>

  export type ConferenceCalendarsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceCalendars"]>

  export type ConferenceCalendarsSelectScalar = {
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConferenceCalendarsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conferenceId" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["conferenceCalendars"]>
  export type ConferenceCalendarsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ConferenceCalendarsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ConferenceCalendarsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $ConferenceCalendarsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConferenceCalendars"
    objects: {
      Conferences: Prisma.$ConferencesPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conferenceId: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conferenceCalendars"]>
    composites: {}
  }

  type ConferenceCalendarsGetPayload<S extends boolean | null | undefined | ConferenceCalendarsDefaultArgs> = $Result.GetResult<Prisma.$ConferenceCalendarsPayload, S>

  type ConferenceCalendarsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferenceCalendarsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferenceCalendarsCountAggregateInputType | true
    }

  export interface ConferenceCalendarsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConferenceCalendars'], meta: { name: 'ConferenceCalendars' } }
    /**
     * Find zero or one ConferenceCalendars that matches the filter.
     * @param {ConferenceCalendarsFindUniqueArgs} args - Arguments to find a ConferenceCalendars
     * @example
     * // Get one ConferenceCalendars
     * const conferenceCalendars = await prisma.conferenceCalendars.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferenceCalendarsFindUniqueArgs>(args: SelectSubset<T, ConferenceCalendarsFindUniqueArgs<ExtArgs>>): Prisma__ConferenceCalendarsClient<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConferenceCalendars that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferenceCalendarsFindUniqueOrThrowArgs} args - Arguments to find a ConferenceCalendars
     * @example
     * // Get one ConferenceCalendars
     * const conferenceCalendars = await prisma.conferenceCalendars.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferenceCalendarsFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferenceCalendarsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferenceCalendarsClient<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceCalendars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCalendarsFindFirstArgs} args - Arguments to find a ConferenceCalendars
     * @example
     * // Get one ConferenceCalendars
     * const conferenceCalendars = await prisma.conferenceCalendars.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferenceCalendarsFindFirstArgs>(args?: SelectSubset<T, ConferenceCalendarsFindFirstArgs<ExtArgs>>): Prisma__ConferenceCalendarsClient<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceCalendars that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCalendarsFindFirstOrThrowArgs} args - Arguments to find a ConferenceCalendars
     * @example
     * // Get one ConferenceCalendars
     * const conferenceCalendars = await prisma.conferenceCalendars.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferenceCalendarsFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferenceCalendarsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferenceCalendarsClient<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConferenceCalendars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCalendarsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConferenceCalendars
     * const conferenceCalendars = await prisma.conferenceCalendars.findMany()
     * 
     * // Get first 10 ConferenceCalendars
     * const conferenceCalendars = await prisma.conferenceCalendars.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferenceCalendarsWithIdOnly = await prisma.conferenceCalendars.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferenceCalendarsFindManyArgs>(args?: SelectSubset<T, ConferenceCalendarsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConferenceCalendars.
     * @param {ConferenceCalendarsCreateArgs} args - Arguments to create a ConferenceCalendars.
     * @example
     * // Create one ConferenceCalendars
     * const ConferenceCalendars = await prisma.conferenceCalendars.create({
     *   data: {
     *     // ... data to create a ConferenceCalendars
     *   }
     * })
     * 
     */
    create<T extends ConferenceCalendarsCreateArgs>(args: SelectSubset<T, ConferenceCalendarsCreateArgs<ExtArgs>>): Prisma__ConferenceCalendarsClient<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConferenceCalendars.
     * @param {ConferenceCalendarsCreateManyArgs} args - Arguments to create many ConferenceCalendars.
     * @example
     * // Create many ConferenceCalendars
     * const conferenceCalendars = await prisma.conferenceCalendars.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferenceCalendarsCreateManyArgs>(args?: SelectSubset<T, ConferenceCalendarsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConferenceCalendars and returns the data saved in the database.
     * @param {ConferenceCalendarsCreateManyAndReturnArgs} args - Arguments to create many ConferenceCalendars.
     * @example
     * // Create many ConferenceCalendars
     * const conferenceCalendars = await prisma.conferenceCalendars.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConferenceCalendars and only return the `id`
     * const conferenceCalendarsWithIdOnly = await prisma.conferenceCalendars.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferenceCalendarsCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferenceCalendarsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConferenceCalendars.
     * @param {ConferenceCalendarsDeleteArgs} args - Arguments to delete one ConferenceCalendars.
     * @example
     * // Delete one ConferenceCalendars
     * const ConferenceCalendars = await prisma.conferenceCalendars.delete({
     *   where: {
     *     // ... filter to delete one ConferenceCalendars
     *   }
     * })
     * 
     */
    delete<T extends ConferenceCalendarsDeleteArgs>(args: SelectSubset<T, ConferenceCalendarsDeleteArgs<ExtArgs>>): Prisma__ConferenceCalendarsClient<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConferenceCalendars.
     * @param {ConferenceCalendarsUpdateArgs} args - Arguments to update one ConferenceCalendars.
     * @example
     * // Update one ConferenceCalendars
     * const conferenceCalendars = await prisma.conferenceCalendars.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferenceCalendarsUpdateArgs>(args: SelectSubset<T, ConferenceCalendarsUpdateArgs<ExtArgs>>): Prisma__ConferenceCalendarsClient<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConferenceCalendars.
     * @param {ConferenceCalendarsDeleteManyArgs} args - Arguments to filter ConferenceCalendars to delete.
     * @example
     * // Delete a few ConferenceCalendars
     * const { count } = await prisma.conferenceCalendars.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferenceCalendarsDeleteManyArgs>(args?: SelectSubset<T, ConferenceCalendarsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceCalendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCalendarsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConferenceCalendars
     * const conferenceCalendars = await prisma.conferenceCalendars.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferenceCalendarsUpdateManyArgs>(args: SelectSubset<T, ConferenceCalendarsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceCalendars and returns the data updated in the database.
     * @param {ConferenceCalendarsUpdateManyAndReturnArgs} args - Arguments to update many ConferenceCalendars.
     * @example
     * // Update many ConferenceCalendars
     * const conferenceCalendars = await prisma.conferenceCalendars.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConferenceCalendars and only return the `id`
     * const conferenceCalendarsWithIdOnly = await prisma.conferenceCalendars.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferenceCalendarsUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferenceCalendarsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConferenceCalendars.
     * @param {ConferenceCalendarsUpsertArgs} args - Arguments to update or create a ConferenceCalendars.
     * @example
     * // Update or create a ConferenceCalendars
     * const conferenceCalendars = await prisma.conferenceCalendars.upsert({
     *   create: {
     *     // ... data to create a ConferenceCalendars
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConferenceCalendars we want to update
     *   }
     * })
     */
    upsert<T extends ConferenceCalendarsUpsertArgs>(args: SelectSubset<T, ConferenceCalendarsUpsertArgs<ExtArgs>>): Prisma__ConferenceCalendarsClient<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConferenceCalendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCalendarsCountArgs} args - Arguments to filter ConferenceCalendars to count.
     * @example
     * // Count the number of ConferenceCalendars
     * const count = await prisma.conferenceCalendars.count({
     *   where: {
     *     // ... the filter for the ConferenceCalendars we want to count
     *   }
     * })
    **/
    count<T extends ConferenceCalendarsCountArgs>(
      args?: Subset<T, ConferenceCalendarsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferenceCalendarsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConferenceCalendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCalendarsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferenceCalendarsAggregateArgs>(args: Subset<T, ConferenceCalendarsAggregateArgs>): Prisma.PrismaPromise<GetConferenceCalendarsAggregateType<T>>

    /**
     * Group by ConferenceCalendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCalendarsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferenceCalendarsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferenceCalendarsGroupByArgs['orderBy'] }
        : { orderBy?: ConferenceCalendarsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferenceCalendarsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferenceCalendarsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConferenceCalendars model
   */
  readonly fields: ConferenceCalendarsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConferenceCalendars.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferenceCalendarsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Conferences<T extends ConferencesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferencesDefaultArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConferenceCalendars model
   */ 
  interface ConferenceCalendarsFieldRefs {
    readonly id: FieldRef<"ConferenceCalendars", 'String'>
    readonly conferenceId: FieldRef<"ConferenceCalendars", 'String'>
    readonly userId: FieldRef<"ConferenceCalendars", 'String'>
    readonly createdAt: FieldRef<"ConferenceCalendars", 'DateTime'>
    readonly updatedAt: FieldRef<"ConferenceCalendars", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConferenceCalendars findUnique
   */
  export type ConferenceCalendarsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceCalendars to fetch.
     */
    where: ConferenceCalendarsWhereUniqueInput
  }

  /**
   * ConferenceCalendars findUniqueOrThrow
   */
  export type ConferenceCalendarsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceCalendars to fetch.
     */
    where: ConferenceCalendarsWhereUniqueInput
  }

  /**
   * ConferenceCalendars findFirst
   */
  export type ConferenceCalendarsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceCalendars to fetch.
     */
    where?: ConferenceCalendarsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceCalendars to fetch.
     */
    orderBy?: ConferenceCalendarsOrderByWithRelationInput | ConferenceCalendarsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceCalendars.
     */
    cursor?: ConferenceCalendarsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceCalendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceCalendars.
     */
    distinct?: ConferenceCalendarsScalarFieldEnum | ConferenceCalendarsScalarFieldEnum[]
  }

  /**
   * ConferenceCalendars findFirstOrThrow
   */
  export type ConferenceCalendarsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceCalendars to fetch.
     */
    where?: ConferenceCalendarsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceCalendars to fetch.
     */
    orderBy?: ConferenceCalendarsOrderByWithRelationInput | ConferenceCalendarsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceCalendars.
     */
    cursor?: ConferenceCalendarsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceCalendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceCalendars.
     */
    distinct?: ConferenceCalendarsScalarFieldEnum | ConferenceCalendarsScalarFieldEnum[]
  }

  /**
   * ConferenceCalendars findMany
   */
  export type ConferenceCalendarsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceCalendars to fetch.
     */
    where?: ConferenceCalendarsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceCalendars to fetch.
     */
    orderBy?: ConferenceCalendarsOrderByWithRelationInput | ConferenceCalendarsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConferenceCalendars.
     */
    cursor?: ConferenceCalendarsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceCalendars.
     */
    skip?: number
    distinct?: ConferenceCalendarsScalarFieldEnum | ConferenceCalendarsScalarFieldEnum[]
  }

  /**
   * ConferenceCalendars create
   */
  export type ConferenceCalendarsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsInclude<ExtArgs> | null
    /**
     * The data needed to create a ConferenceCalendars.
     */
    data: XOR<ConferenceCalendarsCreateInput, ConferenceCalendarsUncheckedCreateInput>
  }

  /**
   * ConferenceCalendars createMany
   */
  export type ConferenceCalendarsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConferenceCalendars.
     */
    data: ConferenceCalendarsCreateManyInput | ConferenceCalendarsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConferenceCalendars createManyAndReturn
   */
  export type ConferenceCalendarsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * The data used to create many ConferenceCalendars.
     */
    data: ConferenceCalendarsCreateManyInput | ConferenceCalendarsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceCalendars update
   */
  export type ConferenceCalendarsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsInclude<ExtArgs> | null
    /**
     * The data needed to update a ConferenceCalendars.
     */
    data: XOR<ConferenceCalendarsUpdateInput, ConferenceCalendarsUncheckedUpdateInput>
    /**
     * Choose, which ConferenceCalendars to update.
     */
    where: ConferenceCalendarsWhereUniqueInput
  }

  /**
   * ConferenceCalendars updateMany
   */
  export type ConferenceCalendarsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConferenceCalendars.
     */
    data: XOR<ConferenceCalendarsUpdateManyMutationInput, ConferenceCalendarsUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceCalendars to update
     */
    where?: ConferenceCalendarsWhereInput
    /**
     * Limit how many ConferenceCalendars to update.
     */
    limit?: number
  }

  /**
   * ConferenceCalendars updateManyAndReturn
   */
  export type ConferenceCalendarsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * The data used to update ConferenceCalendars.
     */
    data: XOR<ConferenceCalendarsUpdateManyMutationInput, ConferenceCalendarsUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceCalendars to update
     */
    where?: ConferenceCalendarsWhereInput
    /**
     * Limit how many ConferenceCalendars to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceCalendars upsert
   */
  export type ConferenceCalendarsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsInclude<ExtArgs> | null
    /**
     * The filter to search for the ConferenceCalendars to update in case it exists.
     */
    where: ConferenceCalendarsWhereUniqueInput
    /**
     * In case the ConferenceCalendars found by the `where` argument doesn't exist, create a new ConferenceCalendars with this data.
     */
    create: XOR<ConferenceCalendarsCreateInput, ConferenceCalendarsUncheckedCreateInput>
    /**
     * In case the ConferenceCalendars was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferenceCalendarsUpdateInput, ConferenceCalendarsUncheckedUpdateInput>
  }

  /**
   * ConferenceCalendars delete
   */
  export type ConferenceCalendarsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsInclude<ExtArgs> | null
    /**
     * Filter which ConferenceCalendars to delete.
     */
    where: ConferenceCalendarsWhereUniqueInput
  }

  /**
   * ConferenceCalendars deleteMany
   */
  export type ConferenceCalendarsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceCalendars to delete
     */
    where?: ConferenceCalendarsWhereInput
    /**
     * Limit how many ConferenceCalendars to delete.
     */
    limit?: number
  }

  /**
   * ConferenceCalendars without action
   */
  export type ConferenceCalendarsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsInclude<ExtArgs> | null
  }


  /**
   * Model ConferenceCrawlJobs
   */

  export type AggregateConferenceCrawlJobs = {
    _count: ConferenceCrawlJobsCountAggregateOutputType | null
    _avg: ConferenceCrawlJobsAvgAggregateOutputType | null
    _sum: ConferenceCrawlJobsSumAggregateOutputType | null
    _min: ConferenceCrawlJobsMinAggregateOutputType | null
    _max: ConferenceCrawlJobsMaxAggregateOutputType | null
  }

  export type ConferenceCrawlJobsAvgAggregateOutputType = {
    progress: number | null
  }

  export type ConferenceCrawlJobsSumAggregateOutputType = {
    progress: number | null
  }

  export type ConferenceCrawlJobsMinAggregateOutputType = {
    id: string | null
    conferenceId: string | null
    status: string | null
    progress: number | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceCrawlJobsMaxAggregateOutputType = {
    id: string | null
    conferenceId: string | null
    status: string | null
    progress: number | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceCrawlJobsCountAggregateOutputType = {
    id: number
    conferenceId: number
    status: number
    progress: number
    message: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConferenceCrawlJobsAvgAggregateInputType = {
    progress?: true
  }

  export type ConferenceCrawlJobsSumAggregateInputType = {
    progress?: true
  }

  export type ConferenceCrawlJobsMinAggregateInputType = {
    id?: true
    conferenceId?: true
    status?: true
    progress?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceCrawlJobsMaxAggregateInputType = {
    id?: true
    conferenceId?: true
    status?: true
    progress?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceCrawlJobsCountAggregateInputType = {
    id?: true
    conferenceId?: true
    status?: true
    progress?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConferenceCrawlJobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceCrawlJobs to aggregate.
     */
    where?: ConferenceCrawlJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceCrawlJobs to fetch.
     */
    orderBy?: ConferenceCrawlJobsOrderByWithRelationInput | ConferenceCrawlJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferenceCrawlJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceCrawlJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceCrawlJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConferenceCrawlJobs
    **/
    _count?: true | ConferenceCrawlJobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConferenceCrawlJobsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConferenceCrawlJobsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferenceCrawlJobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferenceCrawlJobsMaxAggregateInputType
  }

  export type GetConferenceCrawlJobsAggregateType<T extends ConferenceCrawlJobsAggregateArgs> = {
        [P in keyof T & keyof AggregateConferenceCrawlJobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferenceCrawlJobs[P]>
      : GetScalarType<T[P], AggregateConferenceCrawlJobs[P]>
  }




  export type ConferenceCrawlJobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceCrawlJobsWhereInput
    orderBy?: ConferenceCrawlJobsOrderByWithAggregationInput | ConferenceCrawlJobsOrderByWithAggregationInput[]
    by: ConferenceCrawlJobsScalarFieldEnum[] | ConferenceCrawlJobsScalarFieldEnum
    having?: ConferenceCrawlJobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferenceCrawlJobsCountAggregateInputType | true
    _avg?: ConferenceCrawlJobsAvgAggregateInputType
    _sum?: ConferenceCrawlJobsSumAggregateInputType
    _min?: ConferenceCrawlJobsMinAggregateInputType
    _max?: ConferenceCrawlJobsMaxAggregateInputType
  }

  export type ConferenceCrawlJobsGroupByOutputType = {
    id: string
    conferenceId: string
    status: string
    progress: number
    message: string
    createdAt: Date
    updatedAt: Date
    _count: ConferenceCrawlJobsCountAggregateOutputType | null
    _avg: ConferenceCrawlJobsAvgAggregateOutputType | null
    _sum: ConferenceCrawlJobsSumAggregateOutputType | null
    _min: ConferenceCrawlJobsMinAggregateOutputType | null
    _max: ConferenceCrawlJobsMaxAggregateOutputType | null
  }

  type GetConferenceCrawlJobsGroupByPayload<T extends ConferenceCrawlJobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferenceCrawlJobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferenceCrawlJobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferenceCrawlJobsGroupByOutputType[P]>
            : GetScalarType<T[P], ConferenceCrawlJobsGroupByOutputType[P]>
        }
      >
    >


  export type ConferenceCrawlJobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    status?: boolean
    progress?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceCrawlJobs"]>

  export type ConferenceCrawlJobsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    status?: boolean
    progress?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceCrawlJobs"]>

  export type ConferenceCrawlJobsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    status?: boolean
    progress?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceCrawlJobs"]>

  export type ConferenceCrawlJobsSelectScalar = {
    id?: boolean
    conferenceId?: boolean
    status?: boolean
    progress?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConferenceCrawlJobsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conferenceId" | "status" | "progress" | "message" | "createdAt" | "updatedAt", ExtArgs["result"]["conferenceCrawlJobs"]>
  export type ConferenceCrawlJobsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
  }
  export type ConferenceCrawlJobsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
  }
  export type ConferenceCrawlJobsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
  }

  export type $ConferenceCrawlJobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConferenceCrawlJobs"
    objects: {
      Conferences: Prisma.$ConferencesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conferenceId: string
      status: string
      progress: number
      message: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conferenceCrawlJobs"]>
    composites: {}
  }

  type ConferenceCrawlJobsGetPayload<S extends boolean | null | undefined | ConferenceCrawlJobsDefaultArgs> = $Result.GetResult<Prisma.$ConferenceCrawlJobsPayload, S>

  type ConferenceCrawlJobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferenceCrawlJobsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferenceCrawlJobsCountAggregateInputType | true
    }

  export interface ConferenceCrawlJobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConferenceCrawlJobs'], meta: { name: 'ConferenceCrawlJobs' } }
    /**
     * Find zero or one ConferenceCrawlJobs that matches the filter.
     * @param {ConferenceCrawlJobsFindUniqueArgs} args - Arguments to find a ConferenceCrawlJobs
     * @example
     * // Get one ConferenceCrawlJobs
     * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferenceCrawlJobsFindUniqueArgs>(args: SelectSubset<T, ConferenceCrawlJobsFindUniqueArgs<ExtArgs>>): Prisma__ConferenceCrawlJobsClient<$Result.GetResult<Prisma.$ConferenceCrawlJobsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConferenceCrawlJobs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferenceCrawlJobsFindUniqueOrThrowArgs} args - Arguments to find a ConferenceCrawlJobs
     * @example
     * // Get one ConferenceCrawlJobs
     * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferenceCrawlJobsFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferenceCrawlJobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferenceCrawlJobsClient<$Result.GetResult<Prisma.$ConferenceCrawlJobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceCrawlJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCrawlJobsFindFirstArgs} args - Arguments to find a ConferenceCrawlJobs
     * @example
     * // Get one ConferenceCrawlJobs
     * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferenceCrawlJobsFindFirstArgs>(args?: SelectSubset<T, ConferenceCrawlJobsFindFirstArgs<ExtArgs>>): Prisma__ConferenceCrawlJobsClient<$Result.GetResult<Prisma.$ConferenceCrawlJobsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceCrawlJobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCrawlJobsFindFirstOrThrowArgs} args - Arguments to find a ConferenceCrawlJobs
     * @example
     * // Get one ConferenceCrawlJobs
     * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferenceCrawlJobsFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferenceCrawlJobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferenceCrawlJobsClient<$Result.GetResult<Prisma.$ConferenceCrawlJobsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConferenceCrawlJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCrawlJobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConferenceCrawlJobs
     * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.findMany()
     * 
     * // Get first 10 ConferenceCrawlJobs
     * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferenceCrawlJobsWithIdOnly = await prisma.conferenceCrawlJobs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferenceCrawlJobsFindManyArgs>(args?: SelectSubset<T, ConferenceCrawlJobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceCrawlJobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConferenceCrawlJobs.
     * @param {ConferenceCrawlJobsCreateArgs} args - Arguments to create a ConferenceCrawlJobs.
     * @example
     * // Create one ConferenceCrawlJobs
     * const ConferenceCrawlJobs = await prisma.conferenceCrawlJobs.create({
     *   data: {
     *     // ... data to create a ConferenceCrawlJobs
     *   }
     * })
     * 
     */
    create<T extends ConferenceCrawlJobsCreateArgs>(args: SelectSubset<T, ConferenceCrawlJobsCreateArgs<ExtArgs>>): Prisma__ConferenceCrawlJobsClient<$Result.GetResult<Prisma.$ConferenceCrawlJobsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConferenceCrawlJobs.
     * @param {ConferenceCrawlJobsCreateManyArgs} args - Arguments to create many ConferenceCrawlJobs.
     * @example
     * // Create many ConferenceCrawlJobs
     * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferenceCrawlJobsCreateManyArgs>(args?: SelectSubset<T, ConferenceCrawlJobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConferenceCrawlJobs and returns the data saved in the database.
     * @param {ConferenceCrawlJobsCreateManyAndReturnArgs} args - Arguments to create many ConferenceCrawlJobs.
     * @example
     * // Create many ConferenceCrawlJobs
     * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConferenceCrawlJobs and only return the `id`
     * const conferenceCrawlJobsWithIdOnly = await prisma.conferenceCrawlJobs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferenceCrawlJobsCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferenceCrawlJobsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceCrawlJobsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConferenceCrawlJobs.
     * @param {ConferenceCrawlJobsDeleteArgs} args - Arguments to delete one ConferenceCrawlJobs.
     * @example
     * // Delete one ConferenceCrawlJobs
     * const ConferenceCrawlJobs = await prisma.conferenceCrawlJobs.delete({
     *   where: {
     *     // ... filter to delete one ConferenceCrawlJobs
     *   }
     * })
     * 
     */
    delete<T extends ConferenceCrawlJobsDeleteArgs>(args: SelectSubset<T, ConferenceCrawlJobsDeleteArgs<ExtArgs>>): Prisma__ConferenceCrawlJobsClient<$Result.GetResult<Prisma.$ConferenceCrawlJobsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConferenceCrawlJobs.
     * @param {ConferenceCrawlJobsUpdateArgs} args - Arguments to update one ConferenceCrawlJobs.
     * @example
     * // Update one ConferenceCrawlJobs
     * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferenceCrawlJobsUpdateArgs>(args: SelectSubset<T, ConferenceCrawlJobsUpdateArgs<ExtArgs>>): Prisma__ConferenceCrawlJobsClient<$Result.GetResult<Prisma.$ConferenceCrawlJobsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConferenceCrawlJobs.
     * @param {ConferenceCrawlJobsDeleteManyArgs} args - Arguments to filter ConferenceCrawlJobs to delete.
     * @example
     * // Delete a few ConferenceCrawlJobs
     * const { count } = await prisma.conferenceCrawlJobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferenceCrawlJobsDeleteManyArgs>(args?: SelectSubset<T, ConferenceCrawlJobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceCrawlJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCrawlJobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConferenceCrawlJobs
     * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferenceCrawlJobsUpdateManyArgs>(args: SelectSubset<T, ConferenceCrawlJobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceCrawlJobs and returns the data updated in the database.
     * @param {ConferenceCrawlJobsUpdateManyAndReturnArgs} args - Arguments to update many ConferenceCrawlJobs.
     * @example
     * // Update many ConferenceCrawlJobs
     * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConferenceCrawlJobs and only return the `id`
     * const conferenceCrawlJobsWithIdOnly = await prisma.conferenceCrawlJobs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferenceCrawlJobsUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferenceCrawlJobsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceCrawlJobsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConferenceCrawlJobs.
     * @param {ConferenceCrawlJobsUpsertArgs} args - Arguments to update or create a ConferenceCrawlJobs.
     * @example
     * // Update or create a ConferenceCrawlJobs
     * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.upsert({
     *   create: {
     *     // ... data to create a ConferenceCrawlJobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConferenceCrawlJobs we want to update
     *   }
     * })
     */
    upsert<T extends ConferenceCrawlJobsUpsertArgs>(args: SelectSubset<T, ConferenceCrawlJobsUpsertArgs<ExtArgs>>): Prisma__ConferenceCrawlJobsClient<$Result.GetResult<Prisma.$ConferenceCrawlJobsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConferenceCrawlJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCrawlJobsCountArgs} args - Arguments to filter ConferenceCrawlJobs to count.
     * @example
     * // Count the number of ConferenceCrawlJobs
     * const count = await prisma.conferenceCrawlJobs.count({
     *   where: {
     *     // ... the filter for the ConferenceCrawlJobs we want to count
     *   }
     * })
    **/
    count<T extends ConferenceCrawlJobsCountArgs>(
      args?: Subset<T, ConferenceCrawlJobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferenceCrawlJobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConferenceCrawlJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCrawlJobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferenceCrawlJobsAggregateArgs>(args: Subset<T, ConferenceCrawlJobsAggregateArgs>): Prisma.PrismaPromise<GetConferenceCrawlJobsAggregateType<T>>

    /**
     * Group by ConferenceCrawlJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCrawlJobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferenceCrawlJobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferenceCrawlJobsGroupByArgs['orderBy'] }
        : { orderBy?: ConferenceCrawlJobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferenceCrawlJobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferenceCrawlJobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConferenceCrawlJobs model
   */
  readonly fields: ConferenceCrawlJobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConferenceCrawlJobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferenceCrawlJobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Conferences<T extends ConferencesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferencesDefaultArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConferenceCrawlJobs model
   */ 
  interface ConferenceCrawlJobsFieldRefs {
    readonly id: FieldRef<"ConferenceCrawlJobs", 'String'>
    readonly conferenceId: FieldRef<"ConferenceCrawlJobs", 'String'>
    readonly status: FieldRef<"ConferenceCrawlJobs", 'String'>
    readonly progress: FieldRef<"ConferenceCrawlJobs", 'Int'>
    readonly message: FieldRef<"ConferenceCrawlJobs", 'String'>
    readonly createdAt: FieldRef<"ConferenceCrawlJobs", 'DateTime'>
    readonly updatedAt: FieldRef<"ConferenceCrawlJobs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConferenceCrawlJobs findUnique
   */
  export type ConferenceCrawlJobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceCrawlJobs to fetch.
     */
    where: ConferenceCrawlJobsWhereUniqueInput
  }

  /**
   * ConferenceCrawlJobs findUniqueOrThrow
   */
  export type ConferenceCrawlJobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceCrawlJobs to fetch.
     */
    where: ConferenceCrawlJobsWhereUniqueInput
  }

  /**
   * ConferenceCrawlJobs findFirst
   */
  export type ConferenceCrawlJobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceCrawlJobs to fetch.
     */
    where?: ConferenceCrawlJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceCrawlJobs to fetch.
     */
    orderBy?: ConferenceCrawlJobsOrderByWithRelationInput | ConferenceCrawlJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceCrawlJobs.
     */
    cursor?: ConferenceCrawlJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceCrawlJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceCrawlJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceCrawlJobs.
     */
    distinct?: ConferenceCrawlJobsScalarFieldEnum | ConferenceCrawlJobsScalarFieldEnum[]
  }

  /**
   * ConferenceCrawlJobs findFirstOrThrow
   */
  export type ConferenceCrawlJobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceCrawlJobs to fetch.
     */
    where?: ConferenceCrawlJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceCrawlJobs to fetch.
     */
    orderBy?: ConferenceCrawlJobsOrderByWithRelationInput | ConferenceCrawlJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceCrawlJobs.
     */
    cursor?: ConferenceCrawlJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceCrawlJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceCrawlJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceCrawlJobs.
     */
    distinct?: ConferenceCrawlJobsScalarFieldEnum | ConferenceCrawlJobsScalarFieldEnum[]
  }

  /**
   * ConferenceCrawlJobs findMany
   */
  export type ConferenceCrawlJobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceCrawlJobs to fetch.
     */
    where?: ConferenceCrawlJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceCrawlJobs to fetch.
     */
    orderBy?: ConferenceCrawlJobsOrderByWithRelationInput | ConferenceCrawlJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConferenceCrawlJobs.
     */
    cursor?: ConferenceCrawlJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceCrawlJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceCrawlJobs.
     */
    skip?: number
    distinct?: ConferenceCrawlJobsScalarFieldEnum | ConferenceCrawlJobsScalarFieldEnum[]
  }

  /**
   * ConferenceCrawlJobs create
   */
  export type ConferenceCrawlJobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsInclude<ExtArgs> | null
    /**
     * The data needed to create a ConferenceCrawlJobs.
     */
    data: XOR<ConferenceCrawlJobsCreateInput, ConferenceCrawlJobsUncheckedCreateInput>
  }

  /**
   * ConferenceCrawlJobs createMany
   */
  export type ConferenceCrawlJobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConferenceCrawlJobs.
     */
    data: ConferenceCrawlJobsCreateManyInput | ConferenceCrawlJobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConferenceCrawlJobs createManyAndReturn
   */
  export type ConferenceCrawlJobsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * The data used to create many ConferenceCrawlJobs.
     */
    data: ConferenceCrawlJobsCreateManyInput | ConferenceCrawlJobsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceCrawlJobs update
   */
  export type ConferenceCrawlJobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsInclude<ExtArgs> | null
    /**
     * The data needed to update a ConferenceCrawlJobs.
     */
    data: XOR<ConferenceCrawlJobsUpdateInput, ConferenceCrawlJobsUncheckedUpdateInput>
    /**
     * Choose, which ConferenceCrawlJobs to update.
     */
    where: ConferenceCrawlJobsWhereUniqueInput
  }

  /**
   * ConferenceCrawlJobs updateMany
   */
  export type ConferenceCrawlJobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConferenceCrawlJobs.
     */
    data: XOR<ConferenceCrawlJobsUpdateManyMutationInput, ConferenceCrawlJobsUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceCrawlJobs to update
     */
    where?: ConferenceCrawlJobsWhereInput
    /**
     * Limit how many ConferenceCrawlJobs to update.
     */
    limit?: number
  }

  /**
   * ConferenceCrawlJobs updateManyAndReturn
   */
  export type ConferenceCrawlJobsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * The data used to update ConferenceCrawlJobs.
     */
    data: XOR<ConferenceCrawlJobsUpdateManyMutationInput, ConferenceCrawlJobsUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceCrawlJobs to update
     */
    where?: ConferenceCrawlJobsWhereInput
    /**
     * Limit how many ConferenceCrawlJobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceCrawlJobs upsert
   */
  export type ConferenceCrawlJobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsInclude<ExtArgs> | null
    /**
     * The filter to search for the ConferenceCrawlJobs to update in case it exists.
     */
    where: ConferenceCrawlJobsWhereUniqueInput
    /**
     * In case the ConferenceCrawlJobs found by the `where` argument doesn't exist, create a new ConferenceCrawlJobs with this data.
     */
    create: XOR<ConferenceCrawlJobsCreateInput, ConferenceCrawlJobsUncheckedCreateInput>
    /**
     * In case the ConferenceCrawlJobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferenceCrawlJobsUpdateInput, ConferenceCrawlJobsUncheckedUpdateInput>
  }

  /**
   * ConferenceCrawlJobs delete
   */
  export type ConferenceCrawlJobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsInclude<ExtArgs> | null
    /**
     * Filter which ConferenceCrawlJobs to delete.
     */
    where: ConferenceCrawlJobsWhereUniqueInput
  }

  /**
   * ConferenceCrawlJobs deleteMany
   */
  export type ConferenceCrawlJobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceCrawlJobs to delete
     */
    where?: ConferenceCrawlJobsWhereInput
    /**
     * Limit how many ConferenceCrawlJobs to delete.
     */
    limit?: number
  }

  /**
   * ConferenceCrawlJobs without action
   */
  export type ConferenceCrawlJobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsInclude<ExtArgs> | null
  }


  /**
   * Model ConferenceDates
   */

  export type AggregateConferenceDates = {
    _count: ConferenceDatesCountAggregateOutputType | null
    _min: ConferenceDatesMinAggregateOutputType | null
    _max: ConferenceDatesMaxAggregateOutputType | null
  }

  export type ConferenceDatesMinAggregateOutputType = {
    id: string | null
    organizedId: string | null
    fromDate: Date | null
    toDate: Date | null
    type: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isAvailable: boolean | null
  }

  export type ConferenceDatesMaxAggregateOutputType = {
    id: string | null
    organizedId: string | null
    fromDate: Date | null
    toDate: Date | null
    type: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isAvailable: boolean | null
  }

  export type ConferenceDatesCountAggregateOutputType = {
    id: number
    organizedId: number
    fromDate: number
    toDate: number
    type: number
    name: number
    createdAt: number
    updatedAt: number
    isAvailable: number
    _all: number
  }


  export type ConferenceDatesMinAggregateInputType = {
    id?: true
    organizedId?: true
    fromDate?: true
    toDate?: true
    type?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    isAvailable?: true
  }

  export type ConferenceDatesMaxAggregateInputType = {
    id?: true
    organizedId?: true
    fromDate?: true
    toDate?: true
    type?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    isAvailable?: true
  }

  export type ConferenceDatesCountAggregateInputType = {
    id?: true
    organizedId?: true
    fromDate?: true
    toDate?: true
    type?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    isAvailable?: true
    _all?: true
  }

  export type ConferenceDatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceDates to aggregate.
     */
    where?: ConferenceDatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceDates to fetch.
     */
    orderBy?: ConferenceDatesOrderByWithRelationInput | ConferenceDatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferenceDatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConferenceDates
    **/
    _count?: true | ConferenceDatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferenceDatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferenceDatesMaxAggregateInputType
  }

  export type GetConferenceDatesAggregateType<T extends ConferenceDatesAggregateArgs> = {
        [P in keyof T & keyof AggregateConferenceDates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferenceDates[P]>
      : GetScalarType<T[P], AggregateConferenceDates[P]>
  }




  export type ConferenceDatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceDatesWhereInput
    orderBy?: ConferenceDatesOrderByWithAggregationInput | ConferenceDatesOrderByWithAggregationInput[]
    by: ConferenceDatesScalarFieldEnum[] | ConferenceDatesScalarFieldEnum
    having?: ConferenceDatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferenceDatesCountAggregateInputType | true
    _min?: ConferenceDatesMinAggregateInputType
    _max?: ConferenceDatesMaxAggregateInputType
  }

  export type ConferenceDatesGroupByOutputType = {
    id: string
    organizedId: string
    fromDate: Date
    toDate: Date
    type: string
    name: string
    createdAt: Date
    updatedAt: Date
    isAvailable: boolean
    _count: ConferenceDatesCountAggregateOutputType | null
    _min: ConferenceDatesMinAggregateOutputType | null
    _max: ConferenceDatesMaxAggregateOutputType | null
  }

  type GetConferenceDatesGroupByPayload<T extends ConferenceDatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferenceDatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferenceDatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferenceDatesGroupByOutputType[P]>
            : GetScalarType<T[P], ConferenceDatesGroupByOutputType[P]>
        }
      >
    >


  export type ConferenceDatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizedId?: boolean
    fromDate?: boolean
    toDate?: boolean
    type?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAvailable?: boolean
    ConferenceOrganizations?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceDates"]>

  export type ConferenceDatesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizedId?: boolean
    fromDate?: boolean
    toDate?: boolean
    type?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAvailable?: boolean
    ConferenceOrganizations?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceDates"]>

  export type ConferenceDatesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizedId?: boolean
    fromDate?: boolean
    toDate?: boolean
    type?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAvailable?: boolean
    ConferenceOrganizations?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceDates"]>

  export type ConferenceDatesSelectScalar = {
    id?: boolean
    organizedId?: boolean
    fromDate?: boolean
    toDate?: boolean
    type?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAvailable?: boolean
  }

  export type ConferenceDatesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizedId" | "fromDate" | "toDate" | "type" | "name" | "createdAt" | "updatedAt" | "isAvailable", ExtArgs["result"]["conferenceDates"]>
  export type ConferenceDatesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConferenceOrganizations?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
  }
  export type ConferenceDatesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConferenceOrganizations?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
  }
  export type ConferenceDatesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConferenceOrganizations?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
  }

  export type $ConferenceDatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConferenceDates"
    objects: {
      ConferenceOrganizations: Prisma.$ConferenceOrganizationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizedId: string
      fromDate: Date
      toDate: Date
      type: string
      name: string
      createdAt: Date
      updatedAt: Date
      isAvailable: boolean
    }, ExtArgs["result"]["conferenceDates"]>
    composites: {}
  }

  type ConferenceDatesGetPayload<S extends boolean | null | undefined | ConferenceDatesDefaultArgs> = $Result.GetResult<Prisma.$ConferenceDatesPayload, S>

  type ConferenceDatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferenceDatesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferenceDatesCountAggregateInputType | true
    }

  export interface ConferenceDatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConferenceDates'], meta: { name: 'ConferenceDates' } }
    /**
     * Find zero or one ConferenceDates that matches the filter.
     * @param {ConferenceDatesFindUniqueArgs} args - Arguments to find a ConferenceDates
     * @example
     * // Get one ConferenceDates
     * const conferenceDates = await prisma.conferenceDates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferenceDatesFindUniqueArgs>(args: SelectSubset<T, ConferenceDatesFindUniqueArgs<ExtArgs>>): Prisma__ConferenceDatesClient<$Result.GetResult<Prisma.$ConferenceDatesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConferenceDates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferenceDatesFindUniqueOrThrowArgs} args - Arguments to find a ConferenceDates
     * @example
     * // Get one ConferenceDates
     * const conferenceDates = await prisma.conferenceDates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferenceDatesFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferenceDatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferenceDatesClient<$Result.GetResult<Prisma.$ConferenceDatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceDates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceDatesFindFirstArgs} args - Arguments to find a ConferenceDates
     * @example
     * // Get one ConferenceDates
     * const conferenceDates = await prisma.conferenceDates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferenceDatesFindFirstArgs>(args?: SelectSubset<T, ConferenceDatesFindFirstArgs<ExtArgs>>): Prisma__ConferenceDatesClient<$Result.GetResult<Prisma.$ConferenceDatesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceDates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceDatesFindFirstOrThrowArgs} args - Arguments to find a ConferenceDates
     * @example
     * // Get one ConferenceDates
     * const conferenceDates = await prisma.conferenceDates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferenceDatesFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferenceDatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferenceDatesClient<$Result.GetResult<Prisma.$ConferenceDatesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConferenceDates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceDatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConferenceDates
     * const conferenceDates = await prisma.conferenceDates.findMany()
     * 
     * // Get first 10 ConferenceDates
     * const conferenceDates = await prisma.conferenceDates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferenceDatesWithIdOnly = await prisma.conferenceDates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferenceDatesFindManyArgs>(args?: SelectSubset<T, ConferenceDatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceDatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConferenceDates.
     * @param {ConferenceDatesCreateArgs} args - Arguments to create a ConferenceDates.
     * @example
     * // Create one ConferenceDates
     * const ConferenceDates = await prisma.conferenceDates.create({
     *   data: {
     *     // ... data to create a ConferenceDates
     *   }
     * })
     * 
     */
    create<T extends ConferenceDatesCreateArgs>(args: SelectSubset<T, ConferenceDatesCreateArgs<ExtArgs>>): Prisma__ConferenceDatesClient<$Result.GetResult<Prisma.$ConferenceDatesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConferenceDates.
     * @param {ConferenceDatesCreateManyArgs} args - Arguments to create many ConferenceDates.
     * @example
     * // Create many ConferenceDates
     * const conferenceDates = await prisma.conferenceDates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferenceDatesCreateManyArgs>(args?: SelectSubset<T, ConferenceDatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConferenceDates and returns the data saved in the database.
     * @param {ConferenceDatesCreateManyAndReturnArgs} args - Arguments to create many ConferenceDates.
     * @example
     * // Create many ConferenceDates
     * const conferenceDates = await prisma.conferenceDates.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConferenceDates and only return the `id`
     * const conferenceDatesWithIdOnly = await prisma.conferenceDates.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferenceDatesCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferenceDatesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceDatesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConferenceDates.
     * @param {ConferenceDatesDeleteArgs} args - Arguments to delete one ConferenceDates.
     * @example
     * // Delete one ConferenceDates
     * const ConferenceDates = await prisma.conferenceDates.delete({
     *   where: {
     *     // ... filter to delete one ConferenceDates
     *   }
     * })
     * 
     */
    delete<T extends ConferenceDatesDeleteArgs>(args: SelectSubset<T, ConferenceDatesDeleteArgs<ExtArgs>>): Prisma__ConferenceDatesClient<$Result.GetResult<Prisma.$ConferenceDatesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConferenceDates.
     * @param {ConferenceDatesUpdateArgs} args - Arguments to update one ConferenceDates.
     * @example
     * // Update one ConferenceDates
     * const conferenceDates = await prisma.conferenceDates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferenceDatesUpdateArgs>(args: SelectSubset<T, ConferenceDatesUpdateArgs<ExtArgs>>): Prisma__ConferenceDatesClient<$Result.GetResult<Prisma.$ConferenceDatesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConferenceDates.
     * @param {ConferenceDatesDeleteManyArgs} args - Arguments to filter ConferenceDates to delete.
     * @example
     * // Delete a few ConferenceDates
     * const { count } = await prisma.conferenceDates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferenceDatesDeleteManyArgs>(args?: SelectSubset<T, ConferenceDatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceDatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConferenceDates
     * const conferenceDates = await prisma.conferenceDates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferenceDatesUpdateManyArgs>(args: SelectSubset<T, ConferenceDatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceDates and returns the data updated in the database.
     * @param {ConferenceDatesUpdateManyAndReturnArgs} args - Arguments to update many ConferenceDates.
     * @example
     * // Update many ConferenceDates
     * const conferenceDates = await prisma.conferenceDates.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConferenceDates and only return the `id`
     * const conferenceDatesWithIdOnly = await prisma.conferenceDates.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferenceDatesUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferenceDatesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceDatesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConferenceDates.
     * @param {ConferenceDatesUpsertArgs} args - Arguments to update or create a ConferenceDates.
     * @example
     * // Update or create a ConferenceDates
     * const conferenceDates = await prisma.conferenceDates.upsert({
     *   create: {
     *     // ... data to create a ConferenceDates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConferenceDates we want to update
     *   }
     * })
     */
    upsert<T extends ConferenceDatesUpsertArgs>(args: SelectSubset<T, ConferenceDatesUpsertArgs<ExtArgs>>): Prisma__ConferenceDatesClient<$Result.GetResult<Prisma.$ConferenceDatesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConferenceDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceDatesCountArgs} args - Arguments to filter ConferenceDates to count.
     * @example
     * // Count the number of ConferenceDates
     * const count = await prisma.conferenceDates.count({
     *   where: {
     *     // ... the filter for the ConferenceDates we want to count
     *   }
     * })
    **/
    count<T extends ConferenceDatesCountArgs>(
      args?: Subset<T, ConferenceDatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferenceDatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConferenceDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceDatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferenceDatesAggregateArgs>(args: Subset<T, ConferenceDatesAggregateArgs>): Prisma.PrismaPromise<GetConferenceDatesAggregateType<T>>

    /**
     * Group by ConferenceDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceDatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferenceDatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferenceDatesGroupByArgs['orderBy'] }
        : { orderBy?: ConferenceDatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferenceDatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferenceDatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConferenceDates model
   */
  readonly fields: ConferenceDatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConferenceDates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferenceDatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ConferenceOrganizations<T extends ConferenceOrganizationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferenceOrganizationsDefaultArgs<ExtArgs>>): Prisma__ConferenceOrganizationsClient<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConferenceDates model
   */ 
  interface ConferenceDatesFieldRefs {
    readonly id: FieldRef<"ConferenceDates", 'String'>
    readonly organizedId: FieldRef<"ConferenceDates", 'String'>
    readonly fromDate: FieldRef<"ConferenceDates", 'DateTime'>
    readonly toDate: FieldRef<"ConferenceDates", 'DateTime'>
    readonly type: FieldRef<"ConferenceDates", 'String'>
    readonly name: FieldRef<"ConferenceDates", 'String'>
    readonly createdAt: FieldRef<"ConferenceDates", 'DateTime'>
    readonly updatedAt: FieldRef<"ConferenceDates", 'DateTime'>
    readonly isAvailable: FieldRef<"ConferenceDates", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ConferenceDates findUnique
   */
  export type ConferenceDatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceDates to fetch.
     */
    where: ConferenceDatesWhereUniqueInput
  }

  /**
   * ConferenceDates findUniqueOrThrow
   */
  export type ConferenceDatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceDates to fetch.
     */
    where: ConferenceDatesWhereUniqueInput
  }

  /**
   * ConferenceDates findFirst
   */
  export type ConferenceDatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceDates to fetch.
     */
    where?: ConferenceDatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceDates to fetch.
     */
    orderBy?: ConferenceDatesOrderByWithRelationInput | ConferenceDatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceDates.
     */
    cursor?: ConferenceDatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceDates.
     */
    distinct?: ConferenceDatesScalarFieldEnum | ConferenceDatesScalarFieldEnum[]
  }

  /**
   * ConferenceDates findFirstOrThrow
   */
  export type ConferenceDatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceDates to fetch.
     */
    where?: ConferenceDatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceDates to fetch.
     */
    orderBy?: ConferenceDatesOrderByWithRelationInput | ConferenceDatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceDates.
     */
    cursor?: ConferenceDatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceDates.
     */
    distinct?: ConferenceDatesScalarFieldEnum | ConferenceDatesScalarFieldEnum[]
  }

  /**
   * ConferenceDates findMany
   */
  export type ConferenceDatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceDates to fetch.
     */
    where?: ConferenceDatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceDates to fetch.
     */
    orderBy?: ConferenceDatesOrderByWithRelationInput | ConferenceDatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConferenceDates.
     */
    cursor?: ConferenceDatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceDates.
     */
    skip?: number
    distinct?: ConferenceDatesScalarFieldEnum | ConferenceDatesScalarFieldEnum[]
  }

  /**
   * ConferenceDates create
   */
  export type ConferenceDatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesInclude<ExtArgs> | null
    /**
     * The data needed to create a ConferenceDates.
     */
    data: XOR<ConferenceDatesCreateInput, ConferenceDatesUncheckedCreateInput>
  }

  /**
   * ConferenceDates createMany
   */
  export type ConferenceDatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConferenceDates.
     */
    data: ConferenceDatesCreateManyInput | ConferenceDatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConferenceDates createManyAndReturn
   */
  export type ConferenceDatesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * The data used to create many ConferenceDates.
     */
    data: ConferenceDatesCreateManyInput | ConferenceDatesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceDates update
   */
  export type ConferenceDatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesInclude<ExtArgs> | null
    /**
     * The data needed to update a ConferenceDates.
     */
    data: XOR<ConferenceDatesUpdateInput, ConferenceDatesUncheckedUpdateInput>
    /**
     * Choose, which ConferenceDates to update.
     */
    where: ConferenceDatesWhereUniqueInput
  }

  /**
   * ConferenceDates updateMany
   */
  export type ConferenceDatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConferenceDates.
     */
    data: XOR<ConferenceDatesUpdateManyMutationInput, ConferenceDatesUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceDates to update
     */
    where?: ConferenceDatesWhereInput
    /**
     * Limit how many ConferenceDates to update.
     */
    limit?: number
  }

  /**
   * ConferenceDates updateManyAndReturn
   */
  export type ConferenceDatesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * The data used to update ConferenceDates.
     */
    data: XOR<ConferenceDatesUpdateManyMutationInput, ConferenceDatesUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceDates to update
     */
    where?: ConferenceDatesWhereInput
    /**
     * Limit how many ConferenceDates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceDates upsert
   */
  export type ConferenceDatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesInclude<ExtArgs> | null
    /**
     * The filter to search for the ConferenceDates to update in case it exists.
     */
    where: ConferenceDatesWhereUniqueInput
    /**
     * In case the ConferenceDates found by the `where` argument doesn't exist, create a new ConferenceDates with this data.
     */
    create: XOR<ConferenceDatesCreateInput, ConferenceDatesUncheckedCreateInput>
    /**
     * In case the ConferenceDates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferenceDatesUpdateInput, ConferenceDatesUncheckedUpdateInput>
  }

  /**
   * ConferenceDates delete
   */
  export type ConferenceDatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesInclude<ExtArgs> | null
    /**
     * Filter which ConferenceDates to delete.
     */
    where: ConferenceDatesWhereUniqueInput
  }

  /**
   * ConferenceDates deleteMany
   */
  export type ConferenceDatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceDates to delete
     */
    where?: ConferenceDatesWhereInput
    /**
     * Limit how many ConferenceDates to delete.
     */
    limit?: number
  }

  /**
   * ConferenceDates without action
   */
  export type ConferenceDatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesInclude<ExtArgs> | null
  }


  /**
   * Model ConferenceFeedbacks
   */

  export type AggregateConferenceFeedbacks = {
    _count: ConferenceFeedbacksCountAggregateOutputType | null
    _avg: ConferenceFeedbacksAvgAggregateOutputType | null
    _sum: ConferenceFeedbacksSumAggregateOutputType | null
    _min: ConferenceFeedbacksMinAggregateOutputType | null
    _max: ConferenceFeedbacksMaxAggregateOutputType | null
  }

  export type ConferenceFeedbacksAvgAggregateOutputType = {
    star: number | null
  }

  export type ConferenceFeedbacksSumAggregateOutputType = {
    star: number | null
  }

  export type ConferenceFeedbacksMinAggregateOutputType = {
    id: string | null
    conferenceId: string | null
    creatorId: string | null
    description: string | null
    star: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceFeedbacksMaxAggregateOutputType = {
    id: string | null
    conferenceId: string | null
    creatorId: string | null
    description: string | null
    star: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceFeedbacksCountAggregateOutputType = {
    id: number
    conferenceId: number
    creatorId: number
    description: number
    star: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConferenceFeedbacksAvgAggregateInputType = {
    star?: true
  }

  export type ConferenceFeedbacksSumAggregateInputType = {
    star?: true
  }

  export type ConferenceFeedbacksMinAggregateInputType = {
    id?: true
    conferenceId?: true
    creatorId?: true
    description?: true
    star?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceFeedbacksMaxAggregateInputType = {
    id?: true
    conferenceId?: true
    creatorId?: true
    description?: true
    star?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceFeedbacksCountAggregateInputType = {
    id?: true
    conferenceId?: true
    creatorId?: true
    description?: true
    star?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConferenceFeedbacksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceFeedbacks to aggregate.
     */
    where?: ConferenceFeedbacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceFeedbacks to fetch.
     */
    orderBy?: ConferenceFeedbacksOrderByWithRelationInput | ConferenceFeedbacksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferenceFeedbacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConferenceFeedbacks
    **/
    _count?: true | ConferenceFeedbacksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConferenceFeedbacksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConferenceFeedbacksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferenceFeedbacksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferenceFeedbacksMaxAggregateInputType
  }

  export type GetConferenceFeedbacksAggregateType<T extends ConferenceFeedbacksAggregateArgs> = {
        [P in keyof T & keyof AggregateConferenceFeedbacks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferenceFeedbacks[P]>
      : GetScalarType<T[P], AggregateConferenceFeedbacks[P]>
  }




  export type ConferenceFeedbacksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceFeedbacksWhereInput
    orderBy?: ConferenceFeedbacksOrderByWithAggregationInput | ConferenceFeedbacksOrderByWithAggregationInput[]
    by: ConferenceFeedbacksScalarFieldEnum[] | ConferenceFeedbacksScalarFieldEnum
    having?: ConferenceFeedbacksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferenceFeedbacksCountAggregateInputType | true
    _avg?: ConferenceFeedbacksAvgAggregateInputType
    _sum?: ConferenceFeedbacksSumAggregateInputType
    _min?: ConferenceFeedbacksMinAggregateInputType
    _max?: ConferenceFeedbacksMaxAggregateInputType
  }

  export type ConferenceFeedbacksGroupByOutputType = {
    id: string
    conferenceId: string
    creatorId: string
    description: string
    star: number
    createdAt: Date
    updatedAt: Date
    _count: ConferenceFeedbacksCountAggregateOutputType | null
    _avg: ConferenceFeedbacksAvgAggregateOutputType | null
    _sum: ConferenceFeedbacksSumAggregateOutputType | null
    _min: ConferenceFeedbacksMinAggregateOutputType | null
    _max: ConferenceFeedbacksMaxAggregateOutputType | null
  }

  type GetConferenceFeedbacksGroupByPayload<T extends ConferenceFeedbacksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferenceFeedbacksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferenceFeedbacksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferenceFeedbacksGroupByOutputType[P]>
            : GetScalarType<T[P], ConferenceFeedbacksGroupByOutputType[P]>
        }
      >
    >


  export type ConferenceFeedbacksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    creatorId?: boolean
    description?: boolean
    star?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceFeedbacks"]>

  export type ConferenceFeedbacksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    creatorId?: boolean
    description?: boolean
    star?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceFeedbacks"]>

  export type ConferenceFeedbacksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    creatorId?: boolean
    description?: boolean
    star?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceFeedbacks"]>

  export type ConferenceFeedbacksSelectScalar = {
    id?: boolean
    conferenceId?: boolean
    creatorId?: boolean
    description?: boolean
    star?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConferenceFeedbacksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conferenceId" | "creatorId" | "description" | "star" | "createdAt" | "updatedAt", ExtArgs["result"]["conferenceFeedbacks"]>
  export type ConferenceFeedbacksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ConferenceFeedbacksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ConferenceFeedbacksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $ConferenceFeedbacksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConferenceFeedbacks"
    objects: {
      Conferences: Prisma.$ConferencesPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conferenceId: string
      creatorId: string
      description: string
      star: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conferenceFeedbacks"]>
    composites: {}
  }

  type ConferenceFeedbacksGetPayload<S extends boolean | null | undefined | ConferenceFeedbacksDefaultArgs> = $Result.GetResult<Prisma.$ConferenceFeedbacksPayload, S>

  type ConferenceFeedbacksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferenceFeedbacksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferenceFeedbacksCountAggregateInputType | true
    }

  export interface ConferenceFeedbacksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConferenceFeedbacks'], meta: { name: 'ConferenceFeedbacks' } }
    /**
     * Find zero or one ConferenceFeedbacks that matches the filter.
     * @param {ConferenceFeedbacksFindUniqueArgs} args - Arguments to find a ConferenceFeedbacks
     * @example
     * // Get one ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedbacks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferenceFeedbacksFindUniqueArgs>(args: SelectSubset<T, ConferenceFeedbacksFindUniqueArgs<ExtArgs>>): Prisma__ConferenceFeedbacksClient<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConferenceFeedbacks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferenceFeedbacksFindUniqueOrThrowArgs} args - Arguments to find a ConferenceFeedbacks
     * @example
     * // Get one ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedbacks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferenceFeedbacksFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferenceFeedbacksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferenceFeedbacksClient<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFeedbacksFindFirstArgs} args - Arguments to find a ConferenceFeedbacks
     * @example
     * // Get one ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedbacks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferenceFeedbacksFindFirstArgs>(args?: SelectSubset<T, ConferenceFeedbacksFindFirstArgs<ExtArgs>>): Prisma__ConferenceFeedbacksClient<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceFeedbacks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFeedbacksFindFirstOrThrowArgs} args - Arguments to find a ConferenceFeedbacks
     * @example
     * // Get one ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedbacks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferenceFeedbacksFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferenceFeedbacksFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferenceFeedbacksClient<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConferenceFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFeedbacksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedbacks.findMany()
     * 
     * // Get first 10 ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedbacks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferenceFeedbacksWithIdOnly = await prisma.conferenceFeedbacks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferenceFeedbacksFindManyArgs>(args?: SelectSubset<T, ConferenceFeedbacksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConferenceFeedbacks.
     * @param {ConferenceFeedbacksCreateArgs} args - Arguments to create a ConferenceFeedbacks.
     * @example
     * // Create one ConferenceFeedbacks
     * const ConferenceFeedbacks = await prisma.conferenceFeedbacks.create({
     *   data: {
     *     // ... data to create a ConferenceFeedbacks
     *   }
     * })
     * 
     */
    create<T extends ConferenceFeedbacksCreateArgs>(args: SelectSubset<T, ConferenceFeedbacksCreateArgs<ExtArgs>>): Prisma__ConferenceFeedbacksClient<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConferenceFeedbacks.
     * @param {ConferenceFeedbacksCreateManyArgs} args - Arguments to create many ConferenceFeedbacks.
     * @example
     * // Create many ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedbacks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferenceFeedbacksCreateManyArgs>(args?: SelectSubset<T, ConferenceFeedbacksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConferenceFeedbacks and returns the data saved in the database.
     * @param {ConferenceFeedbacksCreateManyAndReturnArgs} args - Arguments to create many ConferenceFeedbacks.
     * @example
     * // Create many ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedbacks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConferenceFeedbacks and only return the `id`
     * const conferenceFeedbacksWithIdOnly = await prisma.conferenceFeedbacks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferenceFeedbacksCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferenceFeedbacksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConferenceFeedbacks.
     * @param {ConferenceFeedbacksDeleteArgs} args - Arguments to delete one ConferenceFeedbacks.
     * @example
     * // Delete one ConferenceFeedbacks
     * const ConferenceFeedbacks = await prisma.conferenceFeedbacks.delete({
     *   where: {
     *     // ... filter to delete one ConferenceFeedbacks
     *   }
     * })
     * 
     */
    delete<T extends ConferenceFeedbacksDeleteArgs>(args: SelectSubset<T, ConferenceFeedbacksDeleteArgs<ExtArgs>>): Prisma__ConferenceFeedbacksClient<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConferenceFeedbacks.
     * @param {ConferenceFeedbacksUpdateArgs} args - Arguments to update one ConferenceFeedbacks.
     * @example
     * // Update one ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedbacks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferenceFeedbacksUpdateArgs>(args: SelectSubset<T, ConferenceFeedbacksUpdateArgs<ExtArgs>>): Prisma__ConferenceFeedbacksClient<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConferenceFeedbacks.
     * @param {ConferenceFeedbacksDeleteManyArgs} args - Arguments to filter ConferenceFeedbacks to delete.
     * @example
     * // Delete a few ConferenceFeedbacks
     * const { count } = await prisma.conferenceFeedbacks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferenceFeedbacksDeleteManyArgs>(args?: SelectSubset<T, ConferenceFeedbacksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFeedbacksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedbacks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferenceFeedbacksUpdateManyArgs>(args: SelectSubset<T, ConferenceFeedbacksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceFeedbacks and returns the data updated in the database.
     * @param {ConferenceFeedbacksUpdateManyAndReturnArgs} args - Arguments to update many ConferenceFeedbacks.
     * @example
     * // Update many ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedbacks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConferenceFeedbacks and only return the `id`
     * const conferenceFeedbacksWithIdOnly = await prisma.conferenceFeedbacks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferenceFeedbacksUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferenceFeedbacksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConferenceFeedbacks.
     * @param {ConferenceFeedbacksUpsertArgs} args - Arguments to update or create a ConferenceFeedbacks.
     * @example
     * // Update or create a ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedbacks.upsert({
     *   create: {
     *     // ... data to create a ConferenceFeedbacks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConferenceFeedbacks we want to update
     *   }
     * })
     */
    upsert<T extends ConferenceFeedbacksUpsertArgs>(args: SelectSubset<T, ConferenceFeedbacksUpsertArgs<ExtArgs>>): Prisma__ConferenceFeedbacksClient<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConferenceFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFeedbacksCountArgs} args - Arguments to filter ConferenceFeedbacks to count.
     * @example
     * // Count the number of ConferenceFeedbacks
     * const count = await prisma.conferenceFeedbacks.count({
     *   where: {
     *     // ... the filter for the ConferenceFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends ConferenceFeedbacksCountArgs>(
      args?: Subset<T, ConferenceFeedbacksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferenceFeedbacksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConferenceFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFeedbacksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferenceFeedbacksAggregateArgs>(args: Subset<T, ConferenceFeedbacksAggregateArgs>): Prisma.PrismaPromise<GetConferenceFeedbacksAggregateType<T>>

    /**
     * Group by ConferenceFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFeedbacksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferenceFeedbacksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferenceFeedbacksGroupByArgs['orderBy'] }
        : { orderBy?: ConferenceFeedbacksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferenceFeedbacksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferenceFeedbacksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConferenceFeedbacks model
   */
  readonly fields: ConferenceFeedbacksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConferenceFeedbacks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferenceFeedbacksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Conferences<T extends ConferencesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferencesDefaultArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConferenceFeedbacks model
   */ 
  interface ConferenceFeedbacksFieldRefs {
    readonly id: FieldRef<"ConferenceFeedbacks", 'String'>
    readonly conferenceId: FieldRef<"ConferenceFeedbacks", 'String'>
    readonly creatorId: FieldRef<"ConferenceFeedbacks", 'String'>
    readonly description: FieldRef<"ConferenceFeedbacks", 'String'>
    readonly star: FieldRef<"ConferenceFeedbacks", 'Int'>
    readonly createdAt: FieldRef<"ConferenceFeedbacks", 'DateTime'>
    readonly updatedAt: FieldRef<"ConferenceFeedbacks", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConferenceFeedbacks findUnique
   */
  export type ConferenceFeedbacksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFeedbacks to fetch.
     */
    where: ConferenceFeedbacksWhereUniqueInput
  }

  /**
   * ConferenceFeedbacks findUniqueOrThrow
   */
  export type ConferenceFeedbacksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFeedbacks to fetch.
     */
    where: ConferenceFeedbacksWhereUniqueInput
  }

  /**
   * ConferenceFeedbacks findFirst
   */
  export type ConferenceFeedbacksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFeedbacks to fetch.
     */
    where?: ConferenceFeedbacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceFeedbacks to fetch.
     */
    orderBy?: ConferenceFeedbacksOrderByWithRelationInput | ConferenceFeedbacksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceFeedbacks.
     */
    cursor?: ConferenceFeedbacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceFeedbacks.
     */
    distinct?: ConferenceFeedbacksScalarFieldEnum | ConferenceFeedbacksScalarFieldEnum[]
  }

  /**
   * ConferenceFeedbacks findFirstOrThrow
   */
  export type ConferenceFeedbacksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFeedbacks to fetch.
     */
    where?: ConferenceFeedbacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceFeedbacks to fetch.
     */
    orderBy?: ConferenceFeedbacksOrderByWithRelationInput | ConferenceFeedbacksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceFeedbacks.
     */
    cursor?: ConferenceFeedbacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceFeedbacks.
     */
    distinct?: ConferenceFeedbacksScalarFieldEnum | ConferenceFeedbacksScalarFieldEnum[]
  }

  /**
   * ConferenceFeedbacks findMany
   */
  export type ConferenceFeedbacksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFeedbacks to fetch.
     */
    where?: ConferenceFeedbacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceFeedbacks to fetch.
     */
    orderBy?: ConferenceFeedbacksOrderByWithRelationInput | ConferenceFeedbacksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConferenceFeedbacks.
     */
    cursor?: ConferenceFeedbacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceFeedbacks.
     */
    skip?: number
    distinct?: ConferenceFeedbacksScalarFieldEnum | ConferenceFeedbacksScalarFieldEnum[]
  }

  /**
   * ConferenceFeedbacks create
   */
  export type ConferenceFeedbacksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksInclude<ExtArgs> | null
    /**
     * The data needed to create a ConferenceFeedbacks.
     */
    data: XOR<ConferenceFeedbacksCreateInput, ConferenceFeedbacksUncheckedCreateInput>
  }

  /**
   * ConferenceFeedbacks createMany
   */
  export type ConferenceFeedbacksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConferenceFeedbacks.
     */
    data: ConferenceFeedbacksCreateManyInput | ConferenceFeedbacksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConferenceFeedbacks createManyAndReturn
   */
  export type ConferenceFeedbacksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * The data used to create many ConferenceFeedbacks.
     */
    data: ConferenceFeedbacksCreateManyInput | ConferenceFeedbacksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceFeedbacks update
   */
  export type ConferenceFeedbacksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksInclude<ExtArgs> | null
    /**
     * The data needed to update a ConferenceFeedbacks.
     */
    data: XOR<ConferenceFeedbacksUpdateInput, ConferenceFeedbacksUncheckedUpdateInput>
    /**
     * Choose, which ConferenceFeedbacks to update.
     */
    where: ConferenceFeedbacksWhereUniqueInput
  }

  /**
   * ConferenceFeedbacks updateMany
   */
  export type ConferenceFeedbacksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConferenceFeedbacks.
     */
    data: XOR<ConferenceFeedbacksUpdateManyMutationInput, ConferenceFeedbacksUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceFeedbacks to update
     */
    where?: ConferenceFeedbacksWhereInput
    /**
     * Limit how many ConferenceFeedbacks to update.
     */
    limit?: number
  }

  /**
   * ConferenceFeedbacks updateManyAndReturn
   */
  export type ConferenceFeedbacksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * The data used to update ConferenceFeedbacks.
     */
    data: XOR<ConferenceFeedbacksUpdateManyMutationInput, ConferenceFeedbacksUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceFeedbacks to update
     */
    where?: ConferenceFeedbacksWhereInput
    /**
     * Limit how many ConferenceFeedbacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceFeedbacks upsert
   */
  export type ConferenceFeedbacksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksInclude<ExtArgs> | null
    /**
     * The filter to search for the ConferenceFeedbacks to update in case it exists.
     */
    where: ConferenceFeedbacksWhereUniqueInput
    /**
     * In case the ConferenceFeedbacks found by the `where` argument doesn't exist, create a new ConferenceFeedbacks with this data.
     */
    create: XOR<ConferenceFeedbacksCreateInput, ConferenceFeedbacksUncheckedCreateInput>
    /**
     * In case the ConferenceFeedbacks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferenceFeedbacksUpdateInput, ConferenceFeedbacksUncheckedUpdateInput>
  }

  /**
   * ConferenceFeedbacks delete
   */
  export type ConferenceFeedbacksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksInclude<ExtArgs> | null
    /**
     * Filter which ConferenceFeedbacks to delete.
     */
    where: ConferenceFeedbacksWhereUniqueInput
  }

  /**
   * ConferenceFeedbacks deleteMany
   */
  export type ConferenceFeedbacksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceFeedbacks to delete
     */
    where?: ConferenceFeedbacksWhereInput
    /**
     * Limit how many ConferenceFeedbacks to delete.
     */
    limit?: number
  }

  /**
   * ConferenceFeedbacks without action
   */
  export type ConferenceFeedbacksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksInclude<ExtArgs> | null
  }


  /**
   * Model ConferenceFollows
   */

  export type AggregateConferenceFollows = {
    _count: ConferenceFollowsCountAggregateOutputType | null
    _min: ConferenceFollowsMinAggregateOutputType | null
    _max: ConferenceFollowsMaxAggregateOutputType | null
  }

  export type ConferenceFollowsMinAggregateOutputType = {
    id: string | null
    conferenceId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceFollowsMaxAggregateOutputType = {
    id: string | null
    conferenceId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceFollowsCountAggregateOutputType = {
    id: number
    conferenceId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConferenceFollowsMinAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceFollowsMaxAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceFollowsCountAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConferenceFollowsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceFollows to aggregate.
     */
    where?: ConferenceFollowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceFollows to fetch.
     */
    orderBy?: ConferenceFollowsOrderByWithRelationInput | ConferenceFollowsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferenceFollowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConferenceFollows
    **/
    _count?: true | ConferenceFollowsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferenceFollowsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferenceFollowsMaxAggregateInputType
  }

  export type GetConferenceFollowsAggregateType<T extends ConferenceFollowsAggregateArgs> = {
        [P in keyof T & keyof AggregateConferenceFollows]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferenceFollows[P]>
      : GetScalarType<T[P], AggregateConferenceFollows[P]>
  }




  export type ConferenceFollowsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceFollowsWhereInput
    orderBy?: ConferenceFollowsOrderByWithAggregationInput | ConferenceFollowsOrderByWithAggregationInput[]
    by: ConferenceFollowsScalarFieldEnum[] | ConferenceFollowsScalarFieldEnum
    having?: ConferenceFollowsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferenceFollowsCountAggregateInputType | true
    _min?: ConferenceFollowsMinAggregateInputType
    _max?: ConferenceFollowsMaxAggregateInputType
  }

  export type ConferenceFollowsGroupByOutputType = {
    id: string
    conferenceId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: ConferenceFollowsCountAggregateOutputType | null
    _min: ConferenceFollowsMinAggregateOutputType | null
    _max: ConferenceFollowsMaxAggregateOutputType | null
  }

  type GetConferenceFollowsGroupByPayload<T extends ConferenceFollowsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferenceFollowsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferenceFollowsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferenceFollowsGroupByOutputType[P]>
            : GetScalarType<T[P], ConferenceFollowsGroupByOutputType[P]>
        }
      >
    >


  export type ConferenceFollowsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceFollows"]>

  export type ConferenceFollowsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceFollows"]>

  export type ConferenceFollowsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceFollows"]>

  export type ConferenceFollowsSelectScalar = {
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConferenceFollowsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conferenceId" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["conferenceFollows"]>
  export type ConferenceFollowsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ConferenceFollowsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ConferenceFollowsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $ConferenceFollowsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConferenceFollows"
    objects: {
      Conferences: Prisma.$ConferencesPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conferenceId: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conferenceFollows"]>
    composites: {}
  }

  type ConferenceFollowsGetPayload<S extends boolean | null | undefined | ConferenceFollowsDefaultArgs> = $Result.GetResult<Prisma.$ConferenceFollowsPayload, S>

  type ConferenceFollowsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferenceFollowsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferenceFollowsCountAggregateInputType | true
    }

  export interface ConferenceFollowsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConferenceFollows'], meta: { name: 'ConferenceFollows' } }
    /**
     * Find zero or one ConferenceFollows that matches the filter.
     * @param {ConferenceFollowsFindUniqueArgs} args - Arguments to find a ConferenceFollows
     * @example
     * // Get one ConferenceFollows
     * const conferenceFollows = await prisma.conferenceFollows.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferenceFollowsFindUniqueArgs>(args: SelectSubset<T, ConferenceFollowsFindUniqueArgs<ExtArgs>>): Prisma__ConferenceFollowsClient<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConferenceFollows that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferenceFollowsFindUniqueOrThrowArgs} args - Arguments to find a ConferenceFollows
     * @example
     * // Get one ConferenceFollows
     * const conferenceFollows = await prisma.conferenceFollows.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferenceFollowsFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferenceFollowsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferenceFollowsClient<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceFollows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFollowsFindFirstArgs} args - Arguments to find a ConferenceFollows
     * @example
     * // Get one ConferenceFollows
     * const conferenceFollows = await prisma.conferenceFollows.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferenceFollowsFindFirstArgs>(args?: SelectSubset<T, ConferenceFollowsFindFirstArgs<ExtArgs>>): Prisma__ConferenceFollowsClient<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceFollows that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFollowsFindFirstOrThrowArgs} args - Arguments to find a ConferenceFollows
     * @example
     * // Get one ConferenceFollows
     * const conferenceFollows = await prisma.conferenceFollows.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferenceFollowsFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferenceFollowsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferenceFollowsClient<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConferenceFollows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFollowsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConferenceFollows
     * const conferenceFollows = await prisma.conferenceFollows.findMany()
     * 
     * // Get first 10 ConferenceFollows
     * const conferenceFollows = await prisma.conferenceFollows.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferenceFollowsWithIdOnly = await prisma.conferenceFollows.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferenceFollowsFindManyArgs>(args?: SelectSubset<T, ConferenceFollowsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConferenceFollows.
     * @param {ConferenceFollowsCreateArgs} args - Arguments to create a ConferenceFollows.
     * @example
     * // Create one ConferenceFollows
     * const ConferenceFollows = await prisma.conferenceFollows.create({
     *   data: {
     *     // ... data to create a ConferenceFollows
     *   }
     * })
     * 
     */
    create<T extends ConferenceFollowsCreateArgs>(args: SelectSubset<T, ConferenceFollowsCreateArgs<ExtArgs>>): Prisma__ConferenceFollowsClient<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConferenceFollows.
     * @param {ConferenceFollowsCreateManyArgs} args - Arguments to create many ConferenceFollows.
     * @example
     * // Create many ConferenceFollows
     * const conferenceFollows = await prisma.conferenceFollows.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferenceFollowsCreateManyArgs>(args?: SelectSubset<T, ConferenceFollowsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConferenceFollows and returns the data saved in the database.
     * @param {ConferenceFollowsCreateManyAndReturnArgs} args - Arguments to create many ConferenceFollows.
     * @example
     * // Create many ConferenceFollows
     * const conferenceFollows = await prisma.conferenceFollows.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConferenceFollows and only return the `id`
     * const conferenceFollowsWithIdOnly = await prisma.conferenceFollows.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferenceFollowsCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferenceFollowsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConferenceFollows.
     * @param {ConferenceFollowsDeleteArgs} args - Arguments to delete one ConferenceFollows.
     * @example
     * // Delete one ConferenceFollows
     * const ConferenceFollows = await prisma.conferenceFollows.delete({
     *   where: {
     *     // ... filter to delete one ConferenceFollows
     *   }
     * })
     * 
     */
    delete<T extends ConferenceFollowsDeleteArgs>(args: SelectSubset<T, ConferenceFollowsDeleteArgs<ExtArgs>>): Prisma__ConferenceFollowsClient<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConferenceFollows.
     * @param {ConferenceFollowsUpdateArgs} args - Arguments to update one ConferenceFollows.
     * @example
     * // Update one ConferenceFollows
     * const conferenceFollows = await prisma.conferenceFollows.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferenceFollowsUpdateArgs>(args: SelectSubset<T, ConferenceFollowsUpdateArgs<ExtArgs>>): Prisma__ConferenceFollowsClient<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConferenceFollows.
     * @param {ConferenceFollowsDeleteManyArgs} args - Arguments to filter ConferenceFollows to delete.
     * @example
     * // Delete a few ConferenceFollows
     * const { count } = await prisma.conferenceFollows.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferenceFollowsDeleteManyArgs>(args?: SelectSubset<T, ConferenceFollowsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFollowsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConferenceFollows
     * const conferenceFollows = await prisma.conferenceFollows.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferenceFollowsUpdateManyArgs>(args: SelectSubset<T, ConferenceFollowsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceFollows and returns the data updated in the database.
     * @param {ConferenceFollowsUpdateManyAndReturnArgs} args - Arguments to update many ConferenceFollows.
     * @example
     * // Update many ConferenceFollows
     * const conferenceFollows = await prisma.conferenceFollows.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConferenceFollows and only return the `id`
     * const conferenceFollowsWithIdOnly = await prisma.conferenceFollows.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferenceFollowsUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferenceFollowsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConferenceFollows.
     * @param {ConferenceFollowsUpsertArgs} args - Arguments to update or create a ConferenceFollows.
     * @example
     * // Update or create a ConferenceFollows
     * const conferenceFollows = await prisma.conferenceFollows.upsert({
     *   create: {
     *     // ... data to create a ConferenceFollows
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConferenceFollows we want to update
     *   }
     * })
     */
    upsert<T extends ConferenceFollowsUpsertArgs>(args: SelectSubset<T, ConferenceFollowsUpsertArgs<ExtArgs>>): Prisma__ConferenceFollowsClient<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConferenceFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFollowsCountArgs} args - Arguments to filter ConferenceFollows to count.
     * @example
     * // Count the number of ConferenceFollows
     * const count = await prisma.conferenceFollows.count({
     *   where: {
     *     // ... the filter for the ConferenceFollows we want to count
     *   }
     * })
    **/
    count<T extends ConferenceFollowsCountArgs>(
      args?: Subset<T, ConferenceFollowsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferenceFollowsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConferenceFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFollowsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferenceFollowsAggregateArgs>(args: Subset<T, ConferenceFollowsAggregateArgs>): Prisma.PrismaPromise<GetConferenceFollowsAggregateType<T>>

    /**
     * Group by ConferenceFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFollowsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferenceFollowsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferenceFollowsGroupByArgs['orderBy'] }
        : { orderBy?: ConferenceFollowsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferenceFollowsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferenceFollowsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConferenceFollows model
   */
  readonly fields: ConferenceFollowsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConferenceFollows.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferenceFollowsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Conferences<T extends ConferencesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferencesDefaultArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConferenceFollows model
   */ 
  interface ConferenceFollowsFieldRefs {
    readonly id: FieldRef<"ConferenceFollows", 'String'>
    readonly conferenceId: FieldRef<"ConferenceFollows", 'String'>
    readonly userId: FieldRef<"ConferenceFollows", 'String'>
    readonly createdAt: FieldRef<"ConferenceFollows", 'DateTime'>
    readonly updatedAt: FieldRef<"ConferenceFollows", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConferenceFollows findUnique
   */
  export type ConferenceFollowsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFollows to fetch.
     */
    where: ConferenceFollowsWhereUniqueInput
  }

  /**
   * ConferenceFollows findUniqueOrThrow
   */
  export type ConferenceFollowsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFollows to fetch.
     */
    where: ConferenceFollowsWhereUniqueInput
  }

  /**
   * ConferenceFollows findFirst
   */
  export type ConferenceFollowsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFollows to fetch.
     */
    where?: ConferenceFollowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceFollows to fetch.
     */
    orderBy?: ConferenceFollowsOrderByWithRelationInput | ConferenceFollowsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceFollows.
     */
    cursor?: ConferenceFollowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceFollows.
     */
    distinct?: ConferenceFollowsScalarFieldEnum | ConferenceFollowsScalarFieldEnum[]
  }

  /**
   * ConferenceFollows findFirstOrThrow
   */
  export type ConferenceFollowsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFollows to fetch.
     */
    where?: ConferenceFollowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceFollows to fetch.
     */
    orderBy?: ConferenceFollowsOrderByWithRelationInput | ConferenceFollowsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceFollows.
     */
    cursor?: ConferenceFollowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceFollows.
     */
    distinct?: ConferenceFollowsScalarFieldEnum | ConferenceFollowsScalarFieldEnum[]
  }

  /**
   * ConferenceFollows findMany
   */
  export type ConferenceFollowsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFollows to fetch.
     */
    where?: ConferenceFollowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceFollows to fetch.
     */
    orderBy?: ConferenceFollowsOrderByWithRelationInput | ConferenceFollowsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConferenceFollows.
     */
    cursor?: ConferenceFollowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceFollows.
     */
    skip?: number
    distinct?: ConferenceFollowsScalarFieldEnum | ConferenceFollowsScalarFieldEnum[]
  }

  /**
   * ConferenceFollows create
   */
  export type ConferenceFollowsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsInclude<ExtArgs> | null
    /**
     * The data needed to create a ConferenceFollows.
     */
    data: XOR<ConferenceFollowsCreateInput, ConferenceFollowsUncheckedCreateInput>
  }

  /**
   * ConferenceFollows createMany
   */
  export type ConferenceFollowsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConferenceFollows.
     */
    data: ConferenceFollowsCreateManyInput | ConferenceFollowsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConferenceFollows createManyAndReturn
   */
  export type ConferenceFollowsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * The data used to create many ConferenceFollows.
     */
    data: ConferenceFollowsCreateManyInput | ConferenceFollowsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceFollows update
   */
  export type ConferenceFollowsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsInclude<ExtArgs> | null
    /**
     * The data needed to update a ConferenceFollows.
     */
    data: XOR<ConferenceFollowsUpdateInput, ConferenceFollowsUncheckedUpdateInput>
    /**
     * Choose, which ConferenceFollows to update.
     */
    where: ConferenceFollowsWhereUniqueInput
  }

  /**
   * ConferenceFollows updateMany
   */
  export type ConferenceFollowsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConferenceFollows.
     */
    data: XOR<ConferenceFollowsUpdateManyMutationInput, ConferenceFollowsUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceFollows to update
     */
    where?: ConferenceFollowsWhereInput
    /**
     * Limit how many ConferenceFollows to update.
     */
    limit?: number
  }

  /**
   * ConferenceFollows updateManyAndReturn
   */
  export type ConferenceFollowsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * The data used to update ConferenceFollows.
     */
    data: XOR<ConferenceFollowsUpdateManyMutationInput, ConferenceFollowsUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceFollows to update
     */
    where?: ConferenceFollowsWhereInput
    /**
     * Limit how many ConferenceFollows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceFollows upsert
   */
  export type ConferenceFollowsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsInclude<ExtArgs> | null
    /**
     * The filter to search for the ConferenceFollows to update in case it exists.
     */
    where: ConferenceFollowsWhereUniqueInput
    /**
     * In case the ConferenceFollows found by the `where` argument doesn't exist, create a new ConferenceFollows with this data.
     */
    create: XOR<ConferenceFollowsCreateInput, ConferenceFollowsUncheckedCreateInput>
    /**
     * In case the ConferenceFollows was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferenceFollowsUpdateInput, ConferenceFollowsUncheckedUpdateInput>
  }

  /**
   * ConferenceFollows delete
   */
  export type ConferenceFollowsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsInclude<ExtArgs> | null
    /**
     * Filter which ConferenceFollows to delete.
     */
    where: ConferenceFollowsWhereUniqueInput
  }

  /**
   * ConferenceFollows deleteMany
   */
  export type ConferenceFollowsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceFollows to delete
     */
    where?: ConferenceFollowsWhereInput
    /**
     * Limit how many ConferenceFollows to delete.
     */
    limit?: number
  }

  /**
   * ConferenceFollows without action
   */
  export type ConferenceFollowsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsInclude<ExtArgs> | null
  }


  /**
   * Model ConferenceLikes
   */

  export type AggregateConferenceLikes = {
    _count: ConferenceLikesCountAggregateOutputType | null
    _min: ConferenceLikesMinAggregateOutputType | null
    _max: ConferenceLikesMaxAggregateOutputType | null
  }

  export type ConferenceLikesMinAggregateOutputType = {
    id: string | null
    conferenceId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceLikesMaxAggregateOutputType = {
    id: string | null
    conferenceId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceLikesCountAggregateOutputType = {
    id: number
    conferenceId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConferenceLikesMinAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceLikesMaxAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceLikesCountAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConferenceLikesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceLikes to aggregate.
     */
    where?: ConferenceLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceLikes to fetch.
     */
    orderBy?: ConferenceLikesOrderByWithRelationInput | ConferenceLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferenceLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConferenceLikes
    **/
    _count?: true | ConferenceLikesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferenceLikesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferenceLikesMaxAggregateInputType
  }

  export type GetConferenceLikesAggregateType<T extends ConferenceLikesAggregateArgs> = {
        [P in keyof T & keyof AggregateConferenceLikes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferenceLikes[P]>
      : GetScalarType<T[P], AggregateConferenceLikes[P]>
  }




  export type ConferenceLikesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceLikesWhereInput
    orderBy?: ConferenceLikesOrderByWithAggregationInput | ConferenceLikesOrderByWithAggregationInput[]
    by: ConferenceLikesScalarFieldEnum[] | ConferenceLikesScalarFieldEnum
    having?: ConferenceLikesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferenceLikesCountAggregateInputType | true
    _min?: ConferenceLikesMinAggregateInputType
    _max?: ConferenceLikesMaxAggregateInputType
  }

  export type ConferenceLikesGroupByOutputType = {
    id: string
    conferenceId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: ConferenceLikesCountAggregateOutputType | null
    _min: ConferenceLikesMinAggregateOutputType | null
    _max: ConferenceLikesMaxAggregateOutputType | null
  }

  type GetConferenceLikesGroupByPayload<T extends ConferenceLikesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferenceLikesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferenceLikesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferenceLikesGroupByOutputType[P]>
            : GetScalarType<T[P], ConferenceLikesGroupByOutputType[P]>
        }
      >
    >


  export type ConferenceLikesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceLikes"]>

  export type ConferenceLikesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceLikes"]>

  export type ConferenceLikesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceLikes"]>

  export type ConferenceLikesSelectScalar = {
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConferenceLikesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conferenceId" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["conferenceLikes"]>
  export type ConferenceLikesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ConferenceLikesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ConferenceLikesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $ConferenceLikesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConferenceLikes"
    objects: {
      Conferences: Prisma.$ConferencesPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conferenceId: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conferenceLikes"]>
    composites: {}
  }

  type ConferenceLikesGetPayload<S extends boolean | null | undefined | ConferenceLikesDefaultArgs> = $Result.GetResult<Prisma.$ConferenceLikesPayload, S>

  type ConferenceLikesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferenceLikesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferenceLikesCountAggregateInputType | true
    }

  export interface ConferenceLikesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConferenceLikes'], meta: { name: 'ConferenceLikes' } }
    /**
     * Find zero or one ConferenceLikes that matches the filter.
     * @param {ConferenceLikesFindUniqueArgs} args - Arguments to find a ConferenceLikes
     * @example
     * // Get one ConferenceLikes
     * const conferenceLikes = await prisma.conferenceLikes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferenceLikesFindUniqueArgs>(args: SelectSubset<T, ConferenceLikesFindUniqueArgs<ExtArgs>>): Prisma__ConferenceLikesClient<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConferenceLikes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferenceLikesFindUniqueOrThrowArgs} args - Arguments to find a ConferenceLikes
     * @example
     * // Get one ConferenceLikes
     * const conferenceLikes = await prisma.conferenceLikes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferenceLikesFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferenceLikesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferenceLikesClient<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceLikesFindFirstArgs} args - Arguments to find a ConferenceLikes
     * @example
     * // Get one ConferenceLikes
     * const conferenceLikes = await prisma.conferenceLikes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferenceLikesFindFirstArgs>(args?: SelectSubset<T, ConferenceLikesFindFirstArgs<ExtArgs>>): Prisma__ConferenceLikesClient<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceLikes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceLikesFindFirstOrThrowArgs} args - Arguments to find a ConferenceLikes
     * @example
     * // Get one ConferenceLikes
     * const conferenceLikes = await prisma.conferenceLikes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferenceLikesFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferenceLikesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferenceLikesClient<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConferenceLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceLikesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConferenceLikes
     * const conferenceLikes = await prisma.conferenceLikes.findMany()
     * 
     * // Get first 10 ConferenceLikes
     * const conferenceLikes = await prisma.conferenceLikes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferenceLikesWithIdOnly = await prisma.conferenceLikes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferenceLikesFindManyArgs>(args?: SelectSubset<T, ConferenceLikesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConferenceLikes.
     * @param {ConferenceLikesCreateArgs} args - Arguments to create a ConferenceLikes.
     * @example
     * // Create one ConferenceLikes
     * const ConferenceLikes = await prisma.conferenceLikes.create({
     *   data: {
     *     // ... data to create a ConferenceLikes
     *   }
     * })
     * 
     */
    create<T extends ConferenceLikesCreateArgs>(args: SelectSubset<T, ConferenceLikesCreateArgs<ExtArgs>>): Prisma__ConferenceLikesClient<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConferenceLikes.
     * @param {ConferenceLikesCreateManyArgs} args - Arguments to create many ConferenceLikes.
     * @example
     * // Create many ConferenceLikes
     * const conferenceLikes = await prisma.conferenceLikes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferenceLikesCreateManyArgs>(args?: SelectSubset<T, ConferenceLikesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConferenceLikes and returns the data saved in the database.
     * @param {ConferenceLikesCreateManyAndReturnArgs} args - Arguments to create many ConferenceLikes.
     * @example
     * // Create many ConferenceLikes
     * const conferenceLikes = await prisma.conferenceLikes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConferenceLikes and only return the `id`
     * const conferenceLikesWithIdOnly = await prisma.conferenceLikes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferenceLikesCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferenceLikesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConferenceLikes.
     * @param {ConferenceLikesDeleteArgs} args - Arguments to delete one ConferenceLikes.
     * @example
     * // Delete one ConferenceLikes
     * const ConferenceLikes = await prisma.conferenceLikes.delete({
     *   where: {
     *     // ... filter to delete one ConferenceLikes
     *   }
     * })
     * 
     */
    delete<T extends ConferenceLikesDeleteArgs>(args: SelectSubset<T, ConferenceLikesDeleteArgs<ExtArgs>>): Prisma__ConferenceLikesClient<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConferenceLikes.
     * @param {ConferenceLikesUpdateArgs} args - Arguments to update one ConferenceLikes.
     * @example
     * // Update one ConferenceLikes
     * const conferenceLikes = await prisma.conferenceLikes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferenceLikesUpdateArgs>(args: SelectSubset<T, ConferenceLikesUpdateArgs<ExtArgs>>): Prisma__ConferenceLikesClient<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConferenceLikes.
     * @param {ConferenceLikesDeleteManyArgs} args - Arguments to filter ConferenceLikes to delete.
     * @example
     * // Delete a few ConferenceLikes
     * const { count } = await prisma.conferenceLikes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferenceLikesDeleteManyArgs>(args?: SelectSubset<T, ConferenceLikesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceLikesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConferenceLikes
     * const conferenceLikes = await prisma.conferenceLikes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferenceLikesUpdateManyArgs>(args: SelectSubset<T, ConferenceLikesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceLikes and returns the data updated in the database.
     * @param {ConferenceLikesUpdateManyAndReturnArgs} args - Arguments to update many ConferenceLikes.
     * @example
     * // Update many ConferenceLikes
     * const conferenceLikes = await prisma.conferenceLikes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConferenceLikes and only return the `id`
     * const conferenceLikesWithIdOnly = await prisma.conferenceLikes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferenceLikesUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferenceLikesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConferenceLikes.
     * @param {ConferenceLikesUpsertArgs} args - Arguments to update or create a ConferenceLikes.
     * @example
     * // Update or create a ConferenceLikes
     * const conferenceLikes = await prisma.conferenceLikes.upsert({
     *   create: {
     *     // ... data to create a ConferenceLikes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConferenceLikes we want to update
     *   }
     * })
     */
    upsert<T extends ConferenceLikesUpsertArgs>(args: SelectSubset<T, ConferenceLikesUpsertArgs<ExtArgs>>): Prisma__ConferenceLikesClient<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConferenceLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceLikesCountArgs} args - Arguments to filter ConferenceLikes to count.
     * @example
     * // Count the number of ConferenceLikes
     * const count = await prisma.conferenceLikes.count({
     *   where: {
     *     // ... the filter for the ConferenceLikes we want to count
     *   }
     * })
    **/
    count<T extends ConferenceLikesCountArgs>(
      args?: Subset<T, ConferenceLikesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferenceLikesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConferenceLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceLikesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferenceLikesAggregateArgs>(args: Subset<T, ConferenceLikesAggregateArgs>): Prisma.PrismaPromise<GetConferenceLikesAggregateType<T>>

    /**
     * Group by ConferenceLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceLikesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferenceLikesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferenceLikesGroupByArgs['orderBy'] }
        : { orderBy?: ConferenceLikesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferenceLikesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferenceLikesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConferenceLikes model
   */
  readonly fields: ConferenceLikesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConferenceLikes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferenceLikesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Conferences<T extends ConferencesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferencesDefaultArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConferenceLikes model
   */ 
  interface ConferenceLikesFieldRefs {
    readonly id: FieldRef<"ConferenceLikes", 'String'>
    readonly conferenceId: FieldRef<"ConferenceLikes", 'String'>
    readonly userId: FieldRef<"ConferenceLikes", 'String'>
    readonly createdAt: FieldRef<"ConferenceLikes", 'DateTime'>
    readonly updatedAt: FieldRef<"ConferenceLikes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConferenceLikes findUnique
   */
  export type ConferenceLikesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceLikes to fetch.
     */
    where: ConferenceLikesWhereUniqueInput
  }

  /**
   * ConferenceLikes findUniqueOrThrow
   */
  export type ConferenceLikesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceLikes to fetch.
     */
    where: ConferenceLikesWhereUniqueInput
  }

  /**
   * ConferenceLikes findFirst
   */
  export type ConferenceLikesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceLikes to fetch.
     */
    where?: ConferenceLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceLikes to fetch.
     */
    orderBy?: ConferenceLikesOrderByWithRelationInput | ConferenceLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceLikes.
     */
    cursor?: ConferenceLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceLikes.
     */
    distinct?: ConferenceLikesScalarFieldEnum | ConferenceLikesScalarFieldEnum[]
  }

  /**
   * ConferenceLikes findFirstOrThrow
   */
  export type ConferenceLikesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceLikes to fetch.
     */
    where?: ConferenceLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceLikes to fetch.
     */
    orderBy?: ConferenceLikesOrderByWithRelationInput | ConferenceLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceLikes.
     */
    cursor?: ConferenceLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceLikes.
     */
    distinct?: ConferenceLikesScalarFieldEnum | ConferenceLikesScalarFieldEnum[]
  }

  /**
   * ConferenceLikes findMany
   */
  export type ConferenceLikesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceLikes to fetch.
     */
    where?: ConferenceLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceLikes to fetch.
     */
    orderBy?: ConferenceLikesOrderByWithRelationInput | ConferenceLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConferenceLikes.
     */
    cursor?: ConferenceLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceLikes.
     */
    skip?: number
    distinct?: ConferenceLikesScalarFieldEnum | ConferenceLikesScalarFieldEnum[]
  }

  /**
   * ConferenceLikes create
   */
  export type ConferenceLikesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesInclude<ExtArgs> | null
    /**
     * The data needed to create a ConferenceLikes.
     */
    data: XOR<ConferenceLikesCreateInput, ConferenceLikesUncheckedCreateInput>
  }

  /**
   * ConferenceLikes createMany
   */
  export type ConferenceLikesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConferenceLikes.
     */
    data: ConferenceLikesCreateManyInput | ConferenceLikesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConferenceLikes createManyAndReturn
   */
  export type ConferenceLikesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * The data used to create many ConferenceLikes.
     */
    data: ConferenceLikesCreateManyInput | ConferenceLikesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceLikes update
   */
  export type ConferenceLikesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesInclude<ExtArgs> | null
    /**
     * The data needed to update a ConferenceLikes.
     */
    data: XOR<ConferenceLikesUpdateInput, ConferenceLikesUncheckedUpdateInput>
    /**
     * Choose, which ConferenceLikes to update.
     */
    where: ConferenceLikesWhereUniqueInput
  }

  /**
   * ConferenceLikes updateMany
   */
  export type ConferenceLikesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConferenceLikes.
     */
    data: XOR<ConferenceLikesUpdateManyMutationInput, ConferenceLikesUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceLikes to update
     */
    where?: ConferenceLikesWhereInput
    /**
     * Limit how many ConferenceLikes to update.
     */
    limit?: number
  }

  /**
   * ConferenceLikes updateManyAndReturn
   */
  export type ConferenceLikesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * The data used to update ConferenceLikes.
     */
    data: XOR<ConferenceLikesUpdateManyMutationInput, ConferenceLikesUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceLikes to update
     */
    where?: ConferenceLikesWhereInput
    /**
     * Limit how many ConferenceLikes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceLikes upsert
   */
  export type ConferenceLikesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesInclude<ExtArgs> | null
    /**
     * The filter to search for the ConferenceLikes to update in case it exists.
     */
    where: ConferenceLikesWhereUniqueInput
    /**
     * In case the ConferenceLikes found by the `where` argument doesn't exist, create a new ConferenceLikes with this data.
     */
    create: XOR<ConferenceLikesCreateInput, ConferenceLikesUncheckedCreateInput>
    /**
     * In case the ConferenceLikes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferenceLikesUpdateInput, ConferenceLikesUncheckedUpdateInput>
  }

  /**
   * ConferenceLikes delete
   */
  export type ConferenceLikesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesInclude<ExtArgs> | null
    /**
     * Filter which ConferenceLikes to delete.
     */
    where: ConferenceLikesWhereUniqueInput
  }

  /**
   * ConferenceLikes deleteMany
   */
  export type ConferenceLikesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceLikes to delete
     */
    where?: ConferenceLikesWhereInput
    /**
     * Limit how many ConferenceLikes to delete.
     */
    limit?: number
  }

  /**
   * ConferenceLikes without action
   */
  export type ConferenceLikesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesInclude<ExtArgs> | null
  }


  /**
   * Model ConferenceOrganizations
   */

  export type AggregateConferenceOrganizations = {
    _count: ConferenceOrganizationsCountAggregateOutputType | null
    _avg: ConferenceOrganizationsAvgAggregateOutputType | null
    _sum: ConferenceOrganizationsSumAggregateOutputType | null
    _min: ConferenceOrganizationsMinAggregateOutputType | null
    _max: ConferenceOrganizationsMaxAggregateOutputType | null
  }

  export type ConferenceOrganizationsAvgAggregateOutputType = {
    year: number | null
  }

  export type ConferenceOrganizationsSumAggregateOutputType = {
    year: number | null
  }

  export type ConferenceOrganizationsMinAggregateOutputType = {
    id: string | null
    year: number | null
    accessType: string | null
    isAvailable: boolean | null
    conferenceId: string | null
    publisher: string | null
    summerize: string | null
    callForPaper: string | null
    link: string | null
    cfpLink: string | null
    impLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceOrganizationsMaxAggregateOutputType = {
    id: string | null
    year: number | null
    accessType: string | null
    isAvailable: boolean | null
    conferenceId: string | null
    publisher: string | null
    summerize: string | null
    callForPaper: string | null
    link: string | null
    cfpLink: string | null
    impLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceOrganizationsCountAggregateOutputType = {
    id: number
    year: number
    accessType: number
    isAvailable: number
    conferenceId: number
    publisher: number
    summerize: number
    callForPaper: number
    link: number
    cfpLink: number
    impLink: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConferenceOrganizationsAvgAggregateInputType = {
    year?: true
  }

  export type ConferenceOrganizationsSumAggregateInputType = {
    year?: true
  }

  export type ConferenceOrganizationsMinAggregateInputType = {
    id?: true
    year?: true
    accessType?: true
    isAvailable?: true
    conferenceId?: true
    publisher?: true
    summerize?: true
    callForPaper?: true
    link?: true
    cfpLink?: true
    impLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceOrganizationsMaxAggregateInputType = {
    id?: true
    year?: true
    accessType?: true
    isAvailable?: true
    conferenceId?: true
    publisher?: true
    summerize?: true
    callForPaper?: true
    link?: true
    cfpLink?: true
    impLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceOrganizationsCountAggregateInputType = {
    id?: true
    year?: true
    accessType?: true
    isAvailable?: true
    conferenceId?: true
    publisher?: true
    summerize?: true
    callForPaper?: true
    link?: true
    cfpLink?: true
    impLink?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConferenceOrganizationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceOrganizations to aggregate.
     */
    where?: ConferenceOrganizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceOrganizations to fetch.
     */
    orderBy?: ConferenceOrganizationsOrderByWithRelationInput | ConferenceOrganizationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferenceOrganizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceOrganizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConferenceOrganizations
    **/
    _count?: true | ConferenceOrganizationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConferenceOrganizationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConferenceOrganizationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferenceOrganizationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferenceOrganizationsMaxAggregateInputType
  }

  export type GetConferenceOrganizationsAggregateType<T extends ConferenceOrganizationsAggregateArgs> = {
        [P in keyof T & keyof AggregateConferenceOrganizations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferenceOrganizations[P]>
      : GetScalarType<T[P], AggregateConferenceOrganizations[P]>
  }




  export type ConferenceOrganizationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceOrganizationsWhereInput
    orderBy?: ConferenceOrganizationsOrderByWithAggregationInput | ConferenceOrganizationsOrderByWithAggregationInput[]
    by: ConferenceOrganizationsScalarFieldEnum[] | ConferenceOrganizationsScalarFieldEnum
    having?: ConferenceOrganizationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferenceOrganizationsCountAggregateInputType | true
    _avg?: ConferenceOrganizationsAvgAggregateInputType
    _sum?: ConferenceOrganizationsSumAggregateInputType
    _min?: ConferenceOrganizationsMinAggregateInputType
    _max?: ConferenceOrganizationsMaxAggregateInputType
  }

  export type ConferenceOrganizationsGroupByOutputType = {
    id: string
    year: number | null
    accessType: string
    isAvailable: boolean
    conferenceId: string
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt: Date
    updatedAt: Date
    _count: ConferenceOrganizationsCountAggregateOutputType | null
    _avg: ConferenceOrganizationsAvgAggregateOutputType | null
    _sum: ConferenceOrganizationsSumAggregateOutputType | null
    _min: ConferenceOrganizationsMinAggregateOutputType | null
    _max: ConferenceOrganizationsMaxAggregateOutputType | null
  }

  type GetConferenceOrganizationsGroupByPayload<T extends ConferenceOrganizationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferenceOrganizationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferenceOrganizationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferenceOrganizationsGroupByOutputType[P]>
            : GetScalarType<T[P], ConferenceOrganizationsGroupByOutputType[P]>
        }
      >
    >


  export type ConferenceOrganizationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    accessType?: boolean
    isAvailable?: boolean
    conferenceId?: boolean
    publisher?: boolean
    summerize?: boolean
    callForPaper?: boolean
    link?: boolean
    cfpLink?: boolean
    impLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ConferenceDates?: boolean | ConferenceOrganizations$ConferenceDatesArgs<ExtArgs>
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    ConferenceTopics?: boolean | ConferenceOrganizations$ConferenceTopicsArgs<ExtArgs>
    Locations?: boolean | ConferenceOrganizations$LocationsArgs<ExtArgs>
    _count?: boolean | ConferenceOrganizationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceOrganizations"]>

  export type ConferenceOrganizationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    accessType?: boolean
    isAvailable?: boolean
    conferenceId?: boolean
    publisher?: boolean
    summerize?: boolean
    callForPaper?: boolean
    link?: boolean
    cfpLink?: boolean
    impLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceOrganizations"]>

  export type ConferenceOrganizationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    accessType?: boolean
    isAvailable?: boolean
    conferenceId?: boolean
    publisher?: boolean
    summerize?: boolean
    callForPaper?: boolean
    link?: boolean
    cfpLink?: boolean
    impLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceOrganizations"]>

  export type ConferenceOrganizationsSelectScalar = {
    id?: boolean
    year?: boolean
    accessType?: boolean
    isAvailable?: boolean
    conferenceId?: boolean
    publisher?: boolean
    summerize?: boolean
    callForPaper?: boolean
    link?: boolean
    cfpLink?: boolean
    impLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConferenceOrganizationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "year" | "accessType" | "isAvailable" | "conferenceId" | "publisher" | "summerize" | "callForPaper" | "link" | "cfpLink" | "impLink" | "createdAt" | "updatedAt", ExtArgs["result"]["conferenceOrganizations"]>
  export type ConferenceOrganizationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConferenceDates?: boolean | ConferenceOrganizations$ConferenceDatesArgs<ExtArgs>
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    ConferenceTopics?: boolean | ConferenceOrganizations$ConferenceTopicsArgs<ExtArgs>
    Locations?: boolean | ConferenceOrganizations$LocationsArgs<ExtArgs>
    _count?: boolean | ConferenceOrganizationsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConferenceOrganizationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
  }
  export type ConferenceOrganizationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
  }

  export type $ConferenceOrganizationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConferenceOrganizations"
    objects: {
      ConferenceDates: Prisma.$ConferenceDatesPayload<ExtArgs>[]
      Conferences: Prisma.$ConferencesPayload<ExtArgs>
      ConferenceTopics: Prisma.$ConferenceTopicsPayload<ExtArgs>[]
      Locations: Prisma.$LocationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      year: number | null
      accessType: string
      isAvailable: boolean
      conferenceId: string
      publisher: string
      summerize: string
      callForPaper: string
      link: string
      cfpLink: string
      impLink: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conferenceOrganizations"]>
    composites: {}
  }

  type ConferenceOrganizationsGetPayload<S extends boolean | null | undefined | ConferenceOrganizationsDefaultArgs> = $Result.GetResult<Prisma.$ConferenceOrganizationsPayload, S>

  type ConferenceOrganizationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferenceOrganizationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferenceOrganizationsCountAggregateInputType | true
    }

  export interface ConferenceOrganizationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConferenceOrganizations'], meta: { name: 'ConferenceOrganizations' } }
    /**
     * Find zero or one ConferenceOrganizations that matches the filter.
     * @param {ConferenceOrganizationsFindUniqueArgs} args - Arguments to find a ConferenceOrganizations
     * @example
     * // Get one ConferenceOrganizations
     * const conferenceOrganizations = await prisma.conferenceOrganizations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferenceOrganizationsFindUniqueArgs>(args: SelectSubset<T, ConferenceOrganizationsFindUniqueArgs<ExtArgs>>): Prisma__ConferenceOrganizationsClient<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConferenceOrganizations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferenceOrganizationsFindUniqueOrThrowArgs} args - Arguments to find a ConferenceOrganizations
     * @example
     * // Get one ConferenceOrganizations
     * const conferenceOrganizations = await prisma.conferenceOrganizations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferenceOrganizationsFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferenceOrganizationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferenceOrganizationsClient<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceOrganizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceOrganizationsFindFirstArgs} args - Arguments to find a ConferenceOrganizations
     * @example
     * // Get one ConferenceOrganizations
     * const conferenceOrganizations = await prisma.conferenceOrganizations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferenceOrganizationsFindFirstArgs>(args?: SelectSubset<T, ConferenceOrganizationsFindFirstArgs<ExtArgs>>): Prisma__ConferenceOrganizationsClient<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceOrganizations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceOrganizationsFindFirstOrThrowArgs} args - Arguments to find a ConferenceOrganizations
     * @example
     * // Get one ConferenceOrganizations
     * const conferenceOrganizations = await prisma.conferenceOrganizations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferenceOrganizationsFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferenceOrganizationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferenceOrganizationsClient<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConferenceOrganizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceOrganizationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConferenceOrganizations
     * const conferenceOrganizations = await prisma.conferenceOrganizations.findMany()
     * 
     * // Get first 10 ConferenceOrganizations
     * const conferenceOrganizations = await prisma.conferenceOrganizations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferenceOrganizationsWithIdOnly = await prisma.conferenceOrganizations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferenceOrganizationsFindManyArgs>(args?: SelectSubset<T, ConferenceOrganizationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConferenceOrganizations.
     * @param {ConferenceOrganizationsCreateArgs} args - Arguments to create a ConferenceOrganizations.
     * @example
     * // Create one ConferenceOrganizations
     * const ConferenceOrganizations = await prisma.conferenceOrganizations.create({
     *   data: {
     *     // ... data to create a ConferenceOrganizations
     *   }
     * })
     * 
     */
    create<T extends ConferenceOrganizationsCreateArgs>(args: SelectSubset<T, ConferenceOrganizationsCreateArgs<ExtArgs>>): Prisma__ConferenceOrganizationsClient<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConferenceOrganizations.
     * @param {ConferenceOrganizationsCreateManyArgs} args - Arguments to create many ConferenceOrganizations.
     * @example
     * // Create many ConferenceOrganizations
     * const conferenceOrganizations = await prisma.conferenceOrganizations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferenceOrganizationsCreateManyArgs>(args?: SelectSubset<T, ConferenceOrganizationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConferenceOrganizations and returns the data saved in the database.
     * @param {ConferenceOrganizationsCreateManyAndReturnArgs} args - Arguments to create many ConferenceOrganizations.
     * @example
     * // Create many ConferenceOrganizations
     * const conferenceOrganizations = await prisma.conferenceOrganizations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConferenceOrganizations and only return the `id`
     * const conferenceOrganizationsWithIdOnly = await prisma.conferenceOrganizations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferenceOrganizationsCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferenceOrganizationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConferenceOrganizations.
     * @param {ConferenceOrganizationsDeleteArgs} args - Arguments to delete one ConferenceOrganizations.
     * @example
     * // Delete one ConferenceOrganizations
     * const ConferenceOrganizations = await prisma.conferenceOrganizations.delete({
     *   where: {
     *     // ... filter to delete one ConferenceOrganizations
     *   }
     * })
     * 
     */
    delete<T extends ConferenceOrganizationsDeleteArgs>(args: SelectSubset<T, ConferenceOrganizationsDeleteArgs<ExtArgs>>): Prisma__ConferenceOrganizationsClient<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConferenceOrganizations.
     * @param {ConferenceOrganizationsUpdateArgs} args - Arguments to update one ConferenceOrganizations.
     * @example
     * // Update one ConferenceOrganizations
     * const conferenceOrganizations = await prisma.conferenceOrganizations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferenceOrganizationsUpdateArgs>(args: SelectSubset<T, ConferenceOrganizationsUpdateArgs<ExtArgs>>): Prisma__ConferenceOrganizationsClient<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConferenceOrganizations.
     * @param {ConferenceOrganizationsDeleteManyArgs} args - Arguments to filter ConferenceOrganizations to delete.
     * @example
     * // Delete a few ConferenceOrganizations
     * const { count } = await prisma.conferenceOrganizations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferenceOrganizationsDeleteManyArgs>(args?: SelectSubset<T, ConferenceOrganizationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceOrganizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceOrganizationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConferenceOrganizations
     * const conferenceOrganizations = await prisma.conferenceOrganizations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferenceOrganizationsUpdateManyArgs>(args: SelectSubset<T, ConferenceOrganizationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceOrganizations and returns the data updated in the database.
     * @param {ConferenceOrganizationsUpdateManyAndReturnArgs} args - Arguments to update many ConferenceOrganizations.
     * @example
     * // Update many ConferenceOrganizations
     * const conferenceOrganizations = await prisma.conferenceOrganizations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConferenceOrganizations and only return the `id`
     * const conferenceOrganizationsWithIdOnly = await prisma.conferenceOrganizations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferenceOrganizationsUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferenceOrganizationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConferenceOrganizations.
     * @param {ConferenceOrganizationsUpsertArgs} args - Arguments to update or create a ConferenceOrganizations.
     * @example
     * // Update or create a ConferenceOrganizations
     * const conferenceOrganizations = await prisma.conferenceOrganizations.upsert({
     *   create: {
     *     // ... data to create a ConferenceOrganizations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConferenceOrganizations we want to update
     *   }
     * })
     */
    upsert<T extends ConferenceOrganizationsUpsertArgs>(args: SelectSubset<T, ConferenceOrganizationsUpsertArgs<ExtArgs>>): Prisma__ConferenceOrganizationsClient<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConferenceOrganizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceOrganizationsCountArgs} args - Arguments to filter ConferenceOrganizations to count.
     * @example
     * // Count the number of ConferenceOrganizations
     * const count = await prisma.conferenceOrganizations.count({
     *   where: {
     *     // ... the filter for the ConferenceOrganizations we want to count
     *   }
     * })
    **/
    count<T extends ConferenceOrganizationsCountArgs>(
      args?: Subset<T, ConferenceOrganizationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferenceOrganizationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConferenceOrganizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceOrganizationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferenceOrganizationsAggregateArgs>(args: Subset<T, ConferenceOrganizationsAggregateArgs>): Prisma.PrismaPromise<GetConferenceOrganizationsAggregateType<T>>

    /**
     * Group by ConferenceOrganizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceOrganizationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferenceOrganizationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferenceOrganizationsGroupByArgs['orderBy'] }
        : { orderBy?: ConferenceOrganizationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferenceOrganizationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferenceOrganizationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConferenceOrganizations model
   */
  readonly fields: ConferenceOrganizationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConferenceOrganizations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferenceOrganizationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ConferenceDates<T extends ConferenceOrganizations$ConferenceDatesArgs<ExtArgs> = {}>(args?: Subset<T, ConferenceOrganizations$ConferenceDatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceDatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Conferences<T extends ConferencesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferencesDefaultArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ConferenceTopics<T extends ConferenceOrganizations$ConferenceTopicsArgs<ExtArgs> = {}>(args?: Subset<T, ConferenceOrganizations$ConferenceTopicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Locations<T extends ConferenceOrganizations$LocationsArgs<ExtArgs> = {}>(args?: Subset<T, ConferenceOrganizations$LocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConferenceOrganizations model
   */ 
  interface ConferenceOrganizationsFieldRefs {
    readonly id: FieldRef<"ConferenceOrganizations", 'String'>
    readonly year: FieldRef<"ConferenceOrganizations", 'Int'>
    readonly accessType: FieldRef<"ConferenceOrganizations", 'String'>
    readonly isAvailable: FieldRef<"ConferenceOrganizations", 'Boolean'>
    readonly conferenceId: FieldRef<"ConferenceOrganizations", 'String'>
    readonly publisher: FieldRef<"ConferenceOrganizations", 'String'>
    readonly summerize: FieldRef<"ConferenceOrganizations", 'String'>
    readonly callForPaper: FieldRef<"ConferenceOrganizations", 'String'>
    readonly link: FieldRef<"ConferenceOrganizations", 'String'>
    readonly cfpLink: FieldRef<"ConferenceOrganizations", 'String'>
    readonly impLink: FieldRef<"ConferenceOrganizations", 'String'>
    readonly createdAt: FieldRef<"ConferenceOrganizations", 'DateTime'>
    readonly updatedAt: FieldRef<"ConferenceOrganizations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConferenceOrganizations findUnique
   */
  export type ConferenceOrganizationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceOrganizations to fetch.
     */
    where: ConferenceOrganizationsWhereUniqueInput
  }

  /**
   * ConferenceOrganizations findUniqueOrThrow
   */
  export type ConferenceOrganizationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceOrganizations to fetch.
     */
    where: ConferenceOrganizationsWhereUniqueInput
  }

  /**
   * ConferenceOrganizations findFirst
   */
  export type ConferenceOrganizationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceOrganizations to fetch.
     */
    where?: ConferenceOrganizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceOrganizations to fetch.
     */
    orderBy?: ConferenceOrganizationsOrderByWithRelationInput | ConferenceOrganizationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceOrganizations.
     */
    cursor?: ConferenceOrganizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceOrganizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceOrganizations.
     */
    distinct?: ConferenceOrganizationsScalarFieldEnum | ConferenceOrganizationsScalarFieldEnum[]
  }

  /**
   * ConferenceOrganizations findFirstOrThrow
   */
  export type ConferenceOrganizationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceOrganizations to fetch.
     */
    where?: ConferenceOrganizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceOrganizations to fetch.
     */
    orderBy?: ConferenceOrganizationsOrderByWithRelationInput | ConferenceOrganizationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceOrganizations.
     */
    cursor?: ConferenceOrganizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceOrganizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceOrganizations.
     */
    distinct?: ConferenceOrganizationsScalarFieldEnum | ConferenceOrganizationsScalarFieldEnum[]
  }

  /**
   * ConferenceOrganizations findMany
   */
  export type ConferenceOrganizationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceOrganizations to fetch.
     */
    where?: ConferenceOrganizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceOrganizations to fetch.
     */
    orderBy?: ConferenceOrganizationsOrderByWithRelationInput | ConferenceOrganizationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConferenceOrganizations.
     */
    cursor?: ConferenceOrganizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceOrganizations.
     */
    skip?: number
    distinct?: ConferenceOrganizationsScalarFieldEnum | ConferenceOrganizationsScalarFieldEnum[]
  }

  /**
   * ConferenceOrganizations create
   */
  export type ConferenceOrganizationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsInclude<ExtArgs> | null
    /**
     * The data needed to create a ConferenceOrganizations.
     */
    data: XOR<ConferenceOrganizationsCreateInput, ConferenceOrganizationsUncheckedCreateInput>
  }

  /**
   * ConferenceOrganizations createMany
   */
  export type ConferenceOrganizationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConferenceOrganizations.
     */
    data: ConferenceOrganizationsCreateManyInput | ConferenceOrganizationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConferenceOrganizations createManyAndReturn
   */
  export type ConferenceOrganizationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * The data used to create many ConferenceOrganizations.
     */
    data: ConferenceOrganizationsCreateManyInput | ConferenceOrganizationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceOrganizations update
   */
  export type ConferenceOrganizationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsInclude<ExtArgs> | null
    /**
     * The data needed to update a ConferenceOrganizations.
     */
    data: XOR<ConferenceOrganizationsUpdateInput, ConferenceOrganizationsUncheckedUpdateInput>
    /**
     * Choose, which ConferenceOrganizations to update.
     */
    where: ConferenceOrganizationsWhereUniqueInput
  }

  /**
   * ConferenceOrganizations updateMany
   */
  export type ConferenceOrganizationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConferenceOrganizations.
     */
    data: XOR<ConferenceOrganizationsUpdateManyMutationInput, ConferenceOrganizationsUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceOrganizations to update
     */
    where?: ConferenceOrganizationsWhereInput
    /**
     * Limit how many ConferenceOrganizations to update.
     */
    limit?: number
  }

  /**
   * ConferenceOrganizations updateManyAndReturn
   */
  export type ConferenceOrganizationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * The data used to update ConferenceOrganizations.
     */
    data: XOR<ConferenceOrganizationsUpdateManyMutationInput, ConferenceOrganizationsUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceOrganizations to update
     */
    where?: ConferenceOrganizationsWhereInput
    /**
     * Limit how many ConferenceOrganizations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceOrganizations upsert
   */
  export type ConferenceOrganizationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsInclude<ExtArgs> | null
    /**
     * The filter to search for the ConferenceOrganizations to update in case it exists.
     */
    where: ConferenceOrganizationsWhereUniqueInput
    /**
     * In case the ConferenceOrganizations found by the `where` argument doesn't exist, create a new ConferenceOrganizations with this data.
     */
    create: XOR<ConferenceOrganizationsCreateInput, ConferenceOrganizationsUncheckedCreateInput>
    /**
     * In case the ConferenceOrganizations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferenceOrganizationsUpdateInput, ConferenceOrganizationsUncheckedUpdateInput>
  }

  /**
   * ConferenceOrganizations delete
   */
  export type ConferenceOrganizationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsInclude<ExtArgs> | null
    /**
     * Filter which ConferenceOrganizations to delete.
     */
    where: ConferenceOrganizationsWhereUniqueInput
  }

  /**
   * ConferenceOrganizations deleteMany
   */
  export type ConferenceOrganizationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceOrganizations to delete
     */
    where?: ConferenceOrganizationsWhereInput
    /**
     * Limit how many ConferenceOrganizations to delete.
     */
    limit?: number
  }

  /**
   * ConferenceOrganizations.ConferenceDates
   */
  export type ConferenceOrganizations$ConferenceDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesInclude<ExtArgs> | null
    where?: ConferenceDatesWhereInput
    orderBy?: ConferenceDatesOrderByWithRelationInput | ConferenceDatesOrderByWithRelationInput[]
    cursor?: ConferenceDatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceDatesScalarFieldEnum | ConferenceDatesScalarFieldEnum[]
  }

  /**
   * ConferenceOrganizations.ConferenceTopics
   */
  export type ConferenceOrganizations$ConferenceTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsInclude<ExtArgs> | null
    where?: ConferenceTopicsWhereInput
    orderBy?: ConferenceTopicsOrderByWithRelationInput | ConferenceTopicsOrderByWithRelationInput[]
    cursor?: ConferenceTopicsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceTopicsScalarFieldEnum | ConferenceTopicsScalarFieldEnum[]
  }

  /**
   * ConferenceOrganizations.Locations
   */
  export type ConferenceOrganizations$LocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    where?: LocationsWhereInput
    orderBy?: LocationsOrderByWithRelationInput | LocationsOrderByWithRelationInput[]
    cursor?: LocationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * ConferenceOrganizations without action
   */
  export type ConferenceOrganizationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsInclude<ExtArgs> | null
  }


  /**
   * Model ConferenceRanks
   */

  export type AggregateConferenceRanks = {
    _count: ConferenceRanksCountAggregateOutputType | null
    _avg: ConferenceRanksAvgAggregateOutputType | null
    _sum: ConferenceRanksSumAggregateOutputType | null
    _min: ConferenceRanksMinAggregateOutputType | null
    _max: ConferenceRanksMaxAggregateOutputType | null
  }

  export type ConferenceRanksAvgAggregateOutputType = {
    year: number | null
  }

  export type ConferenceRanksSumAggregateOutputType = {
    year: number | null
  }

  export type ConferenceRanksMinAggregateOutputType = {
    id: string | null
    year: number | null
    conferenceId: string | null
    fieldOfResearchId: string | null
    rankId: string | null
  }

  export type ConferenceRanksMaxAggregateOutputType = {
    id: string | null
    year: number | null
    conferenceId: string | null
    fieldOfResearchId: string | null
    rankId: string | null
  }

  export type ConferenceRanksCountAggregateOutputType = {
    id: number
    year: number
    conferenceId: number
    fieldOfResearchId: number
    rankId: number
    _all: number
  }


  export type ConferenceRanksAvgAggregateInputType = {
    year?: true
  }

  export type ConferenceRanksSumAggregateInputType = {
    year?: true
  }

  export type ConferenceRanksMinAggregateInputType = {
    id?: true
    year?: true
    conferenceId?: true
    fieldOfResearchId?: true
    rankId?: true
  }

  export type ConferenceRanksMaxAggregateInputType = {
    id?: true
    year?: true
    conferenceId?: true
    fieldOfResearchId?: true
    rankId?: true
  }

  export type ConferenceRanksCountAggregateInputType = {
    id?: true
    year?: true
    conferenceId?: true
    fieldOfResearchId?: true
    rankId?: true
    _all?: true
  }

  export type ConferenceRanksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceRanks to aggregate.
     */
    where?: ConferenceRanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceRanks to fetch.
     */
    orderBy?: ConferenceRanksOrderByWithRelationInput | ConferenceRanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferenceRanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceRanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceRanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConferenceRanks
    **/
    _count?: true | ConferenceRanksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConferenceRanksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConferenceRanksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferenceRanksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferenceRanksMaxAggregateInputType
  }

  export type GetConferenceRanksAggregateType<T extends ConferenceRanksAggregateArgs> = {
        [P in keyof T & keyof AggregateConferenceRanks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferenceRanks[P]>
      : GetScalarType<T[P], AggregateConferenceRanks[P]>
  }




  export type ConferenceRanksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceRanksWhereInput
    orderBy?: ConferenceRanksOrderByWithAggregationInput | ConferenceRanksOrderByWithAggregationInput[]
    by: ConferenceRanksScalarFieldEnum[] | ConferenceRanksScalarFieldEnum
    having?: ConferenceRanksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferenceRanksCountAggregateInputType | true
    _avg?: ConferenceRanksAvgAggregateInputType
    _sum?: ConferenceRanksSumAggregateInputType
    _min?: ConferenceRanksMinAggregateInputType
    _max?: ConferenceRanksMaxAggregateInputType
  }

  export type ConferenceRanksGroupByOutputType = {
    id: string
    year: number
    conferenceId: string
    fieldOfResearchId: string
    rankId: string
    _count: ConferenceRanksCountAggregateOutputType | null
    _avg: ConferenceRanksAvgAggregateOutputType | null
    _sum: ConferenceRanksSumAggregateOutputType | null
    _min: ConferenceRanksMinAggregateOutputType | null
    _max: ConferenceRanksMaxAggregateOutputType | null
  }

  type GetConferenceRanksGroupByPayload<T extends ConferenceRanksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferenceRanksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferenceRanksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferenceRanksGroupByOutputType[P]>
            : GetScalarType<T[P], ConferenceRanksGroupByOutputType[P]>
        }
      >
    >


  export type ConferenceRanksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    conferenceId?: boolean
    fieldOfResearchId?: boolean
    rankId?: boolean
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    FieldOfResearchs?: boolean | FieldOfResearchsDefaultArgs<ExtArgs>
    Ranks?: boolean | RanksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceRanks"]>

  export type ConferenceRanksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    conferenceId?: boolean
    fieldOfResearchId?: boolean
    rankId?: boolean
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    FieldOfResearchs?: boolean | FieldOfResearchsDefaultArgs<ExtArgs>
    Ranks?: boolean | RanksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceRanks"]>

  export type ConferenceRanksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    conferenceId?: boolean
    fieldOfResearchId?: boolean
    rankId?: boolean
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    FieldOfResearchs?: boolean | FieldOfResearchsDefaultArgs<ExtArgs>
    Ranks?: boolean | RanksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceRanks"]>

  export type ConferenceRanksSelectScalar = {
    id?: boolean
    year?: boolean
    conferenceId?: boolean
    fieldOfResearchId?: boolean
    rankId?: boolean
  }

  export type ConferenceRanksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "year" | "conferenceId" | "fieldOfResearchId" | "rankId", ExtArgs["result"]["conferenceRanks"]>
  export type ConferenceRanksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    FieldOfResearchs?: boolean | FieldOfResearchsDefaultArgs<ExtArgs>
    Ranks?: boolean | RanksDefaultArgs<ExtArgs>
  }
  export type ConferenceRanksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    FieldOfResearchs?: boolean | FieldOfResearchsDefaultArgs<ExtArgs>
    Ranks?: boolean | RanksDefaultArgs<ExtArgs>
  }
  export type ConferenceRanksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conferences?: boolean | ConferencesDefaultArgs<ExtArgs>
    FieldOfResearchs?: boolean | FieldOfResearchsDefaultArgs<ExtArgs>
    Ranks?: boolean | RanksDefaultArgs<ExtArgs>
  }

  export type $ConferenceRanksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConferenceRanks"
    objects: {
      Conferences: Prisma.$ConferencesPayload<ExtArgs>
      FieldOfResearchs: Prisma.$FieldOfResearchsPayload<ExtArgs>
      Ranks: Prisma.$RanksPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      year: number
      conferenceId: string
      fieldOfResearchId: string
      rankId: string
    }, ExtArgs["result"]["conferenceRanks"]>
    composites: {}
  }

  type ConferenceRanksGetPayload<S extends boolean | null | undefined | ConferenceRanksDefaultArgs> = $Result.GetResult<Prisma.$ConferenceRanksPayload, S>

  type ConferenceRanksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferenceRanksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferenceRanksCountAggregateInputType | true
    }

  export interface ConferenceRanksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConferenceRanks'], meta: { name: 'ConferenceRanks' } }
    /**
     * Find zero or one ConferenceRanks that matches the filter.
     * @param {ConferenceRanksFindUniqueArgs} args - Arguments to find a ConferenceRanks
     * @example
     * // Get one ConferenceRanks
     * const conferenceRanks = await prisma.conferenceRanks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferenceRanksFindUniqueArgs>(args: SelectSubset<T, ConferenceRanksFindUniqueArgs<ExtArgs>>): Prisma__ConferenceRanksClient<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConferenceRanks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferenceRanksFindUniqueOrThrowArgs} args - Arguments to find a ConferenceRanks
     * @example
     * // Get one ConferenceRanks
     * const conferenceRanks = await prisma.conferenceRanks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferenceRanksFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferenceRanksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferenceRanksClient<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceRanks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceRanksFindFirstArgs} args - Arguments to find a ConferenceRanks
     * @example
     * // Get one ConferenceRanks
     * const conferenceRanks = await prisma.conferenceRanks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferenceRanksFindFirstArgs>(args?: SelectSubset<T, ConferenceRanksFindFirstArgs<ExtArgs>>): Prisma__ConferenceRanksClient<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceRanks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceRanksFindFirstOrThrowArgs} args - Arguments to find a ConferenceRanks
     * @example
     * // Get one ConferenceRanks
     * const conferenceRanks = await prisma.conferenceRanks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferenceRanksFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferenceRanksFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferenceRanksClient<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConferenceRanks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceRanksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConferenceRanks
     * const conferenceRanks = await prisma.conferenceRanks.findMany()
     * 
     * // Get first 10 ConferenceRanks
     * const conferenceRanks = await prisma.conferenceRanks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferenceRanksWithIdOnly = await prisma.conferenceRanks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferenceRanksFindManyArgs>(args?: SelectSubset<T, ConferenceRanksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConferenceRanks.
     * @param {ConferenceRanksCreateArgs} args - Arguments to create a ConferenceRanks.
     * @example
     * // Create one ConferenceRanks
     * const ConferenceRanks = await prisma.conferenceRanks.create({
     *   data: {
     *     // ... data to create a ConferenceRanks
     *   }
     * })
     * 
     */
    create<T extends ConferenceRanksCreateArgs>(args: SelectSubset<T, ConferenceRanksCreateArgs<ExtArgs>>): Prisma__ConferenceRanksClient<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConferenceRanks.
     * @param {ConferenceRanksCreateManyArgs} args - Arguments to create many ConferenceRanks.
     * @example
     * // Create many ConferenceRanks
     * const conferenceRanks = await prisma.conferenceRanks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferenceRanksCreateManyArgs>(args?: SelectSubset<T, ConferenceRanksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConferenceRanks and returns the data saved in the database.
     * @param {ConferenceRanksCreateManyAndReturnArgs} args - Arguments to create many ConferenceRanks.
     * @example
     * // Create many ConferenceRanks
     * const conferenceRanks = await prisma.conferenceRanks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConferenceRanks and only return the `id`
     * const conferenceRanksWithIdOnly = await prisma.conferenceRanks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferenceRanksCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferenceRanksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConferenceRanks.
     * @param {ConferenceRanksDeleteArgs} args - Arguments to delete one ConferenceRanks.
     * @example
     * // Delete one ConferenceRanks
     * const ConferenceRanks = await prisma.conferenceRanks.delete({
     *   where: {
     *     // ... filter to delete one ConferenceRanks
     *   }
     * })
     * 
     */
    delete<T extends ConferenceRanksDeleteArgs>(args: SelectSubset<T, ConferenceRanksDeleteArgs<ExtArgs>>): Prisma__ConferenceRanksClient<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConferenceRanks.
     * @param {ConferenceRanksUpdateArgs} args - Arguments to update one ConferenceRanks.
     * @example
     * // Update one ConferenceRanks
     * const conferenceRanks = await prisma.conferenceRanks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferenceRanksUpdateArgs>(args: SelectSubset<T, ConferenceRanksUpdateArgs<ExtArgs>>): Prisma__ConferenceRanksClient<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConferenceRanks.
     * @param {ConferenceRanksDeleteManyArgs} args - Arguments to filter ConferenceRanks to delete.
     * @example
     * // Delete a few ConferenceRanks
     * const { count } = await prisma.conferenceRanks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferenceRanksDeleteManyArgs>(args?: SelectSubset<T, ConferenceRanksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceRanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceRanksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConferenceRanks
     * const conferenceRanks = await prisma.conferenceRanks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferenceRanksUpdateManyArgs>(args: SelectSubset<T, ConferenceRanksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceRanks and returns the data updated in the database.
     * @param {ConferenceRanksUpdateManyAndReturnArgs} args - Arguments to update many ConferenceRanks.
     * @example
     * // Update many ConferenceRanks
     * const conferenceRanks = await prisma.conferenceRanks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConferenceRanks and only return the `id`
     * const conferenceRanksWithIdOnly = await prisma.conferenceRanks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferenceRanksUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferenceRanksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConferenceRanks.
     * @param {ConferenceRanksUpsertArgs} args - Arguments to update or create a ConferenceRanks.
     * @example
     * // Update or create a ConferenceRanks
     * const conferenceRanks = await prisma.conferenceRanks.upsert({
     *   create: {
     *     // ... data to create a ConferenceRanks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConferenceRanks we want to update
     *   }
     * })
     */
    upsert<T extends ConferenceRanksUpsertArgs>(args: SelectSubset<T, ConferenceRanksUpsertArgs<ExtArgs>>): Prisma__ConferenceRanksClient<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConferenceRanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceRanksCountArgs} args - Arguments to filter ConferenceRanks to count.
     * @example
     * // Count the number of ConferenceRanks
     * const count = await prisma.conferenceRanks.count({
     *   where: {
     *     // ... the filter for the ConferenceRanks we want to count
     *   }
     * })
    **/
    count<T extends ConferenceRanksCountArgs>(
      args?: Subset<T, ConferenceRanksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferenceRanksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConferenceRanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceRanksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferenceRanksAggregateArgs>(args: Subset<T, ConferenceRanksAggregateArgs>): Prisma.PrismaPromise<GetConferenceRanksAggregateType<T>>

    /**
     * Group by ConferenceRanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceRanksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferenceRanksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferenceRanksGroupByArgs['orderBy'] }
        : { orderBy?: ConferenceRanksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferenceRanksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferenceRanksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConferenceRanks model
   */
  readonly fields: ConferenceRanksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConferenceRanks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferenceRanksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Conferences<T extends ConferencesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferencesDefaultArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    FieldOfResearchs<T extends FieldOfResearchsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FieldOfResearchsDefaultArgs<ExtArgs>>): Prisma__FieldOfResearchsClient<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Ranks<T extends RanksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RanksDefaultArgs<ExtArgs>>): Prisma__RanksClient<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConferenceRanks model
   */ 
  interface ConferenceRanksFieldRefs {
    readonly id: FieldRef<"ConferenceRanks", 'String'>
    readonly year: FieldRef<"ConferenceRanks", 'Int'>
    readonly conferenceId: FieldRef<"ConferenceRanks", 'String'>
    readonly fieldOfResearchId: FieldRef<"ConferenceRanks", 'String'>
    readonly rankId: FieldRef<"ConferenceRanks", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ConferenceRanks findUnique
   */
  export type ConferenceRanksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceRanks to fetch.
     */
    where: ConferenceRanksWhereUniqueInput
  }

  /**
   * ConferenceRanks findUniqueOrThrow
   */
  export type ConferenceRanksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceRanks to fetch.
     */
    where: ConferenceRanksWhereUniqueInput
  }

  /**
   * ConferenceRanks findFirst
   */
  export type ConferenceRanksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceRanks to fetch.
     */
    where?: ConferenceRanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceRanks to fetch.
     */
    orderBy?: ConferenceRanksOrderByWithRelationInput | ConferenceRanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceRanks.
     */
    cursor?: ConferenceRanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceRanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceRanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceRanks.
     */
    distinct?: ConferenceRanksScalarFieldEnum | ConferenceRanksScalarFieldEnum[]
  }

  /**
   * ConferenceRanks findFirstOrThrow
   */
  export type ConferenceRanksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceRanks to fetch.
     */
    where?: ConferenceRanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceRanks to fetch.
     */
    orderBy?: ConferenceRanksOrderByWithRelationInput | ConferenceRanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceRanks.
     */
    cursor?: ConferenceRanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceRanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceRanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceRanks.
     */
    distinct?: ConferenceRanksScalarFieldEnum | ConferenceRanksScalarFieldEnum[]
  }

  /**
   * ConferenceRanks findMany
   */
  export type ConferenceRanksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceRanks to fetch.
     */
    where?: ConferenceRanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceRanks to fetch.
     */
    orderBy?: ConferenceRanksOrderByWithRelationInput | ConferenceRanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConferenceRanks.
     */
    cursor?: ConferenceRanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceRanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceRanks.
     */
    skip?: number
    distinct?: ConferenceRanksScalarFieldEnum | ConferenceRanksScalarFieldEnum[]
  }

  /**
   * ConferenceRanks create
   */
  export type ConferenceRanksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
    /**
     * The data needed to create a ConferenceRanks.
     */
    data: XOR<ConferenceRanksCreateInput, ConferenceRanksUncheckedCreateInput>
  }

  /**
   * ConferenceRanks createMany
   */
  export type ConferenceRanksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConferenceRanks.
     */
    data: ConferenceRanksCreateManyInput | ConferenceRanksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConferenceRanks createManyAndReturn
   */
  export type ConferenceRanksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * The data used to create many ConferenceRanks.
     */
    data: ConferenceRanksCreateManyInput | ConferenceRanksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceRanks update
   */
  export type ConferenceRanksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
    /**
     * The data needed to update a ConferenceRanks.
     */
    data: XOR<ConferenceRanksUpdateInput, ConferenceRanksUncheckedUpdateInput>
    /**
     * Choose, which ConferenceRanks to update.
     */
    where: ConferenceRanksWhereUniqueInput
  }

  /**
   * ConferenceRanks updateMany
   */
  export type ConferenceRanksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConferenceRanks.
     */
    data: XOR<ConferenceRanksUpdateManyMutationInput, ConferenceRanksUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceRanks to update
     */
    where?: ConferenceRanksWhereInput
    /**
     * Limit how many ConferenceRanks to update.
     */
    limit?: number
  }

  /**
   * ConferenceRanks updateManyAndReturn
   */
  export type ConferenceRanksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * The data used to update ConferenceRanks.
     */
    data: XOR<ConferenceRanksUpdateManyMutationInput, ConferenceRanksUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceRanks to update
     */
    where?: ConferenceRanksWhereInput
    /**
     * Limit how many ConferenceRanks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceRanks upsert
   */
  export type ConferenceRanksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
    /**
     * The filter to search for the ConferenceRanks to update in case it exists.
     */
    where: ConferenceRanksWhereUniqueInput
    /**
     * In case the ConferenceRanks found by the `where` argument doesn't exist, create a new ConferenceRanks with this data.
     */
    create: XOR<ConferenceRanksCreateInput, ConferenceRanksUncheckedCreateInput>
    /**
     * In case the ConferenceRanks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferenceRanksUpdateInput, ConferenceRanksUncheckedUpdateInput>
  }

  /**
   * ConferenceRanks delete
   */
  export type ConferenceRanksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
    /**
     * Filter which ConferenceRanks to delete.
     */
    where: ConferenceRanksWhereUniqueInput
  }

  /**
   * ConferenceRanks deleteMany
   */
  export type ConferenceRanksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceRanks to delete
     */
    where?: ConferenceRanksWhereInput
    /**
     * Limit how many ConferenceRanks to delete.
     */
    limit?: number
  }

  /**
   * ConferenceRanks without action
   */
  export type ConferenceRanksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
  }


  /**
   * Model ConferenceTopics
   */

  export type AggregateConferenceTopics = {
    _count: ConferenceTopicsCountAggregateOutputType | null
    _min: ConferenceTopicsMinAggregateOutputType | null
    _max: ConferenceTopicsMaxAggregateOutputType | null
  }

  export type ConferenceTopicsMinAggregateOutputType = {
    id: string | null
    organizeId: string | null
    topicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceTopicsMaxAggregateOutputType = {
    id: string | null
    organizeId: string | null
    topicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceTopicsCountAggregateOutputType = {
    id: number
    organizeId: number
    topicId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConferenceTopicsMinAggregateInputType = {
    id?: true
    organizeId?: true
    topicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceTopicsMaxAggregateInputType = {
    id?: true
    organizeId?: true
    topicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceTopicsCountAggregateInputType = {
    id?: true
    organizeId?: true
    topicId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConferenceTopicsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceTopics to aggregate.
     */
    where?: ConferenceTopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceTopics to fetch.
     */
    orderBy?: ConferenceTopicsOrderByWithRelationInput | ConferenceTopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferenceTopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConferenceTopics
    **/
    _count?: true | ConferenceTopicsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferenceTopicsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferenceTopicsMaxAggregateInputType
  }

  export type GetConferenceTopicsAggregateType<T extends ConferenceTopicsAggregateArgs> = {
        [P in keyof T & keyof AggregateConferenceTopics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferenceTopics[P]>
      : GetScalarType<T[P], AggregateConferenceTopics[P]>
  }




  export type ConferenceTopicsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceTopicsWhereInput
    orderBy?: ConferenceTopicsOrderByWithAggregationInput | ConferenceTopicsOrderByWithAggregationInput[]
    by: ConferenceTopicsScalarFieldEnum[] | ConferenceTopicsScalarFieldEnum
    having?: ConferenceTopicsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferenceTopicsCountAggregateInputType | true
    _min?: ConferenceTopicsMinAggregateInputType
    _max?: ConferenceTopicsMaxAggregateInputType
  }

  export type ConferenceTopicsGroupByOutputType = {
    id: string
    organizeId: string
    topicId: string
    createdAt: Date
    updatedAt: Date
    _count: ConferenceTopicsCountAggregateOutputType | null
    _min: ConferenceTopicsMinAggregateOutputType | null
    _max: ConferenceTopicsMaxAggregateOutputType | null
  }

  type GetConferenceTopicsGroupByPayload<T extends ConferenceTopicsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferenceTopicsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferenceTopicsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferenceTopicsGroupByOutputType[P]>
            : GetScalarType<T[P], ConferenceTopicsGroupByOutputType[P]>
        }
      >
    >


  export type ConferenceTopicsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizeId?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ConferenceOrganizations?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
    Topics?: boolean | TopicsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceTopics"]>

  export type ConferenceTopicsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizeId?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ConferenceOrganizations?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
    Topics?: boolean | TopicsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceTopics"]>

  export type ConferenceTopicsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizeId?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ConferenceOrganizations?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
    Topics?: boolean | TopicsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceTopics"]>

  export type ConferenceTopicsSelectScalar = {
    id?: boolean
    organizeId?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConferenceTopicsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizeId" | "topicId" | "createdAt" | "updatedAt", ExtArgs["result"]["conferenceTopics"]>
  export type ConferenceTopicsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConferenceOrganizations?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
    Topics?: boolean | TopicsDefaultArgs<ExtArgs>
  }
  export type ConferenceTopicsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConferenceOrganizations?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
    Topics?: boolean | TopicsDefaultArgs<ExtArgs>
  }
  export type ConferenceTopicsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConferenceOrganizations?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
    Topics?: boolean | TopicsDefaultArgs<ExtArgs>
  }

  export type $ConferenceTopicsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConferenceTopics"
    objects: {
      ConferenceOrganizations: Prisma.$ConferenceOrganizationsPayload<ExtArgs>
      Topics: Prisma.$TopicsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizeId: string
      topicId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conferenceTopics"]>
    composites: {}
  }

  type ConferenceTopicsGetPayload<S extends boolean | null | undefined | ConferenceTopicsDefaultArgs> = $Result.GetResult<Prisma.$ConferenceTopicsPayload, S>

  type ConferenceTopicsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferenceTopicsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferenceTopicsCountAggregateInputType | true
    }

  export interface ConferenceTopicsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConferenceTopics'], meta: { name: 'ConferenceTopics' } }
    /**
     * Find zero or one ConferenceTopics that matches the filter.
     * @param {ConferenceTopicsFindUniqueArgs} args - Arguments to find a ConferenceTopics
     * @example
     * // Get one ConferenceTopics
     * const conferenceTopics = await prisma.conferenceTopics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferenceTopicsFindUniqueArgs>(args: SelectSubset<T, ConferenceTopicsFindUniqueArgs<ExtArgs>>): Prisma__ConferenceTopicsClient<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConferenceTopics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferenceTopicsFindUniqueOrThrowArgs} args - Arguments to find a ConferenceTopics
     * @example
     * // Get one ConferenceTopics
     * const conferenceTopics = await prisma.conferenceTopics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferenceTopicsFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferenceTopicsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferenceTopicsClient<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceTopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceTopicsFindFirstArgs} args - Arguments to find a ConferenceTopics
     * @example
     * // Get one ConferenceTopics
     * const conferenceTopics = await prisma.conferenceTopics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferenceTopicsFindFirstArgs>(args?: SelectSubset<T, ConferenceTopicsFindFirstArgs<ExtArgs>>): Prisma__ConferenceTopicsClient<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceTopics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceTopicsFindFirstOrThrowArgs} args - Arguments to find a ConferenceTopics
     * @example
     * // Get one ConferenceTopics
     * const conferenceTopics = await prisma.conferenceTopics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferenceTopicsFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferenceTopicsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferenceTopicsClient<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConferenceTopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceTopicsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConferenceTopics
     * const conferenceTopics = await prisma.conferenceTopics.findMany()
     * 
     * // Get first 10 ConferenceTopics
     * const conferenceTopics = await prisma.conferenceTopics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferenceTopicsWithIdOnly = await prisma.conferenceTopics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferenceTopicsFindManyArgs>(args?: SelectSubset<T, ConferenceTopicsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConferenceTopics.
     * @param {ConferenceTopicsCreateArgs} args - Arguments to create a ConferenceTopics.
     * @example
     * // Create one ConferenceTopics
     * const ConferenceTopics = await prisma.conferenceTopics.create({
     *   data: {
     *     // ... data to create a ConferenceTopics
     *   }
     * })
     * 
     */
    create<T extends ConferenceTopicsCreateArgs>(args: SelectSubset<T, ConferenceTopicsCreateArgs<ExtArgs>>): Prisma__ConferenceTopicsClient<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConferenceTopics.
     * @param {ConferenceTopicsCreateManyArgs} args - Arguments to create many ConferenceTopics.
     * @example
     * // Create many ConferenceTopics
     * const conferenceTopics = await prisma.conferenceTopics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferenceTopicsCreateManyArgs>(args?: SelectSubset<T, ConferenceTopicsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConferenceTopics and returns the data saved in the database.
     * @param {ConferenceTopicsCreateManyAndReturnArgs} args - Arguments to create many ConferenceTopics.
     * @example
     * // Create many ConferenceTopics
     * const conferenceTopics = await prisma.conferenceTopics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConferenceTopics and only return the `id`
     * const conferenceTopicsWithIdOnly = await prisma.conferenceTopics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferenceTopicsCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferenceTopicsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConferenceTopics.
     * @param {ConferenceTopicsDeleteArgs} args - Arguments to delete one ConferenceTopics.
     * @example
     * // Delete one ConferenceTopics
     * const ConferenceTopics = await prisma.conferenceTopics.delete({
     *   where: {
     *     // ... filter to delete one ConferenceTopics
     *   }
     * })
     * 
     */
    delete<T extends ConferenceTopicsDeleteArgs>(args: SelectSubset<T, ConferenceTopicsDeleteArgs<ExtArgs>>): Prisma__ConferenceTopicsClient<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConferenceTopics.
     * @param {ConferenceTopicsUpdateArgs} args - Arguments to update one ConferenceTopics.
     * @example
     * // Update one ConferenceTopics
     * const conferenceTopics = await prisma.conferenceTopics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferenceTopicsUpdateArgs>(args: SelectSubset<T, ConferenceTopicsUpdateArgs<ExtArgs>>): Prisma__ConferenceTopicsClient<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConferenceTopics.
     * @param {ConferenceTopicsDeleteManyArgs} args - Arguments to filter ConferenceTopics to delete.
     * @example
     * // Delete a few ConferenceTopics
     * const { count } = await prisma.conferenceTopics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferenceTopicsDeleteManyArgs>(args?: SelectSubset<T, ConferenceTopicsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceTopicsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConferenceTopics
     * const conferenceTopics = await prisma.conferenceTopics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferenceTopicsUpdateManyArgs>(args: SelectSubset<T, ConferenceTopicsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceTopics and returns the data updated in the database.
     * @param {ConferenceTopicsUpdateManyAndReturnArgs} args - Arguments to update many ConferenceTopics.
     * @example
     * // Update many ConferenceTopics
     * const conferenceTopics = await prisma.conferenceTopics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConferenceTopics and only return the `id`
     * const conferenceTopicsWithIdOnly = await prisma.conferenceTopics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferenceTopicsUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferenceTopicsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConferenceTopics.
     * @param {ConferenceTopicsUpsertArgs} args - Arguments to update or create a ConferenceTopics.
     * @example
     * // Update or create a ConferenceTopics
     * const conferenceTopics = await prisma.conferenceTopics.upsert({
     *   create: {
     *     // ... data to create a ConferenceTopics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConferenceTopics we want to update
     *   }
     * })
     */
    upsert<T extends ConferenceTopicsUpsertArgs>(args: SelectSubset<T, ConferenceTopicsUpsertArgs<ExtArgs>>): Prisma__ConferenceTopicsClient<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConferenceTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceTopicsCountArgs} args - Arguments to filter ConferenceTopics to count.
     * @example
     * // Count the number of ConferenceTopics
     * const count = await prisma.conferenceTopics.count({
     *   where: {
     *     // ... the filter for the ConferenceTopics we want to count
     *   }
     * })
    **/
    count<T extends ConferenceTopicsCountArgs>(
      args?: Subset<T, ConferenceTopicsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferenceTopicsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConferenceTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceTopicsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferenceTopicsAggregateArgs>(args: Subset<T, ConferenceTopicsAggregateArgs>): Prisma.PrismaPromise<GetConferenceTopicsAggregateType<T>>

    /**
     * Group by ConferenceTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceTopicsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferenceTopicsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferenceTopicsGroupByArgs['orderBy'] }
        : { orderBy?: ConferenceTopicsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferenceTopicsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferenceTopicsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConferenceTopics model
   */
  readonly fields: ConferenceTopicsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConferenceTopics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferenceTopicsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ConferenceOrganizations<T extends ConferenceOrganizationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferenceOrganizationsDefaultArgs<ExtArgs>>): Prisma__ConferenceOrganizationsClient<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Topics<T extends TopicsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TopicsDefaultArgs<ExtArgs>>): Prisma__TopicsClient<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConferenceTopics model
   */ 
  interface ConferenceTopicsFieldRefs {
    readonly id: FieldRef<"ConferenceTopics", 'String'>
    readonly organizeId: FieldRef<"ConferenceTopics", 'String'>
    readonly topicId: FieldRef<"ConferenceTopics", 'String'>
    readonly createdAt: FieldRef<"ConferenceTopics", 'DateTime'>
    readonly updatedAt: FieldRef<"ConferenceTopics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConferenceTopics findUnique
   */
  export type ConferenceTopicsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceTopics to fetch.
     */
    where: ConferenceTopicsWhereUniqueInput
  }

  /**
   * ConferenceTopics findUniqueOrThrow
   */
  export type ConferenceTopicsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceTopics to fetch.
     */
    where: ConferenceTopicsWhereUniqueInput
  }

  /**
   * ConferenceTopics findFirst
   */
  export type ConferenceTopicsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceTopics to fetch.
     */
    where?: ConferenceTopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceTopics to fetch.
     */
    orderBy?: ConferenceTopicsOrderByWithRelationInput | ConferenceTopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceTopics.
     */
    cursor?: ConferenceTopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceTopics.
     */
    distinct?: ConferenceTopicsScalarFieldEnum | ConferenceTopicsScalarFieldEnum[]
  }

  /**
   * ConferenceTopics findFirstOrThrow
   */
  export type ConferenceTopicsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceTopics to fetch.
     */
    where?: ConferenceTopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceTopics to fetch.
     */
    orderBy?: ConferenceTopicsOrderByWithRelationInput | ConferenceTopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceTopics.
     */
    cursor?: ConferenceTopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceTopics.
     */
    distinct?: ConferenceTopicsScalarFieldEnum | ConferenceTopicsScalarFieldEnum[]
  }

  /**
   * ConferenceTopics findMany
   */
  export type ConferenceTopicsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceTopics to fetch.
     */
    where?: ConferenceTopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceTopics to fetch.
     */
    orderBy?: ConferenceTopicsOrderByWithRelationInput | ConferenceTopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConferenceTopics.
     */
    cursor?: ConferenceTopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceTopics.
     */
    skip?: number
    distinct?: ConferenceTopicsScalarFieldEnum | ConferenceTopicsScalarFieldEnum[]
  }

  /**
   * ConferenceTopics create
   */
  export type ConferenceTopicsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsInclude<ExtArgs> | null
    /**
     * The data needed to create a ConferenceTopics.
     */
    data: XOR<ConferenceTopicsCreateInput, ConferenceTopicsUncheckedCreateInput>
  }

  /**
   * ConferenceTopics createMany
   */
  export type ConferenceTopicsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConferenceTopics.
     */
    data: ConferenceTopicsCreateManyInput | ConferenceTopicsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConferenceTopics createManyAndReturn
   */
  export type ConferenceTopicsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * The data used to create many ConferenceTopics.
     */
    data: ConferenceTopicsCreateManyInput | ConferenceTopicsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceTopics update
   */
  export type ConferenceTopicsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsInclude<ExtArgs> | null
    /**
     * The data needed to update a ConferenceTopics.
     */
    data: XOR<ConferenceTopicsUpdateInput, ConferenceTopicsUncheckedUpdateInput>
    /**
     * Choose, which ConferenceTopics to update.
     */
    where: ConferenceTopicsWhereUniqueInput
  }

  /**
   * ConferenceTopics updateMany
   */
  export type ConferenceTopicsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConferenceTopics.
     */
    data: XOR<ConferenceTopicsUpdateManyMutationInput, ConferenceTopicsUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceTopics to update
     */
    where?: ConferenceTopicsWhereInput
    /**
     * Limit how many ConferenceTopics to update.
     */
    limit?: number
  }

  /**
   * ConferenceTopics updateManyAndReturn
   */
  export type ConferenceTopicsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * The data used to update ConferenceTopics.
     */
    data: XOR<ConferenceTopicsUpdateManyMutationInput, ConferenceTopicsUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceTopics to update
     */
    where?: ConferenceTopicsWhereInput
    /**
     * Limit how many ConferenceTopics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceTopics upsert
   */
  export type ConferenceTopicsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsInclude<ExtArgs> | null
    /**
     * The filter to search for the ConferenceTopics to update in case it exists.
     */
    where: ConferenceTopicsWhereUniqueInput
    /**
     * In case the ConferenceTopics found by the `where` argument doesn't exist, create a new ConferenceTopics with this data.
     */
    create: XOR<ConferenceTopicsCreateInput, ConferenceTopicsUncheckedCreateInput>
    /**
     * In case the ConferenceTopics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferenceTopicsUpdateInput, ConferenceTopicsUncheckedUpdateInput>
  }

  /**
   * ConferenceTopics delete
   */
  export type ConferenceTopicsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsInclude<ExtArgs> | null
    /**
     * Filter which ConferenceTopics to delete.
     */
    where: ConferenceTopicsWhereUniqueInput
  }

  /**
   * ConferenceTopics deleteMany
   */
  export type ConferenceTopicsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceTopics to delete
     */
    where?: ConferenceTopicsWhereInput
    /**
     * Limit how many ConferenceTopics to delete.
     */
    limit?: number
  }

  /**
   * ConferenceTopics without action
   */
  export type ConferenceTopicsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsInclude<ExtArgs> | null
  }


  /**
   * Model Conferences
   */

  export type AggregateConferences = {
    _count: ConferencesCountAggregateOutputType | null
    _min: ConferencesMinAggregateOutputType | null
    _max: ConferencesMaxAggregateOutputType | null
  }

  export type ConferencesMinAggregateOutputType = {
    id: string | null
    title: string | null
    acronym: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
    adminId: string | null
  }

  export type ConferencesMaxAggregateOutputType = {
    id: string | null
    title: string | null
    acronym: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
    adminId: string | null
  }

  export type ConferencesCountAggregateOutputType = {
    id: number
    title: number
    acronym: number
    creatorId: number
    createdAt: number
    updatedAt: number
    status: number
    adminId: number
    _all: number
  }


  export type ConferencesMinAggregateInputType = {
    id?: true
    title?: true
    acronym?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    adminId?: true
  }

  export type ConferencesMaxAggregateInputType = {
    id?: true
    title?: true
    acronym?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    adminId?: true
  }

  export type ConferencesCountAggregateInputType = {
    id?: true
    title?: true
    acronym?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    adminId?: true
    _all?: true
  }

  export type ConferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conferences to aggregate.
     */
    where?: ConferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conferences to fetch.
     */
    orderBy?: ConferencesOrderByWithRelationInput | ConferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conferences
    **/
    _count?: true | ConferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferencesMaxAggregateInputType
  }

  export type GetConferencesAggregateType<T extends ConferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateConferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferences[P]>
      : GetScalarType<T[P], AggregateConferences[P]>
  }




  export type ConferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferencesWhereInput
    orderBy?: ConferencesOrderByWithAggregationInput | ConferencesOrderByWithAggregationInput[]
    by: ConferencesScalarFieldEnum[] | ConferencesScalarFieldEnum
    having?: ConferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferencesCountAggregateInputType | true
    _min?: ConferencesMinAggregateInputType
    _max?: ConferencesMaxAggregateInputType
  }

  export type ConferencesGroupByOutputType = {
    id: string
    title: string
    acronym: string
    creatorId: string | null
    createdAt: Date
    updatedAt: Date
    status: string
    adminId: string | null
    _count: ConferencesCountAggregateOutputType | null
    _min: ConferencesMinAggregateOutputType | null
    _max: ConferencesMaxAggregateOutputType | null
  }

  type GetConferencesGroupByPayload<T extends ConferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferencesGroupByOutputType[P]>
            : GetScalarType<T[P], ConferencesGroupByOutputType[P]>
        }
      >
    >


  export type ConferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    acronym?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    adminId?: boolean
    ConferenceBlacklists?: boolean | Conferences$ConferenceBlacklistsArgs<ExtArgs>
    ConferenceCalendars?: boolean | Conferences$ConferenceCalendarsArgs<ExtArgs>
    ConferenceCrawlJobs?: boolean | Conferences$ConferenceCrawlJobsArgs<ExtArgs>
    ConferenceFeedbacks?: boolean | Conferences$ConferenceFeedbacksArgs<ExtArgs>
    ConferenceFollows?: boolean | Conferences$ConferenceFollowsArgs<ExtArgs>
    ConferenceLikes?: boolean | Conferences$ConferenceLikesArgs<ExtArgs>
    ConferenceOrganizations?: boolean | Conferences$ConferenceOrganizationsArgs<ExtArgs>
    ConferenceRanks?: boolean | Conferences$ConferenceRanksArgs<ExtArgs>
    Admins?: boolean | Conferences$AdminsArgs<ExtArgs>
    Users?: boolean | Conferences$UsersArgs<ExtArgs>
    _count?: boolean | ConferencesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferences"]>

  export type ConferencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    acronym?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    adminId?: boolean
    Admins?: boolean | Conferences$AdminsArgs<ExtArgs>
    Users?: boolean | Conferences$UsersArgs<ExtArgs>
  }, ExtArgs["result"]["conferences"]>

  export type ConferencesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    acronym?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    adminId?: boolean
    Admins?: boolean | Conferences$AdminsArgs<ExtArgs>
    Users?: boolean | Conferences$UsersArgs<ExtArgs>
  }, ExtArgs["result"]["conferences"]>

  export type ConferencesSelectScalar = {
    id?: boolean
    title?: boolean
    acronym?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    adminId?: boolean
  }

  export type ConferencesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "acronym" | "creatorId" | "createdAt" | "updatedAt" | "status" | "adminId", ExtArgs["result"]["conferences"]>
  export type ConferencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConferenceBlacklists?: boolean | Conferences$ConferenceBlacklistsArgs<ExtArgs>
    ConferenceCalendars?: boolean | Conferences$ConferenceCalendarsArgs<ExtArgs>
    ConferenceCrawlJobs?: boolean | Conferences$ConferenceCrawlJobsArgs<ExtArgs>
    ConferenceFeedbacks?: boolean | Conferences$ConferenceFeedbacksArgs<ExtArgs>
    ConferenceFollows?: boolean | Conferences$ConferenceFollowsArgs<ExtArgs>
    ConferenceLikes?: boolean | Conferences$ConferenceLikesArgs<ExtArgs>
    ConferenceOrganizations?: boolean | Conferences$ConferenceOrganizationsArgs<ExtArgs>
    ConferenceRanks?: boolean | Conferences$ConferenceRanksArgs<ExtArgs>
    Admins?: boolean | Conferences$AdminsArgs<ExtArgs>
    Users?: boolean | Conferences$UsersArgs<ExtArgs>
    _count?: boolean | ConferencesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConferencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Admins?: boolean | Conferences$AdminsArgs<ExtArgs>
    Users?: boolean | Conferences$UsersArgs<ExtArgs>
  }
  export type ConferencesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Admins?: boolean | Conferences$AdminsArgs<ExtArgs>
    Users?: boolean | Conferences$UsersArgs<ExtArgs>
  }

  export type $ConferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conferences"
    objects: {
      ConferenceBlacklists: Prisma.$ConferenceBlacklistsPayload<ExtArgs>[]
      ConferenceCalendars: Prisma.$ConferenceCalendarsPayload<ExtArgs>[]
      ConferenceCrawlJobs: Prisma.$ConferenceCrawlJobsPayload<ExtArgs>[]
      ConferenceFeedbacks: Prisma.$ConferenceFeedbacksPayload<ExtArgs>[]
      ConferenceFollows: Prisma.$ConferenceFollowsPayload<ExtArgs>[]
      ConferenceLikes: Prisma.$ConferenceLikesPayload<ExtArgs>[]
      ConferenceOrganizations: Prisma.$ConferenceOrganizationsPayload<ExtArgs>[]
      ConferenceRanks: Prisma.$ConferenceRanksPayload<ExtArgs>[]
      Admins: Prisma.$AdminsPayload<ExtArgs> | null
      Users: Prisma.$UsersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      acronym: string
      creatorId: string | null
      createdAt: Date
      updatedAt: Date
      status: string
      adminId: string | null
    }, ExtArgs["result"]["conferences"]>
    composites: {}
  }

  type ConferencesGetPayload<S extends boolean | null | undefined | ConferencesDefaultArgs> = $Result.GetResult<Prisma.$ConferencesPayload, S>

  type ConferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferencesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferencesCountAggregateInputType | true
    }

  export interface ConferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conferences'], meta: { name: 'Conferences' } }
    /**
     * Find zero or one Conferences that matches the filter.
     * @param {ConferencesFindUniqueArgs} args - Arguments to find a Conferences
     * @example
     * // Get one Conferences
     * const conferences = await prisma.conferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferencesFindUniqueArgs>(args: SelectSubset<T, ConferencesFindUniqueArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conferences that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferencesFindUniqueOrThrowArgs} args - Arguments to find a Conferences
     * @example
     * // Get one Conferences
     * const conferences = await prisma.conferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferencesFindFirstArgs} args - Arguments to find a Conferences
     * @example
     * // Get one Conferences
     * const conferences = await prisma.conferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferencesFindFirstArgs>(args?: SelectSubset<T, ConferencesFindFirstArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferencesFindFirstOrThrowArgs} args - Arguments to find a Conferences
     * @example
     * // Get one Conferences
     * const conferences = await prisma.conferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conferences
     * const conferences = await prisma.conferences.findMany()
     * 
     * // Get first 10 Conferences
     * const conferences = await prisma.conferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferencesWithIdOnly = await prisma.conferences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferencesFindManyArgs>(args?: SelectSubset<T, ConferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conferences.
     * @param {ConferencesCreateArgs} args - Arguments to create a Conferences.
     * @example
     * // Create one Conferences
     * const Conferences = await prisma.conferences.create({
     *   data: {
     *     // ... data to create a Conferences
     *   }
     * })
     * 
     */
    create<T extends ConferencesCreateArgs>(args: SelectSubset<T, ConferencesCreateArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conferences.
     * @param {ConferencesCreateManyArgs} args - Arguments to create many Conferences.
     * @example
     * // Create many Conferences
     * const conferences = await prisma.conferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferencesCreateManyArgs>(args?: SelectSubset<T, ConferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conferences and returns the data saved in the database.
     * @param {ConferencesCreateManyAndReturnArgs} args - Arguments to create many Conferences.
     * @example
     * // Create many Conferences
     * const conferences = await prisma.conferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conferences and only return the `id`
     * const conferencesWithIdOnly = await prisma.conferences.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferencesCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conferences.
     * @param {ConferencesDeleteArgs} args - Arguments to delete one Conferences.
     * @example
     * // Delete one Conferences
     * const Conferences = await prisma.conferences.delete({
     *   where: {
     *     // ... filter to delete one Conferences
     *   }
     * })
     * 
     */
    delete<T extends ConferencesDeleteArgs>(args: SelectSubset<T, ConferencesDeleteArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conferences.
     * @param {ConferencesUpdateArgs} args - Arguments to update one Conferences.
     * @example
     * // Update one Conferences
     * const conferences = await prisma.conferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferencesUpdateArgs>(args: SelectSubset<T, ConferencesUpdateArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conferences.
     * @param {ConferencesDeleteManyArgs} args - Arguments to filter Conferences to delete.
     * @example
     * // Delete a few Conferences
     * const { count } = await prisma.conferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferencesDeleteManyArgs>(args?: SelectSubset<T, ConferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conferences
     * const conferences = await prisma.conferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferencesUpdateManyArgs>(args: SelectSubset<T, ConferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conferences and returns the data updated in the database.
     * @param {ConferencesUpdateManyAndReturnArgs} args - Arguments to update many Conferences.
     * @example
     * // Update many Conferences
     * const conferences = await prisma.conferences.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conferences and only return the `id`
     * const conferencesWithIdOnly = await prisma.conferences.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferencesUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferencesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conferences.
     * @param {ConferencesUpsertArgs} args - Arguments to update or create a Conferences.
     * @example
     * // Update or create a Conferences
     * const conferences = await prisma.conferences.upsert({
     *   create: {
     *     // ... data to create a Conferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conferences we want to update
     *   }
     * })
     */
    upsert<T extends ConferencesUpsertArgs>(args: SelectSubset<T, ConferencesUpsertArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferencesCountArgs} args - Arguments to filter Conferences to count.
     * @example
     * // Count the number of Conferences
     * const count = await prisma.conferences.count({
     *   where: {
     *     // ... the filter for the Conferences we want to count
     *   }
     * })
    **/
    count<T extends ConferencesCountArgs>(
      args?: Subset<T, ConferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferencesAggregateArgs>(args: Subset<T, ConferencesAggregateArgs>): Prisma.PrismaPromise<GetConferencesAggregateType<T>>

    /**
     * Group by Conferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferencesGroupByArgs['orderBy'] }
        : { orderBy?: ConferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conferences model
   */
  readonly fields: ConferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ConferenceBlacklists<T extends Conferences$ConferenceBlacklistsArgs<ExtArgs> = {}>(args?: Subset<T, Conferences$ConferenceBlacklistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceBlacklistsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ConferenceCalendars<T extends Conferences$ConferenceCalendarsArgs<ExtArgs> = {}>(args?: Subset<T, Conferences$ConferenceCalendarsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ConferenceCrawlJobs<T extends Conferences$ConferenceCrawlJobsArgs<ExtArgs> = {}>(args?: Subset<T, Conferences$ConferenceCrawlJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceCrawlJobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ConferenceFeedbacks<T extends Conferences$ConferenceFeedbacksArgs<ExtArgs> = {}>(args?: Subset<T, Conferences$ConferenceFeedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ConferenceFollows<T extends Conferences$ConferenceFollowsArgs<ExtArgs> = {}>(args?: Subset<T, Conferences$ConferenceFollowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ConferenceLikes<T extends Conferences$ConferenceLikesArgs<ExtArgs> = {}>(args?: Subset<T, Conferences$ConferenceLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ConferenceOrganizations<T extends Conferences$ConferenceOrganizationsArgs<ExtArgs> = {}>(args?: Subset<T, Conferences$ConferenceOrganizationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ConferenceRanks<T extends Conferences$ConferenceRanksArgs<ExtArgs> = {}>(args?: Subset<T, Conferences$ConferenceRanksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Admins<T extends Conferences$AdminsArgs<ExtArgs> = {}>(args?: Subset<T, Conferences$AdminsArgs<ExtArgs>>): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Users<T extends Conferences$UsersArgs<ExtArgs> = {}>(args?: Subset<T, Conferences$UsersArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conferences model
   */ 
  interface ConferencesFieldRefs {
    readonly id: FieldRef<"Conferences", 'String'>
    readonly title: FieldRef<"Conferences", 'String'>
    readonly acronym: FieldRef<"Conferences", 'String'>
    readonly creatorId: FieldRef<"Conferences", 'String'>
    readonly createdAt: FieldRef<"Conferences", 'DateTime'>
    readonly updatedAt: FieldRef<"Conferences", 'DateTime'>
    readonly status: FieldRef<"Conferences", 'String'>
    readonly adminId: FieldRef<"Conferences", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Conferences findUnique
   */
  export type ConferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesInclude<ExtArgs> | null
    /**
     * Filter, which Conferences to fetch.
     */
    where: ConferencesWhereUniqueInput
  }

  /**
   * Conferences findUniqueOrThrow
   */
  export type ConferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesInclude<ExtArgs> | null
    /**
     * Filter, which Conferences to fetch.
     */
    where: ConferencesWhereUniqueInput
  }

  /**
   * Conferences findFirst
   */
  export type ConferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesInclude<ExtArgs> | null
    /**
     * Filter, which Conferences to fetch.
     */
    where?: ConferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conferences to fetch.
     */
    orderBy?: ConferencesOrderByWithRelationInput | ConferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conferences.
     */
    cursor?: ConferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conferences.
     */
    distinct?: ConferencesScalarFieldEnum | ConferencesScalarFieldEnum[]
  }

  /**
   * Conferences findFirstOrThrow
   */
  export type ConferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesInclude<ExtArgs> | null
    /**
     * Filter, which Conferences to fetch.
     */
    where?: ConferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conferences to fetch.
     */
    orderBy?: ConferencesOrderByWithRelationInput | ConferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conferences.
     */
    cursor?: ConferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conferences.
     */
    distinct?: ConferencesScalarFieldEnum | ConferencesScalarFieldEnum[]
  }

  /**
   * Conferences findMany
   */
  export type ConferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesInclude<ExtArgs> | null
    /**
     * Filter, which Conferences to fetch.
     */
    where?: ConferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conferences to fetch.
     */
    orderBy?: ConferencesOrderByWithRelationInput | ConferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conferences.
     */
    cursor?: ConferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conferences.
     */
    skip?: number
    distinct?: ConferencesScalarFieldEnum | ConferencesScalarFieldEnum[]
  }

  /**
   * Conferences create
   */
  export type ConferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a Conferences.
     */
    data: XOR<ConferencesCreateInput, ConferencesUncheckedCreateInput>
  }

  /**
   * Conferences createMany
   */
  export type ConferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conferences.
     */
    data: ConferencesCreateManyInput | ConferencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conferences createManyAndReturn
   */
  export type ConferencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * The data used to create many Conferences.
     */
    data: ConferencesCreateManyInput | ConferencesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conferences update
   */
  export type ConferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a Conferences.
     */
    data: XOR<ConferencesUpdateInput, ConferencesUncheckedUpdateInput>
    /**
     * Choose, which Conferences to update.
     */
    where: ConferencesWhereUniqueInput
  }

  /**
   * Conferences updateMany
   */
  export type ConferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conferences.
     */
    data: XOR<ConferencesUpdateManyMutationInput, ConferencesUncheckedUpdateManyInput>
    /**
     * Filter which Conferences to update
     */
    where?: ConferencesWhereInput
    /**
     * Limit how many Conferences to update.
     */
    limit?: number
  }

  /**
   * Conferences updateManyAndReturn
   */
  export type ConferencesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * The data used to update Conferences.
     */
    data: XOR<ConferencesUpdateManyMutationInput, ConferencesUncheckedUpdateManyInput>
    /**
     * Filter which Conferences to update
     */
    where?: ConferencesWhereInput
    /**
     * Limit how many Conferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conferences upsert
   */
  export type ConferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the Conferences to update in case it exists.
     */
    where: ConferencesWhereUniqueInput
    /**
     * In case the Conferences found by the `where` argument doesn't exist, create a new Conferences with this data.
     */
    create: XOR<ConferencesCreateInput, ConferencesUncheckedCreateInput>
    /**
     * In case the Conferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferencesUpdateInput, ConferencesUncheckedUpdateInput>
  }

  /**
   * Conferences delete
   */
  export type ConferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesInclude<ExtArgs> | null
    /**
     * Filter which Conferences to delete.
     */
    where: ConferencesWhereUniqueInput
  }

  /**
   * Conferences deleteMany
   */
  export type ConferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conferences to delete
     */
    where?: ConferencesWhereInput
    /**
     * Limit how many Conferences to delete.
     */
    limit?: number
  }

  /**
   * Conferences.ConferenceBlacklists
   */
  export type Conferences$ConferenceBlacklistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceBlacklists
     */
    select?: ConferenceBlacklistsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceBlacklists
     */
    omit?: ConferenceBlacklistsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceBlacklistsInclude<ExtArgs> | null
    where?: ConferenceBlacklistsWhereInput
    orderBy?: ConferenceBlacklistsOrderByWithRelationInput | ConferenceBlacklistsOrderByWithRelationInput[]
    cursor?: ConferenceBlacklistsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceBlacklistsScalarFieldEnum | ConferenceBlacklistsScalarFieldEnum[]
  }

  /**
   * Conferences.ConferenceCalendars
   */
  export type Conferences$ConferenceCalendarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsInclude<ExtArgs> | null
    where?: ConferenceCalendarsWhereInput
    orderBy?: ConferenceCalendarsOrderByWithRelationInput | ConferenceCalendarsOrderByWithRelationInput[]
    cursor?: ConferenceCalendarsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceCalendarsScalarFieldEnum | ConferenceCalendarsScalarFieldEnum[]
  }

  /**
   * Conferences.ConferenceCrawlJobs
   */
  export type Conferences$ConferenceCrawlJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsInclude<ExtArgs> | null
    where?: ConferenceCrawlJobsWhereInput
    orderBy?: ConferenceCrawlJobsOrderByWithRelationInput | ConferenceCrawlJobsOrderByWithRelationInput[]
    cursor?: ConferenceCrawlJobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceCrawlJobsScalarFieldEnum | ConferenceCrawlJobsScalarFieldEnum[]
  }

  /**
   * Conferences.ConferenceFeedbacks
   */
  export type Conferences$ConferenceFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksInclude<ExtArgs> | null
    where?: ConferenceFeedbacksWhereInput
    orderBy?: ConferenceFeedbacksOrderByWithRelationInput | ConferenceFeedbacksOrderByWithRelationInput[]
    cursor?: ConferenceFeedbacksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceFeedbacksScalarFieldEnum | ConferenceFeedbacksScalarFieldEnum[]
  }

  /**
   * Conferences.ConferenceFollows
   */
  export type Conferences$ConferenceFollowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsInclude<ExtArgs> | null
    where?: ConferenceFollowsWhereInput
    orderBy?: ConferenceFollowsOrderByWithRelationInput | ConferenceFollowsOrderByWithRelationInput[]
    cursor?: ConferenceFollowsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceFollowsScalarFieldEnum | ConferenceFollowsScalarFieldEnum[]
  }

  /**
   * Conferences.ConferenceLikes
   */
  export type Conferences$ConferenceLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesInclude<ExtArgs> | null
    where?: ConferenceLikesWhereInput
    orderBy?: ConferenceLikesOrderByWithRelationInput | ConferenceLikesOrderByWithRelationInput[]
    cursor?: ConferenceLikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceLikesScalarFieldEnum | ConferenceLikesScalarFieldEnum[]
  }

  /**
   * Conferences.ConferenceOrganizations
   */
  export type Conferences$ConferenceOrganizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsInclude<ExtArgs> | null
    where?: ConferenceOrganizationsWhereInput
    orderBy?: ConferenceOrganizationsOrderByWithRelationInput | ConferenceOrganizationsOrderByWithRelationInput[]
    cursor?: ConferenceOrganizationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceOrganizationsScalarFieldEnum | ConferenceOrganizationsScalarFieldEnum[]
  }

  /**
   * Conferences.ConferenceRanks
   */
  export type Conferences$ConferenceRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
    where?: ConferenceRanksWhereInput
    orderBy?: ConferenceRanksOrderByWithRelationInput | ConferenceRanksOrderByWithRelationInput[]
    cursor?: ConferenceRanksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceRanksScalarFieldEnum | ConferenceRanksScalarFieldEnum[]
  }

  /**
   * Conferences.Admins
   */
  export type Conferences$AdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admins
     */
    omit?: AdminsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    where?: AdminsWhereInput
  }

  /**
   * Conferences.Users
   */
  export type Conferences$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
  }

  /**
   * Conferences without action
   */
  export type ConferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesInclude<ExtArgs> | null
  }


  /**
   * Model FieldOfResearchs
   */

  export type AggregateFieldOfResearchs = {
    _count: FieldOfResearchsCountAggregateOutputType | null
    _min: FieldOfResearchsMinAggregateOutputType | null
    _max: FieldOfResearchsMaxAggregateOutputType | null
  }

  export type FieldOfResearchsMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
  }

  export type FieldOfResearchsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
  }

  export type FieldOfResearchsCountAggregateOutputType = {
    id: number
    name: number
    code: number
    _all: number
  }


  export type FieldOfResearchsMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
  }

  export type FieldOfResearchsMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
  }

  export type FieldOfResearchsCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    _all?: true
  }

  export type FieldOfResearchsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FieldOfResearchs to aggregate.
     */
    where?: FieldOfResearchsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldOfResearchs to fetch.
     */
    orderBy?: FieldOfResearchsOrderByWithRelationInput | FieldOfResearchsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FieldOfResearchsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldOfResearchs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldOfResearchs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FieldOfResearchs
    **/
    _count?: true | FieldOfResearchsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FieldOfResearchsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FieldOfResearchsMaxAggregateInputType
  }

  export type GetFieldOfResearchsAggregateType<T extends FieldOfResearchsAggregateArgs> = {
        [P in keyof T & keyof AggregateFieldOfResearchs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFieldOfResearchs[P]>
      : GetScalarType<T[P], AggregateFieldOfResearchs[P]>
  }




  export type FieldOfResearchsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldOfResearchsWhereInput
    orderBy?: FieldOfResearchsOrderByWithAggregationInput | FieldOfResearchsOrderByWithAggregationInput[]
    by: FieldOfResearchsScalarFieldEnum[] | FieldOfResearchsScalarFieldEnum
    having?: FieldOfResearchsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FieldOfResearchsCountAggregateInputType | true
    _min?: FieldOfResearchsMinAggregateInputType
    _max?: FieldOfResearchsMaxAggregateInputType
  }

  export type FieldOfResearchsGroupByOutputType = {
    id: string
    name: string
    code: string
    _count: FieldOfResearchsCountAggregateOutputType | null
    _min: FieldOfResearchsMinAggregateOutputType | null
    _max: FieldOfResearchsMaxAggregateOutputType | null
  }

  type GetFieldOfResearchsGroupByPayload<T extends FieldOfResearchsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FieldOfResearchsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FieldOfResearchsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FieldOfResearchsGroupByOutputType[P]>
            : GetScalarType<T[P], FieldOfResearchsGroupByOutputType[P]>
        }
      >
    >


  export type FieldOfResearchsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    ConferenceRanks?: boolean | FieldOfResearchs$ConferenceRanksArgs<ExtArgs>
    JournalRanks?: boolean | FieldOfResearchs$JournalRanksArgs<ExtArgs>
    _count?: boolean | FieldOfResearchsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fieldOfResearchs"]>

  export type FieldOfResearchsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
  }, ExtArgs["result"]["fieldOfResearchs"]>

  export type FieldOfResearchsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
  }, ExtArgs["result"]["fieldOfResearchs"]>

  export type FieldOfResearchsSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
  }

  export type FieldOfResearchsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code", ExtArgs["result"]["fieldOfResearchs"]>
  export type FieldOfResearchsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConferenceRanks?: boolean | FieldOfResearchs$ConferenceRanksArgs<ExtArgs>
    JournalRanks?: boolean | FieldOfResearchs$JournalRanksArgs<ExtArgs>
    _count?: boolean | FieldOfResearchsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FieldOfResearchsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FieldOfResearchsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FieldOfResearchsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FieldOfResearchs"
    objects: {
      ConferenceRanks: Prisma.$ConferenceRanksPayload<ExtArgs>[]
      JournalRanks: Prisma.$JournalRanksPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
    }, ExtArgs["result"]["fieldOfResearchs"]>
    composites: {}
  }

  type FieldOfResearchsGetPayload<S extends boolean | null | undefined | FieldOfResearchsDefaultArgs> = $Result.GetResult<Prisma.$FieldOfResearchsPayload, S>

  type FieldOfResearchsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FieldOfResearchsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FieldOfResearchsCountAggregateInputType | true
    }

  export interface FieldOfResearchsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FieldOfResearchs'], meta: { name: 'FieldOfResearchs' } }
    /**
     * Find zero or one FieldOfResearchs that matches the filter.
     * @param {FieldOfResearchsFindUniqueArgs} args - Arguments to find a FieldOfResearchs
     * @example
     * // Get one FieldOfResearchs
     * const fieldOfResearchs = await prisma.fieldOfResearchs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FieldOfResearchsFindUniqueArgs>(args: SelectSubset<T, FieldOfResearchsFindUniqueArgs<ExtArgs>>): Prisma__FieldOfResearchsClient<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FieldOfResearchs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FieldOfResearchsFindUniqueOrThrowArgs} args - Arguments to find a FieldOfResearchs
     * @example
     * // Get one FieldOfResearchs
     * const fieldOfResearchs = await prisma.fieldOfResearchs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FieldOfResearchsFindUniqueOrThrowArgs>(args: SelectSubset<T, FieldOfResearchsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FieldOfResearchsClient<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FieldOfResearchs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOfResearchsFindFirstArgs} args - Arguments to find a FieldOfResearchs
     * @example
     * // Get one FieldOfResearchs
     * const fieldOfResearchs = await prisma.fieldOfResearchs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FieldOfResearchsFindFirstArgs>(args?: SelectSubset<T, FieldOfResearchsFindFirstArgs<ExtArgs>>): Prisma__FieldOfResearchsClient<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FieldOfResearchs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOfResearchsFindFirstOrThrowArgs} args - Arguments to find a FieldOfResearchs
     * @example
     * // Get one FieldOfResearchs
     * const fieldOfResearchs = await prisma.fieldOfResearchs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FieldOfResearchsFindFirstOrThrowArgs>(args?: SelectSubset<T, FieldOfResearchsFindFirstOrThrowArgs<ExtArgs>>): Prisma__FieldOfResearchsClient<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FieldOfResearchs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOfResearchsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FieldOfResearchs
     * const fieldOfResearchs = await prisma.fieldOfResearchs.findMany()
     * 
     * // Get first 10 FieldOfResearchs
     * const fieldOfResearchs = await prisma.fieldOfResearchs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fieldOfResearchsWithIdOnly = await prisma.fieldOfResearchs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FieldOfResearchsFindManyArgs>(args?: SelectSubset<T, FieldOfResearchsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FieldOfResearchs.
     * @param {FieldOfResearchsCreateArgs} args - Arguments to create a FieldOfResearchs.
     * @example
     * // Create one FieldOfResearchs
     * const FieldOfResearchs = await prisma.fieldOfResearchs.create({
     *   data: {
     *     // ... data to create a FieldOfResearchs
     *   }
     * })
     * 
     */
    create<T extends FieldOfResearchsCreateArgs>(args: SelectSubset<T, FieldOfResearchsCreateArgs<ExtArgs>>): Prisma__FieldOfResearchsClient<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FieldOfResearchs.
     * @param {FieldOfResearchsCreateManyArgs} args - Arguments to create many FieldOfResearchs.
     * @example
     * // Create many FieldOfResearchs
     * const fieldOfResearchs = await prisma.fieldOfResearchs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FieldOfResearchsCreateManyArgs>(args?: SelectSubset<T, FieldOfResearchsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FieldOfResearchs and returns the data saved in the database.
     * @param {FieldOfResearchsCreateManyAndReturnArgs} args - Arguments to create many FieldOfResearchs.
     * @example
     * // Create many FieldOfResearchs
     * const fieldOfResearchs = await prisma.fieldOfResearchs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FieldOfResearchs and only return the `id`
     * const fieldOfResearchsWithIdOnly = await prisma.fieldOfResearchs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FieldOfResearchsCreateManyAndReturnArgs>(args?: SelectSubset<T, FieldOfResearchsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FieldOfResearchs.
     * @param {FieldOfResearchsDeleteArgs} args - Arguments to delete one FieldOfResearchs.
     * @example
     * // Delete one FieldOfResearchs
     * const FieldOfResearchs = await prisma.fieldOfResearchs.delete({
     *   where: {
     *     // ... filter to delete one FieldOfResearchs
     *   }
     * })
     * 
     */
    delete<T extends FieldOfResearchsDeleteArgs>(args: SelectSubset<T, FieldOfResearchsDeleteArgs<ExtArgs>>): Prisma__FieldOfResearchsClient<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FieldOfResearchs.
     * @param {FieldOfResearchsUpdateArgs} args - Arguments to update one FieldOfResearchs.
     * @example
     * // Update one FieldOfResearchs
     * const fieldOfResearchs = await prisma.fieldOfResearchs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FieldOfResearchsUpdateArgs>(args: SelectSubset<T, FieldOfResearchsUpdateArgs<ExtArgs>>): Prisma__FieldOfResearchsClient<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FieldOfResearchs.
     * @param {FieldOfResearchsDeleteManyArgs} args - Arguments to filter FieldOfResearchs to delete.
     * @example
     * // Delete a few FieldOfResearchs
     * const { count } = await prisma.fieldOfResearchs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FieldOfResearchsDeleteManyArgs>(args?: SelectSubset<T, FieldOfResearchsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FieldOfResearchs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOfResearchsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FieldOfResearchs
     * const fieldOfResearchs = await prisma.fieldOfResearchs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FieldOfResearchsUpdateManyArgs>(args: SelectSubset<T, FieldOfResearchsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FieldOfResearchs and returns the data updated in the database.
     * @param {FieldOfResearchsUpdateManyAndReturnArgs} args - Arguments to update many FieldOfResearchs.
     * @example
     * // Update many FieldOfResearchs
     * const fieldOfResearchs = await prisma.fieldOfResearchs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FieldOfResearchs and only return the `id`
     * const fieldOfResearchsWithIdOnly = await prisma.fieldOfResearchs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FieldOfResearchsUpdateManyAndReturnArgs>(args: SelectSubset<T, FieldOfResearchsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FieldOfResearchs.
     * @param {FieldOfResearchsUpsertArgs} args - Arguments to update or create a FieldOfResearchs.
     * @example
     * // Update or create a FieldOfResearchs
     * const fieldOfResearchs = await prisma.fieldOfResearchs.upsert({
     *   create: {
     *     // ... data to create a FieldOfResearchs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FieldOfResearchs we want to update
     *   }
     * })
     */
    upsert<T extends FieldOfResearchsUpsertArgs>(args: SelectSubset<T, FieldOfResearchsUpsertArgs<ExtArgs>>): Prisma__FieldOfResearchsClient<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FieldOfResearchs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOfResearchsCountArgs} args - Arguments to filter FieldOfResearchs to count.
     * @example
     * // Count the number of FieldOfResearchs
     * const count = await prisma.fieldOfResearchs.count({
     *   where: {
     *     // ... the filter for the FieldOfResearchs we want to count
     *   }
     * })
    **/
    count<T extends FieldOfResearchsCountArgs>(
      args?: Subset<T, FieldOfResearchsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FieldOfResearchsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FieldOfResearchs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOfResearchsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FieldOfResearchsAggregateArgs>(args: Subset<T, FieldOfResearchsAggregateArgs>): Prisma.PrismaPromise<GetFieldOfResearchsAggregateType<T>>

    /**
     * Group by FieldOfResearchs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOfResearchsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FieldOfResearchsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FieldOfResearchsGroupByArgs['orderBy'] }
        : { orderBy?: FieldOfResearchsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FieldOfResearchsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFieldOfResearchsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FieldOfResearchs model
   */
  readonly fields: FieldOfResearchsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FieldOfResearchs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FieldOfResearchsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ConferenceRanks<T extends FieldOfResearchs$ConferenceRanksArgs<ExtArgs> = {}>(args?: Subset<T, FieldOfResearchs$ConferenceRanksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    JournalRanks<T extends FieldOfResearchs$JournalRanksArgs<ExtArgs> = {}>(args?: Subset<T, FieldOfResearchs$JournalRanksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FieldOfResearchs model
   */ 
  interface FieldOfResearchsFieldRefs {
    readonly id: FieldRef<"FieldOfResearchs", 'String'>
    readonly name: FieldRef<"FieldOfResearchs", 'String'>
    readonly code: FieldRef<"FieldOfResearchs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FieldOfResearchs findUnique
   */
  export type FieldOfResearchsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchs
     */
    select?: FieldOfResearchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOfResearchs
     */
    omit?: FieldOfResearchsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOfResearchsInclude<ExtArgs> | null
    /**
     * Filter, which FieldOfResearchs to fetch.
     */
    where: FieldOfResearchsWhereUniqueInput
  }

  /**
   * FieldOfResearchs findUniqueOrThrow
   */
  export type FieldOfResearchsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchs
     */
    select?: FieldOfResearchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOfResearchs
     */
    omit?: FieldOfResearchsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOfResearchsInclude<ExtArgs> | null
    /**
     * Filter, which FieldOfResearchs to fetch.
     */
    where: FieldOfResearchsWhereUniqueInput
  }

  /**
   * FieldOfResearchs findFirst
   */
  export type FieldOfResearchsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchs
     */
    select?: FieldOfResearchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOfResearchs
     */
    omit?: FieldOfResearchsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOfResearchsInclude<ExtArgs> | null
    /**
     * Filter, which FieldOfResearchs to fetch.
     */
    where?: FieldOfResearchsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldOfResearchs to fetch.
     */
    orderBy?: FieldOfResearchsOrderByWithRelationInput | FieldOfResearchsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FieldOfResearchs.
     */
    cursor?: FieldOfResearchsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldOfResearchs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldOfResearchs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FieldOfResearchs.
     */
    distinct?: FieldOfResearchsScalarFieldEnum | FieldOfResearchsScalarFieldEnum[]
  }

  /**
   * FieldOfResearchs findFirstOrThrow
   */
  export type FieldOfResearchsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchs
     */
    select?: FieldOfResearchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOfResearchs
     */
    omit?: FieldOfResearchsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOfResearchsInclude<ExtArgs> | null
    /**
     * Filter, which FieldOfResearchs to fetch.
     */
    where?: FieldOfResearchsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldOfResearchs to fetch.
     */
    orderBy?: FieldOfResearchsOrderByWithRelationInput | FieldOfResearchsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FieldOfResearchs.
     */
    cursor?: FieldOfResearchsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldOfResearchs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldOfResearchs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FieldOfResearchs.
     */
    distinct?: FieldOfResearchsScalarFieldEnum | FieldOfResearchsScalarFieldEnum[]
  }

  /**
   * FieldOfResearchs findMany
   */
  export type FieldOfResearchsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchs
     */
    select?: FieldOfResearchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOfResearchs
     */
    omit?: FieldOfResearchsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOfResearchsInclude<ExtArgs> | null
    /**
     * Filter, which FieldOfResearchs to fetch.
     */
    where?: FieldOfResearchsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldOfResearchs to fetch.
     */
    orderBy?: FieldOfResearchsOrderByWithRelationInput | FieldOfResearchsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FieldOfResearchs.
     */
    cursor?: FieldOfResearchsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldOfResearchs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldOfResearchs.
     */
    skip?: number
    distinct?: FieldOfResearchsScalarFieldEnum | FieldOfResearchsScalarFieldEnum[]
  }

  /**
   * FieldOfResearchs create
   */
  export type FieldOfResearchsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchs
     */
    select?: FieldOfResearchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOfResearchs
     */
    omit?: FieldOfResearchsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOfResearchsInclude<ExtArgs> | null
    /**
     * The data needed to create a FieldOfResearchs.
     */
    data: XOR<FieldOfResearchsCreateInput, FieldOfResearchsUncheckedCreateInput>
  }

  /**
   * FieldOfResearchs createMany
   */
  export type FieldOfResearchsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FieldOfResearchs.
     */
    data: FieldOfResearchsCreateManyInput | FieldOfResearchsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FieldOfResearchs createManyAndReturn
   */
  export type FieldOfResearchsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchs
     */
    select?: FieldOfResearchsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOfResearchs
     */
    omit?: FieldOfResearchsOmit<ExtArgs> | null
    /**
     * The data used to create many FieldOfResearchs.
     */
    data: FieldOfResearchsCreateManyInput | FieldOfResearchsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FieldOfResearchs update
   */
  export type FieldOfResearchsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchs
     */
    select?: FieldOfResearchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOfResearchs
     */
    omit?: FieldOfResearchsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOfResearchsInclude<ExtArgs> | null
    /**
     * The data needed to update a FieldOfResearchs.
     */
    data: XOR<FieldOfResearchsUpdateInput, FieldOfResearchsUncheckedUpdateInput>
    /**
     * Choose, which FieldOfResearchs to update.
     */
    where: FieldOfResearchsWhereUniqueInput
  }

  /**
   * FieldOfResearchs updateMany
   */
  export type FieldOfResearchsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FieldOfResearchs.
     */
    data: XOR<FieldOfResearchsUpdateManyMutationInput, FieldOfResearchsUncheckedUpdateManyInput>
    /**
     * Filter which FieldOfResearchs to update
     */
    where?: FieldOfResearchsWhereInput
    /**
     * Limit how many FieldOfResearchs to update.
     */
    limit?: number
  }

  /**
   * FieldOfResearchs updateManyAndReturn
   */
  export type FieldOfResearchsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchs
     */
    select?: FieldOfResearchsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOfResearchs
     */
    omit?: FieldOfResearchsOmit<ExtArgs> | null
    /**
     * The data used to update FieldOfResearchs.
     */
    data: XOR<FieldOfResearchsUpdateManyMutationInput, FieldOfResearchsUncheckedUpdateManyInput>
    /**
     * Filter which FieldOfResearchs to update
     */
    where?: FieldOfResearchsWhereInput
    /**
     * Limit how many FieldOfResearchs to update.
     */
    limit?: number
  }

  /**
   * FieldOfResearchs upsert
   */
  export type FieldOfResearchsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchs
     */
    select?: FieldOfResearchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOfResearchs
     */
    omit?: FieldOfResearchsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOfResearchsInclude<ExtArgs> | null
    /**
     * The filter to search for the FieldOfResearchs to update in case it exists.
     */
    where: FieldOfResearchsWhereUniqueInput
    /**
     * In case the FieldOfResearchs found by the `where` argument doesn't exist, create a new FieldOfResearchs with this data.
     */
    create: XOR<FieldOfResearchsCreateInput, FieldOfResearchsUncheckedCreateInput>
    /**
     * In case the FieldOfResearchs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FieldOfResearchsUpdateInput, FieldOfResearchsUncheckedUpdateInput>
  }

  /**
   * FieldOfResearchs delete
   */
  export type FieldOfResearchsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchs
     */
    select?: FieldOfResearchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOfResearchs
     */
    omit?: FieldOfResearchsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOfResearchsInclude<ExtArgs> | null
    /**
     * Filter which FieldOfResearchs to delete.
     */
    where: FieldOfResearchsWhereUniqueInput
  }

  /**
   * FieldOfResearchs deleteMany
   */
  export type FieldOfResearchsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FieldOfResearchs to delete
     */
    where?: FieldOfResearchsWhereInput
    /**
     * Limit how many FieldOfResearchs to delete.
     */
    limit?: number
  }

  /**
   * FieldOfResearchs.ConferenceRanks
   */
  export type FieldOfResearchs$ConferenceRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
    where?: ConferenceRanksWhereInput
    orderBy?: ConferenceRanksOrderByWithRelationInput | ConferenceRanksOrderByWithRelationInput[]
    cursor?: ConferenceRanksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceRanksScalarFieldEnum | ConferenceRanksScalarFieldEnum[]
  }

  /**
   * FieldOfResearchs.JournalRanks
   */
  export type FieldOfResearchs$JournalRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
    where?: JournalRanksWhereInput
    orderBy?: JournalRanksOrderByWithRelationInput | JournalRanksOrderByWithRelationInput[]
    cursor?: JournalRanksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalRanksScalarFieldEnum | JournalRanksScalarFieldEnum[]
  }

  /**
   * FieldOfResearchs without action
   */
  export type FieldOfResearchsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchs
     */
    select?: FieldOfResearchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOfResearchs
     */
    omit?: FieldOfResearchsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOfResearchsInclude<ExtArgs> | null
  }


  /**
   * Model JournalCrawlJobs
   */

  export type AggregateJournalCrawlJobs = {
    _count: JournalCrawlJobsCountAggregateOutputType | null
    _avg: JournalCrawlJobsAvgAggregateOutputType | null
    _sum: JournalCrawlJobsSumAggregateOutputType | null
    _min: JournalCrawlJobsMinAggregateOutputType | null
    _max: JournalCrawlJobsMaxAggregateOutputType | null
  }

  export type JournalCrawlJobsAvgAggregateOutputType = {
    progress: number | null
  }

  export type JournalCrawlJobsSumAggregateOutputType = {
    progress: number | null
  }

  export type JournalCrawlJobsMinAggregateOutputType = {
    id: string | null
    journalId: string | null
    status: string | null
    progress: number | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalCrawlJobsMaxAggregateOutputType = {
    id: string | null
    journalId: string | null
    status: string | null
    progress: number | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalCrawlJobsCountAggregateOutputType = {
    id: number
    journalId: number
    status: number
    progress: number
    message: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JournalCrawlJobsAvgAggregateInputType = {
    progress?: true
  }

  export type JournalCrawlJobsSumAggregateInputType = {
    progress?: true
  }

  export type JournalCrawlJobsMinAggregateInputType = {
    id?: true
    journalId?: true
    status?: true
    progress?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalCrawlJobsMaxAggregateInputType = {
    id?: true
    journalId?: true
    status?: true
    progress?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalCrawlJobsCountAggregateInputType = {
    id?: true
    journalId?: true
    status?: true
    progress?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JournalCrawlJobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalCrawlJobs to aggregate.
     */
    where?: JournalCrawlJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalCrawlJobs to fetch.
     */
    orderBy?: JournalCrawlJobsOrderByWithRelationInput | JournalCrawlJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalCrawlJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalCrawlJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalCrawlJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalCrawlJobs
    **/
    _count?: true | JournalCrawlJobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JournalCrawlJobsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JournalCrawlJobsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalCrawlJobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalCrawlJobsMaxAggregateInputType
  }

  export type GetJournalCrawlJobsAggregateType<T extends JournalCrawlJobsAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalCrawlJobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalCrawlJobs[P]>
      : GetScalarType<T[P], AggregateJournalCrawlJobs[P]>
  }




  export type JournalCrawlJobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalCrawlJobsWhereInput
    orderBy?: JournalCrawlJobsOrderByWithAggregationInput | JournalCrawlJobsOrderByWithAggregationInput[]
    by: JournalCrawlJobsScalarFieldEnum[] | JournalCrawlJobsScalarFieldEnum
    having?: JournalCrawlJobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalCrawlJobsCountAggregateInputType | true
    _avg?: JournalCrawlJobsAvgAggregateInputType
    _sum?: JournalCrawlJobsSumAggregateInputType
    _min?: JournalCrawlJobsMinAggregateInputType
    _max?: JournalCrawlJobsMaxAggregateInputType
  }

  export type JournalCrawlJobsGroupByOutputType = {
    id: string
    journalId: string
    status: string
    progress: number
    message: string
    createdAt: Date
    updatedAt: Date
    _count: JournalCrawlJobsCountAggregateOutputType | null
    _avg: JournalCrawlJobsAvgAggregateOutputType | null
    _sum: JournalCrawlJobsSumAggregateOutputType | null
    _min: JournalCrawlJobsMinAggregateOutputType | null
    _max: JournalCrawlJobsMaxAggregateOutputType | null
  }

  type GetJournalCrawlJobsGroupByPayload<T extends JournalCrawlJobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalCrawlJobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalCrawlJobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalCrawlJobsGroupByOutputType[P]>
            : GetScalarType<T[P], JournalCrawlJobsGroupByOutputType[P]>
        }
      >
    >


  export type JournalCrawlJobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    status?: boolean
    progress?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalCrawlJobs"]>

  export type JournalCrawlJobsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    status?: boolean
    progress?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalCrawlJobs"]>

  export type JournalCrawlJobsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    status?: boolean
    progress?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalCrawlJobs"]>

  export type JournalCrawlJobsSelectScalar = {
    id?: boolean
    journalId?: boolean
    status?: boolean
    progress?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JournalCrawlJobsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "journalId" | "status" | "progress" | "message" | "createdAt" | "updatedAt", ExtArgs["result"]["journalCrawlJobs"]>
  export type JournalCrawlJobsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
  }
  export type JournalCrawlJobsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
  }
  export type JournalCrawlJobsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
  }

  export type $JournalCrawlJobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalCrawlJobs"
    objects: {
      Journals: Prisma.$JournalsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      journalId: string
      status: string
      progress: number
      message: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["journalCrawlJobs"]>
    composites: {}
  }

  type JournalCrawlJobsGetPayload<S extends boolean | null | undefined | JournalCrawlJobsDefaultArgs> = $Result.GetResult<Prisma.$JournalCrawlJobsPayload, S>

  type JournalCrawlJobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalCrawlJobsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalCrawlJobsCountAggregateInputType | true
    }

  export interface JournalCrawlJobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalCrawlJobs'], meta: { name: 'JournalCrawlJobs' } }
    /**
     * Find zero or one JournalCrawlJobs that matches the filter.
     * @param {JournalCrawlJobsFindUniqueArgs} args - Arguments to find a JournalCrawlJobs
     * @example
     * // Get one JournalCrawlJobs
     * const journalCrawlJobs = await prisma.journalCrawlJobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalCrawlJobsFindUniqueArgs>(args: SelectSubset<T, JournalCrawlJobsFindUniqueArgs<ExtArgs>>): Prisma__JournalCrawlJobsClient<$Result.GetResult<Prisma.$JournalCrawlJobsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JournalCrawlJobs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalCrawlJobsFindUniqueOrThrowArgs} args - Arguments to find a JournalCrawlJobs
     * @example
     * // Get one JournalCrawlJobs
     * const journalCrawlJobs = await prisma.journalCrawlJobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalCrawlJobsFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalCrawlJobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalCrawlJobsClient<$Result.GetResult<Prisma.$JournalCrawlJobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalCrawlJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalCrawlJobsFindFirstArgs} args - Arguments to find a JournalCrawlJobs
     * @example
     * // Get one JournalCrawlJobs
     * const journalCrawlJobs = await prisma.journalCrawlJobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalCrawlJobsFindFirstArgs>(args?: SelectSubset<T, JournalCrawlJobsFindFirstArgs<ExtArgs>>): Prisma__JournalCrawlJobsClient<$Result.GetResult<Prisma.$JournalCrawlJobsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalCrawlJobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalCrawlJobsFindFirstOrThrowArgs} args - Arguments to find a JournalCrawlJobs
     * @example
     * // Get one JournalCrawlJobs
     * const journalCrawlJobs = await prisma.journalCrawlJobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalCrawlJobsFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalCrawlJobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalCrawlJobsClient<$Result.GetResult<Prisma.$JournalCrawlJobsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JournalCrawlJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalCrawlJobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalCrawlJobs
     * const journalCrawlJobs = await prisma.journalCrawlJobs.findMany()
     * 
     * // Get first 10 JournalCrawlJobs
     * const journalCrawlJobs = await prisma.journalCrawlJobs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalCrawlJobsWithIdOnly = await prisma.journalCrawlJobs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalCrawlJobsFindManyArgs>(args?: SelectSubset<T, JournalCrawlJobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalCrawlJobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JournalCrawlJobs.
     * @param {JournalCrawlJobsCreateArgs} args - Arguments to create a JournalCrawlJobs.
     * @example
     * // Create one JournalCrawlJobs
     * const JournalCrawlJobs = await prisma.journalCrawlJobs.create({
     *   data: {
     *     // ... data to create a JournalCrawlJobs
     *   }
     * })
     * 
     */
    create<T extends JournalCrawlJobsCreateArgs>(args: SelectSubset<T, JournalCrawlJobsCreateArgs<ExtArgs>>): Prisma__JournalCrawlJobsClient<$Result.GetResult<Prisma.$JournalCrawlJobsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JournalCrawlJobs.
     * @param {JournalCrawlJobsCreateManyArgs} args - Arguments to create many JournalCrawlJobs.
     * @example
     * // Create many JournalCrawlJobs
     * const journalCrawlJobs = await prisma.journalCrawlJobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalCrawlJobsCreateManyArgs>(args?: SelectSubset<T, JournalCrawlJobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalCrawlJobs and returns the data saved in the database.
     * @param {JournalCrawlJobsCreateManyAndReturnArgs} args - Arguments to create many JournalCrawlJobs.
     * @example
     * // Create many JournalCrawlJobs
     * const journalCrawlJobs = await prisma.journalCrawlJobs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalCrawlJobs and only return the `id`
     * const journalCrawlJobsWithIdOnly = await prisma.journalCrawlJobs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalCrawlJobsCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalCrawlJobsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalCrawlJobsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JournalCrawlJobs.
     * @param {JournalCrawlJobsDeleteArgs} args - Arguments to delete one JournalCrawlJobs.
     * @example
     * // Delete one JournalCrawlJobs
     * const JournalCrawlJobs = await prisma.journalCrawlJobs.delete({
     *   where: {
     *     // ... filter to delete one JournalCrawlJobs
     *   }
     * })
     * 
     */
    delete<T extends JournalCrawlJobsDeleteArgs>(args: SelectSubset<T, JournalCrawlJobsDeleteArgs<ExtArgs>>): Prisma__JournalCrawlJobsClient<$Result.GetResult<Prisma.$JournalCrawlJobsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JournalCrawlJobs.
     * @param {JournalCrawlJobsUpdateArgs} args - Arguments to update one JournalCrawlJobs.
     * @example
     * // Update one JournalCrawlJobs
     * const journalCrawlJobs = await prisma.journalCrawlJobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalCrawlJobsUpdateArgs>(args: SelectSubset<T, JournalCrawlJobsUpdateArgs<ExtArgs>>): Prisma__JournalCrawlJobsClient<$Result.GetResult<Prisma.$JournalCrawlJobsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JournalCrawlJobs.
     * @param {JournalCrawlJobsDeleteManyArgs} args - Arguments to filter JournalCrawlJobs to delete.
     * @example
     * // Delete a few JournalCrawlJobs
     * const { count } = await prisma.journalCrawlJobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalCrawlJobsDeleteManyArgs>(args?: SelectSubset<T, JournalCrawlJobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalCrawlJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalCrawlJobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalCrawlJobs
     * const journalCrawlJobs = await prisma.journalCrawlJobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalCrawlJobsUpdateManyArgs>(args: SelectSubset<T, JournalCrawlJobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalCrawlJobs and returns the data updated in the database.
     * @param {JournalCrawlJobsUpdateManyAndReturnArgs} args - Arguments to update many JournalCrawlJobs.
     * @example
     * // Update many JournalCrawlJobs
     * const journalCrawlJobs = await prisma.journalCrawlJobs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JournalCrawlJobs and only return the `id`
     * const journalCrawlJobsWithIdOnly = await prisma.journalCrawlJobs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalCrawlJobsUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalCrawlJobsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalCrawlJobsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JournalCrawlJobs.
     * @param {JournalCrawlJobsUpsertArgs} args - Arguments to update or create a JournalCrawlJobs.
     * @example
     * // Update or create a JournalCrawlJobs
     * const journalCrawlJobs = await prisma.journalCrawlJobs.upsert({
     *   create: {
     *     // ... data to create a JournalCrawlJobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalCrawlJobs we want to update
     *   }
     * })
     */
    upsert<T extends JournalCrawlJobsUpsertArgs>(args: SelectSubset<T, JournalCrawlJobsUpsertArgs<ExtArgs>>): Prisma__JournalCrawlJobsClient<$Result.GetResult<Prisma.$JournalCrawlJobsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JournalCrawlJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalCrawlJobsCountArgs} args - Arguments to filter JournalCrawlJobs to count.
     * @example
     * // Count the number of JournalCrawlJobs
     * const count = await prisma.journalCrawlJobs.count({
     *   where: {
     *     // ... the filter for the JournalCrawlJobs we want to count
     *   }
     * })
    **/
    count<T extends JournalCrawlJobsCountArgs>(
      args?: Subset<T, JournalCrawlJobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalCrawlJobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalCrawlJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalCrawlJobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalCrawlJobsAggregateArgs>(args: Subset<T, JournalCrawlJobsAggregateArgs>): Prisma.PrismaPromise<GetJournalCrawlJobsAggregateType<T>>

    /**
     * Group by JournalCrawlJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalCrawlJobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalCrawlJobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalCrawlJobsGroupByArgs['orderBy'] }
        : { orderBy?: JournalCrawlJobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalCrawlJobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalCrawlJobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalCrawlJobs model
   */
  readonly fields: JournalCrawlJobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalCrawlJobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalCrawlJobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Journals<T extends JournalsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JournalsDefaultArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalCrawlJobs model
   */ 
  interface JournalCrawlJobsFieldRefs {
    readonly id: FieldRef<"JournalCrawlJobs", 'String'>
    readonly journalId: FieldRef<"JournalCrawlJobs", 'String'>
    readonly status: FieldRef<"JournalCrawlJobs", 'String'>
    readonly progress: FieldRef<"JournalCrawlJobs", 'Int'>
    readonly message: FieldRef<"JournalCrawlJobs", 'String'>
    readonly createdAt: FieldRef<"JournalCrawlJobs", 'DateTime'>
    readonly updatedAt: FieldRef<"JournalCrawlJobs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JournalCrawlJobs findUnique
   */
  export type JournalCrawlJobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsInclude<ExtArgs> | null
    /**
     * Filter, which JournalCrawlJobs to fetch.
     */
    where: JournalCrawlJobsWhereUniqueInput
  }

  /**
   * JournalCrawlJobs findUniqueOrThrow
   */
  export type JournalCrawlJobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsInclude<ExtArgs> | null
    /**
     * Filter, which JournalCrawlJobs to fetch.
     */
    where: JournalCrawlJobsWhereUniqueInput
  }

  /**
   * JournalCrawlJobs findFirst
   */
  export type JournalCrawlJobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsInclude<ExtArgs> | null
    /**
     * Filter, which JournalCrawlJobs to fetch.
     */
    where?: JournalCrawlJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalCrawlJobs to fetch.
     */
    orderBy?: JournalCrawlJobsOrderByWithRelationInput | JournalCrawlJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalCrawlJobs.
     */
    cursor?: JournalCrawlJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalCrawlJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalCrawlJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalCrawlJobs.
     */
    distinct?: JournalCrawlJobsScalarFieldEnum | JournalCrawlJobsScalarFieldEnum[]
  }

  /**
   * JournalCrawlJobs findFirstOrThrow
   */
  export type JournalCrawlJobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsInclude<ExtArgs> | null
    /**
     * Filter, which JournalCrawlJobs to fetch.
     */
    where?: JournalCrawlJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalCrawlJobs to fetch.
     */
    orderBy?: JournalCrawlJobsOrderByWithRelationInput | JournalCrawlJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalCrawlJobs.
     */
    cursor?: JournalCrawlJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalCrawlJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalCrawlJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalCrawlJobs.
     */
    distinct?: JournalCrawlJobsScalarFieldEnum | JournalCrawlJobsScalarFieldEnum[]
  }

  /**
   * JournalCrawlJobs findMany
   */
  export type JournalCrawlJobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsInclude<ExtArgs> | null
    /**
     * Filter, which JournalCrawlJobs to fetch.
     */
    where?: JournalCrawlJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalCrawlJobs to fetch.
     */
    orderBy?: JournalCrawlJobsOrderByWithRelationInput | JournalCrawlJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalCrawlJobs.
     */
    cursor?: JournalCrawlJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalCrawlJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalCrawlJobs.
     */
    skip?: number
    distinct?: JournalCrawlJobsScalarFieldEnum | JournalCrawlJobsScalarFieldEnum[]
  }

  /**
   * JournalCrawlJobs create
   */
  export type JournalCrawlJobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalCrawlJobs.
     */
    data: XOR<JournalCrawlJobsCreateInput, JournalCrawlJobsUncheckedCreateInput>
  }

  /**
   * JournalCrawlJobs createMany
   */
  export type JournalCrawlJobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalCrawlJobs.
     */
    data: JournalCrawlJobsCreateManyInput | JournalCrawlJobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalCrawlJobs createManyAndReturn
   */
  export type JournalCrawlJobsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * The data used to create many JournalCrawlJobs.
     */
    data: JournalCrawlJobsCreateManyInput | JournalCrawlJobsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalCrawlJobs update
   */
  export type JournalCrawlJobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalCrawlJobs.
     */
    data: XOR<JournalCrawlJobsUpdateInput, JournalCrawlJobsUncheckedUpdateInput>
    /**
     * Choose, which JournalCrawlJobs to update.
     */
    where: JournalCrawlJobsWhereUniqueInput
  }

  /**
   * JournalCrawlJobs updateMany
   */
  export type JournalCrawlJobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalCrawlJobs.
     */
    data: XOR<JournalCrawlJobsUpdateManyMutationInput, JournalCrawlJobsUncheckedUpdateManyInput>
    /**
     * Filter which JournalCrawlJobs to update
     */
    where?: JournalCrawlJobsWhereInput
    /**
     * Limit how many JournalCrawlJobs to update.
     */
    limit?: number
  }

  /**
   * JournalCrawlJobs updateManyAndReturn
   */
  export type JournalCrawlJobsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * The data used to update JournalCrawlJobs.
     */
    data: XOR<JournalCrawlJobsUpdateManyMutationInput, JournalCrawlJobsUncheckedUpdateManyInput>
    /**
     * Filter which JournalCrawlJobs to update
     */
    where?: JournalCrawlJobsWhereInput
    /**
     * Limit how many JournalCrawlJobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalCrawlJobs upsert
   */
  export type JournalCrawlJobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalCrawlJobs to update in case it exists.
     */
    where: JournalCrawlJobsWhereUniqueInput
    /**
     * In case the JournalCrawlJobs found by the `where` argument doesn't exist, create a new JournalCrawlJobs with this data.
     */
    create: XOR<JournalCrawlJobsCreateInput, JournalCrawlJobsUncheckedCreateInput>
    /**
     * In case the JournalCrawlJobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalCrawlJobsUpdateInput, JournalCrawlJobsUncheckedUpdateInput>
  }

  /**
   * JournalCrawlJobs delete
   */
  export type JournalCrawlJobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsInclude<ExtArgs> | null
    /**
     * Filter which JournalCrawlJobs to delete.
     */
    where: JournalCrawlJobsWhereUniqueInput
  }

  /**
   * JournalCrawlJobs deleteMany
   */
  export type JournalCrawlJobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalCrawlJobs to delete
     */
    where?: JournalCrawlJobsWhereInput
    /**
     * Limit how many JournalCrawlJobs to delete.
     */
    limit?: number
  }

  /**
   * JournalCrawlJobs without action
   */
  export type JournalCrawlJobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsInclude<ExtArgs> | null
  }


  /**
   * Model JournalFollows
   */

  export type AggregateJournalFollows = {
    _count: JournalFollowsCountAggregateOutputType | null
    _min: JournalFollowsMinAggregateOutputType | null
    _max: JournalFollowsMaxAggregateOutputType | null
  }

  export type JournalFollowsMinAggregateOutputType = {
    id: string | null
    journalId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalFollowsMaxAggregateOutputType = {
    id: string | null
    journalId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalFollowsCountAggregateOutputType = {
    id: number
    journalId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JournalFollowsMinAggregateInputType = {
    id?: true
    journalId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalFollowsMaxAggregateInputType = {
    id?: true
    journalId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalFollowsCountAggregateInputType = {
    id?: true
    journalId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JournalFollowsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalFollows to aggregate.
     */
    where?: JournalFollowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalFollows to fetch.
     */
    orderBy?: JournalFollowsOrderByWithRelationInput | JournalFollowsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalFollowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalFollows
    **/
    _count?: true | JournalFollowsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalFollowsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalFollowsMaxAggregateInputType
  }

  export type GetJournalFollowsAggregateType<T extends JournalFollowsAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalFollows]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalFollows[P]>
      : GetScalarType<T[P], AggregateJournalFollows[P]>
  }




  export type JournalFollowsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalFollowsWhereInput
    orderBy?: JournalFollowsOrderByWithAggregationInput | JournalFollowsOrderByWithAggregationInput[]
    by: JournalFollowsScalarFieldEnum[] | JournalFollowsScalarFieldEnum
    having?: JournalFollowsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalFollowsCountAggregateInputType | true
    _min?: JournalFollowsMinAggregateInputType
    _max?: JournalFollowsMaxAggregateInputType
  }

  export type JournalFollowsGroupByOutputType = {
    id: string
    journalId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: JournalFollowsCountAggregateOutputType | null
    _min: JournalFollowsMinAggregateOutputType | null
    _max: JournalFollowsMaxAggregateOutputType | null
  }

  type GetJournalFollowsGroupByPayload<T extends JournalFollowsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalFollowsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalFollowsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalFollowsGroupByOutputType[P]>
            : GetScalarType<T[P], JournalFollowsGroupByOutputType[P]>
        }
      >
    >


  export type JournalFollowsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalFollows"]>

  export type JournalFollowsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalFollows"]>

  export type JournalFollowsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalFollows"]>

  export type JournalFollowsSelectScalar = {
    id?: boolean
    journalId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JournalFollowsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "journalId" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["journalFollows"]>
  export type JournalFollowsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type JournalFollowsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type JournalFollowsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $JournalFollowsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalFollows"
    objects: {
      Journals: Prisma.$JournalsPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      journalId: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["journalFollows"]>
    composites: {}
  }

  type JournalFollowsGetPayload<S extends boolean | null | undefined | JournalFollowsDefaultArgs> = $Result.GetResult<Prisma.$JournalFollowsPayload, S>

  type JournalFollowsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalFollowsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalFollowsCountAggregateInputType | true
    }

  export interface JournalFollowsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalFollows'], meta: { name: 'JournalFollows' } }
    /**
     * Find zero or one JournalFollows that matches the filter.
     * @param {JournalFollowsFindUniqueArgs} args - Arguments to find a JournalFollows
     * @example
     * // Get one JournalFollows
     * const journalFollows = await prisma.journalFollows.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalFollowsFindUniqueArgs>(args: SelectSubset<T, JournalFollowsFindUniqueArgs<ExtArgs>>): Prisma__JournalFollowsClient<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JournalFollows that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalFollowsFindUniqueOrThrowArgs} args - Arguments to find a JournalFollows
     * @example
     * // Get one JournalFollows
     * const journalFollows = await prisma.journalFollows.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalFollowsFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalFollowsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalFollowsClient<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalFollows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFollowsFindFirstArgs} args - Arguments to find a JournalFollows
     * @example
     * // Get one JournalFollows
     * const journalFollows = await prisma.journalFollows.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalFollowsFindFirstArgs>(args?: SelectSubset<T, JournalFollowsFindFirstArgs<ExtArgs>>): Prisma__JournalFollowsClient<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalFollows that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFollowsFindFirstOrThrowArgs} args - Arguments to find a JournalFollows
     * @example
     * // Get one JournalFollows
     * const journalFollows = await prisma.journalFollows.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalFollowsFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalFollowsFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalFollowsClient<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JournalFollows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFollowsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalFollows
     * const journalFollows = await prisma.journalFollows.findMany()
     * 
     * // Get first 10 JournalFollows
     * const journalFollows = await prisma.journalFollows.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalFollowsWithIdOnly = await prisma.journalFollows.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalFollowsFindManyArgs>(args?: SelectSubset<T, JournalFollowsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JournalFollows.
     * @param {JournalFollowsCreateArgs} args - Arguments to create a JournalFollows.
     * @example
     * // Create one JournalFollows
     * const JournalFollows = await prisma.journalFollows.create({
     *   data: {
     *     // ... data to create a JournalFollows
     *   }
     * })
     * 
     */
    create<T extends JournalFollowsCreateArgs>(args: SelectSubset<T, JournalFollowsCreateArgs<ExtArgs>>): Prisma__JournalFollowsClient<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JournalFollows.
     * @param {JournalFollowsCreateManyArgs} args - Arguments to create many JournalFollows.
     * @example
     * // Create many JournalFollows
     * const journalFollows = await prisma.journalFollows.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalFollowsCreateManyArgs>(args?: SelectSubset<T, JournalFollowsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalFollows and returns the data saved in the database.
     * @param {JournalFollowsCreateManyAndReturnArgs} args - Arguments to create many JournalFollows.
     * @example
     * // Create many JournalFollows
     * const journalFollows = await prisma.journalFollows.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalFollows and only return the `id`
     * const journalFollowsWithIdOnly = await prisma.journalFollows.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalFollowsCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalFollowsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JournalFollows.
     * @param {JournalFollowsDeleteArgs} args - Arguments to delete one JournalFollows.
     * @example
     * // Delete one JournalFollows
     * const JournalFollows = await prisma.journalFollows.delete({
     *   where: {
     *     // ... filter to delete one JournalFollows
     *   }
     * })
     * 
     */
    delete<T extends JournalFollowsDeleteArgs>(args: SelectSubset<T, JournalFollowsDeleteArgs<ExtArgs>>): Prisma__JournalFollowsClient<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JournalFollows.
     * @param {JournalFollowsUpdateArgs} args - Arguments to update one JournalFollows.
     * @example
     * // Update one JournalFollows
     * const journalFollows = await prisma.journalFollows.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalFollowsUpdateArgs>(args: SelectSubset<T, JournalFollowsUpdateArgs<ExtArgs>>): Prisma__JournalFollowsClient<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JournalFollows.
     * @param {JournalFollowsDeleteManyArgs} args - Arguments to filter JournalFollows to delete.
     * @example
     * // Delete a few JournalFollows
     * const { count } = await prisma.journalFollows.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalFollowsDeleteManyArgs>(args?: SelectSubset<T, JournalFollowsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFollowsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalFollows
     * const journalFollows = await prisma.journalFollows.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalFollowsUpdateManyArgs>(args: SelectSubset<T, JournalFollowsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalFollows and returns the data updated in the database.
     * @param {JournalFollowsUpdateManyAndReturnArgs} args - Arguments to update many JournalFollows.
     * @example
     * // Update many JournalFollows
     * const journalFollows = await prisma.journalFollows.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JournalFollows and only return the `id`
     * const journalFollowsWithIdOnly = await prisma.journalFollows.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalFollowsUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalFollowsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JournalFollows.
     * @param {JournalFollowsUpsertArgs} args - Arguments to update or create a JournalFollows.
     * @example
     * // Update or create a JournalFollows
     * const journalFollows = await prisma.journalFollows.upsert({
     *   create: {
     *     // ... data to create a JournalFollows
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalFollows we want to update
     *   }
     * })
     */
    upsert<T extends JournalFollowsUpsertArgs>(args: SelectSubset<T, JournalFollowsUpsertArgs<ExtArgs>>): Prisma__JournalFollowsClient<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JournalFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFollowsCountArgs} args - Arguments to filter JournalFollows to count.
     * @example
     * // Count the number of JournalFollows
     * const count = await prisma.journalFollows.count({
     *   where: {
     *     // ... the filter for the JournalFollows we want to count
     *   }
     * })
    **/
    count<T extends JournalFollowsCountArgs>(
      args?: Subset<T, JournalFollowsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalFollowsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFollowsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalFollowsAggregateArgs>(args: Subset<T, JournalFollowsAggregateArgs>): Prisma.PrismaPromise<GetJournalFollowsAggregateType<T>>

    /**
     * Group by JournalFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFollowsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalFollowsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalFollowsGroupByArgs['orderBy'] }
        : { orderBy?: JournalFollowsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalFollowsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalFollowsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalFollows model
   */
  readonly fields: JournalFollowsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalFollows.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalFollowsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Journals<T extends JournalsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JournalsDefaultArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalFollows model
   */ 
  interface JournalFollowsFieldRefs {
    readonly id: FieldRef<"JournalFollows", 'String'>
    readonly journalId: FieldRef<"JournalFollows", 'String'>
    readonly userId: FieldRef<"JournalFollows", 'String'>
    readonly createdAt: FieldRef<"JournalFollows", 'DateTime'>
    readonly updatedAt: FieldRef<"JournalFollows", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JournalFollows findUnique
   */
  export type JournalFollowsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsInclude<ExtArgs> | null
    /**
     * Filter, which JournalFollows to fetch.
     */
    where: JournalFollowsWhereUniqueInput
  }

  /**
   * JournalFollows findUniqueOrThrow
   */
  export type JournalFollowsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsInclude<ExtArgs> | null
    /**
     * Filter, which JournalFollows to fetch.
     */
    where: JournalFollowsWhereUniqueInput
  }

  /**
   * JournalFollows findFirst
   */
  export type JournalFollowsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsInclude<ExtArgs> | null
    /**
     * Filter, which JournalFollows to fetch.
     */
    where?: JournalFollowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalFollows to fetch.
     */
    orderBy?: JournalFollowsOrderByWithRelationInput | JournalFollowsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalFollows.
     */
    cursor?: JournalFollowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalFollows.
     */
    distinct?: JournalFollowsScalarFieldEnum | JournalFollowsScalarFieldEnum[]
  }

  /**
   * JournalFollows findFirstOrThrow
   */
  export type JournalFollowsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsInclude<ExtArgs> | null
    /**
     * Filter, which JournalFollows to fetch.
     */
    where?: JournalFollowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalFollows to fetch.
     */
    orderBy?: JournalFollowsOrderByWithRelationInput | JournalFollowsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalFollows.
     */
    cursor?: JournalFollowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalFollows.
     */
    distinct?: JournalFollowsScalarFieldEnum | JournalFollowsScalarFieldEnum[]
  }

  /**
   * JournalFollows findMany
   */
  export type JournalFollowsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsInclude<ExtArgs> | null
    /**
     * Filter, which JournalFollows to fetch.
     */
    where?: JournalFollowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalFollows to fetch.
     */
    orderBy?: JournalFollowsOrderByWithRelationInput | JournalFollowsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalFollows.
     */
    cursor?: JournalFollowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalFollows.
     */
    skip?: number
    distinct?: JournalFollowsScalarFieldEnum | JournalFollowsScalarFieldEnum[]
  }

  /**
   * JournalFollows create
   */
  export type JournalFollowsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalFollows.
     */
    data: XOR<JournalFollowsCreateInput, JournalFollowsUncheckedCreateInput>
  }

  /**
   * JournalFollows createMany
   */
  export type JournalFollowsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalFollows.
     */
    data: JournalFollowsCreateManyInput | JournalFollowsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalFollows createManyAndReturn
   */
  export type JournalFollowsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * The data used to create many JournalFollows.
     */
    data: JournalFollowsCreateManyInput | JournalFollowsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalFollows update
   */
  export type JournalFollowsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalFollows.
     */
    data: XOR<JournalFollowsUpdateInput, JournalFollowsUncheckedUpdateInput>
    /**
     * Choose, which JournalFollows to update.
     */
    where: JournalFollowsWhereUniqueInput
  }

  /**
   * JournalFollows updateMany
   */
  export type JournalFollowsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalFollows.
     */
    data: XOR<JournalFollowsUpdateManyMutationInput, JournalFollowsUncheckedUpdateManyInput>
    /**
     * Filter which JournalFollows to update
     */
    where?: JournalFollowsWhereInput
    /**
     * Limit how many JournalFollows to update.
     */
    limit?: number
  }

  /**
   * JournalFollows updateManyAndReturn
   */
  export type JournalFollowsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * The data used to update JournalFollows.
     */
    data: XOR<JournalFollowsUpdateManyMutationInput, JournalFollowsUncheckedUpdateManyInput>
    /**
     * Filter which JournalFollows to update
     */
    where?: JournalFollowsWhereInput
    /**
     * Limit how many JournalFollows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalFollows upsert
   */
  export type JournalFollowsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalFollows to update in case it exists.
     */
    where: JournalFollowsWhereUniqueInput
    /**
     * In case the JournalFollows found by the `where` argument doesn't exist, create a new JournalFollows with this data.
     */
    create: XOR<JournalFollowsCreateInput, JournalFollowsUncheckedCreateInput>
    /**
     * In case the JournalFollows was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalFollowsUpdateInput, JournalFollowsUncheckedUpdateInput>
  }

  /**
   * JournalFollows delete
   */
  export type JournalFollowsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsInclude<ExtArgs> | null
    /**
     * Filter which JournalFollows to delete.
     */
    where: JournalFollowsWhereUniqueInput
  }

  /**
   * JournalFollows deleteMany
   */
  export type JournalFollowsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalFollows to delete
     */
    where?: JournalFollowsWhereInput
    /**
     * Limit how many JournalFollows to delete.
     */
    limit?: number
  }

  /**
   * JournalFollows without action
   */
  export type JournalFollowsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsInclude<ExtArgs> | null
  }


  /**
   * Model JournalLikes
   */

  export type AggregateJournalLikes = {
    _count: JournalLikesCountAggregateOutputType | null
    _min: JournalLikesMinAggregateOutputType | null
    _max: JournalLikesMaxAggregateOutputType | null
  }

  export type JournalLikesMinAggregateOutputType = {
    id: string | null
    journalId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalLikesMaxAggregateOutputType = {
    id: string | null
    journalId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalLikesCountAggregateOutputType = {
    id: number
    journalId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JournalLikesMinAggregateInputType = {
    id?: true
    journalId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalLikesMaxAggregateInputType = {
    id?: true
    journalId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalLikesCountAggregateInputType = {
    id?: true
    journalId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JournalLikesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalLikes to aggregate.
     */
    where?: JournalLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLikes to fetch.
     */
    orderBy?: JournalLikesOrderByWithRelationInput | JournalLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalLikes
    **/
    _count?: true | JournalLikesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalLikesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalLikesMaxAggregateInputType
  }

  export type GetJournalLikesAggregateType<T extends JournalLikesAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalLikes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalLikes[P]>
      : GetScalarType<T[P], AggregateJournalLikes[P]>
  }




  export type JournalLikesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalLikesWhereInput
    orderBy?: JournalLikesOrderByWithAggregationInput | JournalLikesOrderByWithAggregationInput[]
    by: JournalLikesScalarFieldEnum[] | JournalLikesScalarFieldEnum
    having?: JournalLikesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalLikesCountAggregateInputType | true
    _min?: JournalLikesMinAggregateInputType
    _max?: JournalLikesMaxAggregateInputType
  }

  export type JournalLikesGroupByOutputType = {
    id: string
    journalId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: JournalLikesCountAggregateOutputType | null
    _min: JournalLikesMinAggregateOutputType | null
    _max: JournalLikesMaxAggregateOutputType | null
  }

  type GetJournalLikesGroupByPayload<T extends JournalLikesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalLikesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalLikesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalLikesGroupByOutputType[P]>
            : GetScalarType<T[P], JournalLikesGroupByOutputType[P]>
        }
      >
    >


  export type JournalLikesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalLikes"]>

  export type JournalLikesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalLikes"]>

  export type JournalLikesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalLikes"]>

  export type JournalLikesSelectScalar = {
    id?: boolean
    journalId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JournalLikesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "journalId" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["journalLikes"]>
  export type JournalLikesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type JournalLikesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type JournalLikesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $JournalLikesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalLikes"
    objects: {
      Journals: Prisma.$JournalsPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      journalId: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["journalLikes"]>
    composites: {}
  }

  type JournalLikesGetPayload<S extends boolean | null | undefined | JournalLikesDefaultArgs> = $Result.GetResult<Prisma.$JournalLikesPayload, S>

  type JournalLikesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalLikesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalLikesCountAggregateInputType | true
    }

  export interface JournalLikesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalLikes'], meta: { name: 'JournalLikes' } }
    /**
     * Find zero or one JournalLikes that matches the filter.
     * @param {JournalLikesFindUniqueArgs} args - Arguments to find a JournalLikes
     * @example
     * // Get one JournalLikes
     * const journalLikes = await prisma.journalLikes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalLikesFindUniqueArgs>(args: SelectSubset<T, JournalLikesFindUniqueArgs<ExtArgs>>): Prisma__JournalLikesClient<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JournalLikes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalLikesFindUniqueOrThrowArgs} args - Arguments to find a JournalLikes
     * @example
     * // Get one JournalLikes
     * const journalLikes = await prisma.journalLikes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalLikesFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalLikesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalLikesClient<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLikesFindFirstArgs} args - Arguments to find a JournalLikes
     * @example
     * // Get one JournalLikes
     * const journalLikes = await prisma.journalLikes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalLikesFindFirstArgs>(args?: SelectSubset<T, JournalLikesFindFirstArgs<ExtArgs>>): Prisma__JournalLikesClient<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalLikes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLikesFindFirstOrThrowArgs} args - Arguments to find a JournalLikes
     * @example
     * // Get one JournalLikes
     * const journalLikes = await prisma.journalLikes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalLikesFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalLikesFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalLikesClient<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JournalLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLikesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalLikes
     * const journalLikes = await prisma.journalLikes.findMany()
     * 
     * // Get first 10 JournalLikes
     * const journalLikes = await prisma.journalLikes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalLikesWithIdOnly = await prisma.journalLikes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalLikesFindManyArgs>(args?: SelectSubset<T, JournalLikesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JournalLikes.
     * @param {JournalLikesCreateArgs} args - Arguments to create a JournalLikes.
     * @example
     * // Create one JournalLikes
     * const JournalLikes = await prisma.journalLikes.create({
     *   data: {
     *     // ... data to create a JournalLikes
     *   }
     * })
     * 
     */
    create<T extends JournalLikesCreateArgs>(args: SelectSubset<T, JournalLikesCreateArgs<ExtArgs>>): Prisma__JournalLikesClient<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JournalLikes.
     * @param {JournalLikesCreateManyArgs} args - Arguments to create many JournalLikes.
     * @example
     * // Create many JournalLikes
     * const journalLikes = await prisma.journalLikes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalLikesCreateManyArgs>(args?: SelectSubset<T, JournalLikesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalLikes and returns the data saved in the database.
     * @param {JournalLikesCreateManyAndReturnArgs} args - Arguments to create many JournalLikes.
     * @example
     * // Create many JournalLikes
     * const journalLikes = await prisma.journalLikes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalLikes and only return the `id`
     * const journalLikesWithIdOnly = await prisma.journalLikes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalLikesCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalLikesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JournalLikes.
     * @param {JournalLikesDeleteArgs} args - Arguments to delete one JournalLikes.
     * @example
     * // Delete one JournalLikes
     * const JournalLikes = await prisma.journalLikes.delete({
     *   where: {
     *     // ... filter to delete one JournalLikes
     *   }
     * })
     * 
     */
    delete<T extends JournalLikesDeleteArgs>(args: SelectSubset<T, JournalLikesDeleteArgs<ExtArgs>>): Prisma__JournalLikesClient<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JournalLikes.
     * @param {JournalLikesUpdateArgs} args - Arguments to update one JournalLikes.
     * @example
     * // Update one JournalLikes
     * const journalLikes = await prisma.journalLikes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalLikesUpdateArgs>(args: SelectSubset<T, JournalLikesUpdateArgs<ExtArgs>>): Prisma__JournalLikesClient<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JournalLikes.
     * @param {JournalLikesDeleteManyArgs} args - Arguments to filter JournalLikes to delete.
     * @example
     * // Delete a few JournalLikes
     * const { count } = await prisma.journalLikes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalLikesDeleteManyArgs>(args?: SelectSubset<T, JournalLikesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLikesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalLikes
     * const journalLikes = await prisma.journalLikes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalLikesUpdateManyArgs>(args: SelectSubset<T, JournalLikesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalLikes and returns the data updated in the database.
     * @param {JournalLikesUpdateManyAndReturnArgs} args - Arguments to update many JournalLikes.
     * @example
     * // Update many JournalLikes
     * const journalLikes = await prisma.journalLikes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JournalLikes and only return the `id`
     * const journalLikesWithIdOnly = await prisma.journalLikes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalLikesUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalLikesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JournalLikes.
     * @param {JournalLikesUpsertArgs} args - Arguments to update or create a JournalLikes.
     * @example
     * // Update or create a JournalLikes
     * const journalLikes = await prisma.journalLikes.upsert({
     *   create: {
     *     // ... data to create a JournalLikes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalLikes we want to update
     *   }
     * })
     */
    upsert<T extends JournalLikesUpsertArgs>(args: SelectSubset<T, JournalLikesUpsertArgs<ExtArgs>>): Prisma__JournalLikesClient<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JournalLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLikesCountArgs} args - Arguments to filter JournalLikes to count.
     * @example
     * // Count the number of JournalLikes
     * const count = await prisma.journalLikes.count({
     *   where: {
     *     // ... the filter for the JournalLikes we want to count
     *   }
     * })
    **/
    count<T extends JournalLikesCountArgs>(
      args?: Subset<T, JournalLikesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalLikesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLikesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalLikesAggregateArgs>(args: Subset<T, JournalLikesAggregateArgs>): Prisma.PrismaPromise<GetJournalLikesAggregateType<T>>

    /**
     * Group by JournalLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLikesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalLikesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalLikesGroupByArgs['orderBy'] }
        : { orderBy?: JournalLikesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalLikesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalLikesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalLikes model
   */
  readonly fields: JournalLikesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalLikes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalLikesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Journals<T extends JournalsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JournalsDefaultArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalLikes model
   */ 
  interface JournalLikesFieldRefs {
    readonly id: FieldRef<"JournalLikes", 'String'>
    readonly journalId: FieldRef<"JournalLikes", 'String'>
    readonly userId: FieldRef<"JournalLikes", 'String'>
    readonly createdAt: FieldRef<"JournalLikes", 'DateTime'>
    readonly updatedAt: FieldRef<"JournalLikes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JournalLikes findUnique
   */
  export type JournalLikesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesInclude<ExtArgs> | null
    /**
     * Filter, which JournalLikes to fetch.
     */
    where: JournalLikesWhereUniqueInput
  }

  /**
   * JournalLikes findUniqueOrThrow
   */
  export type JournalLikesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesInclude<ExtArgs> | null
    /**
     * Filter, which JournalLikes to fetch.
     */
    where: JournalLikesWhereUniqueInput
  }

  /**
   * JournalLikes findFirst
   */
  export type JournalLikesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesInclude<ExtArgs> | null
    /**
     * Filter, which JournalLikes to fetch.
     */
    where?: JournalLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLikes to fetch.
     */
    orderBy?: JournalLikesOrderByWithRelationInput | JournalLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalLikes.
     */
    cursor?: JournalLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalLikes.
     */
    distinct?: JournalLikesScalarFieldEnum | JournalLikesScalarFieldEnum[]
  }

  /**
   * JournalLikes findFirstOrThrow
   */
  export type JournalLikesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesInclude<ExtArgs> | null
    /**
     * Filter, which JournalLikes to fetch.
     */
    where?: JournalLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLikes to fetch.
     */
    orderBy?: JournalLikesOrderByWithRelationInput | JournalLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalLikes.
     */
    cursor?: JournalLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalLikes.
     */
    distinct?: JournalLikesScalarFieldEnum | JournalLikesScalarFieldEnum[]
  }

  /**
   * JournalLikes findMany
   */
  export type JournalLikesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesInclude<ExtArgs> | null
    /**
     * Filter, which JournalLikes to fetch.
     */
    where?: JournalLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLikes to fetch.
     */
    orderBy?: JournalLikesOrderByWithRelationInput | JournalLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalLikes.
     */
    cursor?: JournalLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLikes.
     */
    skip?: number
    distinct?: JournalLikesScalarFieldEnum | JournalLikesScalarFieldEnum[]
  }

  /**
   * JournalLikes create
   */
  export type JournalLikesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalLikes.
     */
    data: XOR<JournalLikesCreateInput, JournalLikesUncheckedCreateInput>
  }

  /**
   * JournalLikes createMany
   */
  export type JournalLikesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalLikes.
     */
    data: JournalLikesCreateManyInput | JournalLikesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalLikes createManyAndReturn
   */
  export type JournalLikesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * The data used to create many JournalLikes.
     */
    data: JournalLikesCreateManyInput | JournalLikesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalLikes update
   */
  export type JournalLikesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalLikes.
     */
    data: XOR<JournalLikesUpdateInput, JournalLikesUncheckedUpdateInput>
    /**
     * Choose, which JournalLikes to update.
     */
    where: JournalLikesWhereUniqueInput
  }

  /**
   * JournalLikes updateMany
   */
  export type JournalLikesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalLikes.
     */
    data: XOR<JournalLikesUpdateManyMutationInput, JournalLikesUncheckedUpdateManyInput>
    /**
     * Filter which JournalLikes to update
     */
    where?: JournalLikesWhereInput
    /**
     * Limit how many JournalLikes to update.
     */
    limit?: number
  }

  /**
   * JournalLikes updateManyAndReturn
   */
  export type JournalLikesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * The data used to update JournalLikes.
     */
    data: XOR<JournalLikesUpdateManyMutationInput, JournalLikesUncheckedUpdateManyInput>
    /**
     * Filter which JournalLikes to update
     */
    where?: JournalLikesWhereInput
    /**
     * Limit how many JournalLikes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalLikes upsert
   */
  export type JournalLikesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalLikes to update in case it exists.
     */
    where: JournalLikesWhereUniqueInput
    /**
     * In case the JournalLikes found by the `where` argument doesn't exist, create a new JournalLikes with this data.
     */
    create: XOR<JournalLikesCreateInput, JournalLikesUncheckedCreateInput>
    /**
     * In case the JournalLikes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalLikesUpdateInput, JournalLikesUncheckedUpdateInput>
  }

  /**
   * JournalLikes delete
   */
  export type JournalLikesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesInclude<ExtArgs> | null
    /**
     * Filter which JournalLikes to delete.
     */
    where: JournalLikesWhereUniqueInput
  }

  /**
   * JournalLikes deleteMany
   */
  export type JournalLikesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalLikes to delete
     */
    where?: JournalLikesWhereInput
    /**
     * Limit how many JournalLikes to delete.
     */
    limit?: number
  }

  /**
   * JournalLikes without action
   */
  export type JournalLikesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesInclude<ExtArgs> | null
  }


  /**
   * Model JournalRanks
   */

  export type AggregateJournalRanks = {
    _count: JournalRanksCountAggregateOutputType | null
    _avg: JournalRanksAvgAggregateOutputType | null
    _sum: JournalRanksSumAggregateOutputType | null
    _min: JournalRanksMinAggregateOutputType | null
    _max: JournalRanksMaxAggregateOutputType | null
  }

  export type JournalRanksAvgAggregateOutputType = {
    year: number | null
  }

  export type JournalRanksSumAggregateOutputType = {
    year: number | null
  }

  export type JournalRanksMinAggregateOutputType = {
    id: string | null
    year: number | null
    journalId: string | null
    fieldOfResearchId: string | null
    rankId: string | null
  }

  export type JournalRanksMaxAggregateOutputType = {
    id: string | null
    year: number | null
    journalId: string | null
    fieldOfResearchId: string | null
    rankId: string | null
  }

  export type JournalRanksCountAggregateOutputType = {
    id: number
    year: number
    journalId: number
    fieldOfResearchId: number
    rankId: number
    _all: number
  }


  export type JournalRanksAvgAggregateInputType = {
    year?: true
  }

  export type JournalRanksSumAggregateInputType = {
    year?: true
  }

  export type JournalRanksMinAggregateInputType = {
    id?: true
    year?: true
    journalId?: true
    fieldOfResearchId?: true
    rankId?: true
  }

  export type JournalRanksMaxAggregateInputType = {
    id?: true
    year?: true
    journalId?: true
    fieldOfResearchId?: true
    rankId?: true
  }

  export type JournalRanksCountAggregateInputType = {
    id?: true
    year?: true
    journalId?: true
    fieldOfResearchId?: true
    rankId?: true
    _all?: true
  }

  export type JournalRanksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalRanks to aggregate.
     */
    where?: JournalRanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalRanks to fetch.
     */
    orderBy?: JournalRanksOrderByWithRelationInput | JournalRanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalRanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalRanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalRanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalRanks
    **/
    _count?: true | JournalRanksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JournalRanksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JournalRanksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalRanksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalRanksMaxAggregateInputType
  }

  export type GetJournalRanksAggregateType<T extends JournalRanksAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalRanks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalRanks[P]>
      : GetScalarType<T[P], AggregateJournalRanks[P]>
  }




  export type JournalRanksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalRanksWhereInput
    orderBy?: JournalRanksOrderByWithAggregationInput | JournalRanksOrderByWithAggregationInput[]
    by: JournalRanksScalarFieldEnum[] | JournalRanksScalarFieldEnum
    having?: JournalRanksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalRanksCountAggregateInputType | true
    _avg?: JournalRanksAvgAggregateInputType
    _sum?: JournalRanksSumAggregateInputType
    _min?: JournalRanksMinAggregateInputType
    _max?: JournalRanksMaxAggregateInputType
  }

  export type JournalRanksGroupByOutputType = {
    id: string
    year: number
    journalId: string
    fieldOfResearchId: string
    rankId: string
    _count: JournalRanksCountAggregateOutputType | null
    _avg: JournalRanksAvgAggregateOutputType | null
    _sum: JournalRanksSumAggregateOutputType | null
    _min: JournalRanksMinAggregateOutputType | null
    _max: JournalRanksMaxAggregateOutputType | null
  }

  type GetJournalRanksGroupByPayload<T extends JournalRanksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalRanksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalRanksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalRanksGroupByOutputType[P]>
            : GetScalarType<T[P], JournalRanksGroupByOutputType[P]>
        }
      >
    >


  export type JournalRanksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    journalId?: boolean
    fieldOfResearchId?: boolean
    rankId?: boolean
    FieldOfResearchs?: boolean | FieldOfResearchsDefaultArgs<ExtArgs>
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
    Ranks?: boolean | RanksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalRanks"]>

  export type JournalRanksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    journalId?: boolean
    fieldOfResearchId?: boolean
    rankId?: boolean
    FieldOfResearchs?: boolean | FieldOfResearchsDefaultArgs<ExtArgs>
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
    Ranks?: boolean | RanksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalRanks"]>

  export type JournalRanksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    journalId?: boolean
    fieldOfResearchId?: boolean
    rankId?: boolean
    FieldOfResearchs?: boolean | FieldOfResearchsDefaultArgs<ExtArgs>
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
    Ranks?: boolean | RanksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalRanks"]>

  export type JournalRanksSelectScalar = {
    id?: boolean
    year?: boolean
    journalId?: boolean
    fieldOfResearchId?: boolean
    rankId?: boolean
  }

  export type JournalRanksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "year" | "journalId" | "fieldOfResearchId" | "rankId", ExtArgs["result"]["journalRanks"]>
  export type JournalRanksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FieldOfResearchs?: boolean | FieldOfResearchsDefaultArgs<ExtArgs>
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
    Ranks?: boolean | RanksDefaultArgs<ExtArgs>
  }
  export type JournalRanksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FieldOfResearchs?: boolean | FieldOfResearchsDefaultArgs<ExtArgs>
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
    Ranks?: boolean | RanksDefaultArgs<ExtArgs>
  }
  export type JournalRanksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FieldOfResearchs?: boolean | FieldOfResearchsDefaultArgs<ExtArgs>
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
    Ranks?: boolean | RanksDefaultArgs<ExtArgs>
  }

  export type $JournalRanksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalRanks"
    objects: {
      FieldOfResearchs: Prisma.$FieldOfResearchsPayload<ExtArgs>
      Journals: Prisma.$JournalsPayload<ExtArgs>
      Ranks: Prisma.$RanksPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      year: number
      journalId: string
      fieldOfResearchId: string
      rankId: string
    }, ExtArgs["result"]["journalRanks"]>
    composites: {}
  }

  type JournalRanksGetPayload<S extends boolean | null | undefined | JournalRanksDefaultArgs> = $Result.GetResult<Prisma.$JournalRanksPayload, S>

  type JournalRanksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalRanksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalRanksCountAggregateInputType | true
    }

  export interface JournalRanksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalRanks'], meta: { name: 'JournalRanks' } }
    /**
     * Find zero or one JournalRanks that matches the filter.
     * @param {JournalRanksFindUniqueArgs} args - Arguments to find a JournalRanks
     * @example
     * // Get one JournalRanks
     * const journalRanks = await prisma.journalRanks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalRanksFindUniqueArgs>(args: SelectSubset<T, JournalRanksFindUniqueArgs<ExtArgs>>): Prisma__JournalRanksClient<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JournalRanks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalRanksFindUniqueOrThrowArgs} args - Arguments to find a JournalRanks
     * @example
     * // Get one JournalRanks
     * const journalRanks = await prisma.journalRanks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalRanksFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalRanksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalRanksClient<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalRanks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalRanksFindFirstArgs} args - Arguments to find a JournalRanks
     * @example
     * // Get one JournalRanks
     * const journalRanks = await prisma.journalRanks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalRanksFindFirstArgs>(args?: SelectSubset<T, JournalRanksFindFirstArgs<ExtArgs>>): Prisma__JournalRanksClient<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalRanks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalRanksFindFirstOrThrowArgs} args - Arguments to find a JournalRanks
     * @example
     * // Get one JournalRanks
     * const journalRanks = await prisma.journalRanks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalRanksFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalRanksFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalRanksClient<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JournalRanks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalRanksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalRanks
     * const journalRanks = await prisma.journalRanks.findMany()
     * 
     * // Get first 10 JournalRanks
     * const journalRanks = await prisma.journalRanks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalRanksWithIdOnly = await prisma.journalRanks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalRanksFindManyArgs>(args?: SelectSubset<T, JournalRanksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JournalRanks.
     * @param {JournalRanksCreateArgs} args - Arguments to create a JournalRanks.
     * @example
     * // Create one JournalRanks
     * const JournalRanks = await prisma.journalRanks.create({
     *   data: {
     *     // ... data to create a JournalRanks
     *   }
     * })
     * 
     */
    create<T extends JournalRanksCreateArgs>(args: SelectSubset<T, JournalRanksCreateArgs<ExtArgs>>): Prisma__JournalRanksClient<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JournalRanks.
     * @param {JournalRanksCreateManyArgs} args - Arguments to create many JournalRanks.
     * @example
     * // Create many JournalRanks
     * const journalRanks = await prisma.journalRanks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalRanksCreateManyArgs>(args?: SelectSubset<T, JournalRanksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalRanks and returns the data saved in the database.
     * @param {JournalRanksCreateManyAndReturnArgs} args - Arguments to create many JournalRanks.
     * @example
     * // Create many JournalRanks
     * const journalRanks = await prisma.journalRanks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalRanks and only return the `id`
     * const journalRanksWithIdOnly = await prisma.journalRanks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalRanksCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalRanksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JournalRanks.
     * @param {JournalRanksDeleteArgs} args - Arguments to delete one JournalRanks.
     * @example
     * // Delete one JournalRanks
     * const JournalRanks = await prisma.journalRanks.delete({
     *   where: {
     *     // ... filter to delete one JournalRanks
     *   }
     * })
     * 
     */
    delete<T extends JournalRanksDeleteArgs>(args: SelectSubset<T, JournalRanksDeleteArgs<ExtArgs>>): Prisma__JournalRanksClient<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JournalRanks.
     * @param {JournalRanksUpdateArgs} args - Arguments to update one JournalRanks.
     * @example
     * // Update one JournalRanks
     * const journalRanks = await prisma.journalRanks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalRanksUpdateArgs>(args: SelectSubset<T, JournalRanksUpdateArgs<ExtArgs>>): Prisma__JournalRanksClient<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JournalRanks.
     * @param {JournalRanksDeleteManyArgs} args - Arguments to filter JournalRanks to delete.
     * @example
     * // Delete a few JournalRanks
     * const { count } = await prisma.journalRanks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalRanksDeleteManyArgs>(args?: SelectSubset<T, JournalRanksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalRanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalRanksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalRanks
     * const journalRanks = await prisma.journalRanks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalRanksUpdateManyArgs>(args: SelectSubset<T, JournalRanksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalRanks and returns the data updated in the database.
     * @param {JournalRanksUpdateManyAndReturnArgs} args - Arguments to update many JournalRanks.
     * @example
     * // Update many JournalRanks
     * const journalRanks = await prisma.journalRanks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JournalRanks and only return the `id`
     * const journalRanksWithIdOnly = await prisma.journalRanks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalRanksUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalRanksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JournalRanks.
     * @param {JournalRanksUpsertArgs} args - Arguments to update or create a JournalRanks.
     * @example
     * // Update or create a JournalRanks
     * const journalRanks = await prisma.journalRanks.upsert({
     *   create: {
     *     // ... data to create a JournalRanks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalRanks we want to update
     *   }
     * })
     */
    upsert<T extends JournalRanksUpsertArgs>(args: SelectSubset<T, JournalRanksUpsertArgs<ExtArgs>>): Prisma__JournalRanksClient<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JournalRanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalRanksCountArgs} args - Arguments to filter JournalRanks to count.
     * @example
     * // Count the number of JournalRanks
     * const count = await prisma.journalRanks.count({
     *   where: {
     *     // ... the filter for the JournalRanks we want to count
     *   }
     * })
    **/
    count<T extends JournalRanksCountArgs>(
      args?: Subset<T, JournalRanksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalRanksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalRanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalRanksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalRanksAggregateArgs>(args: Subset<T, JournalRanksAggregateArgs>): Prisma.PrismaPromise<GetJournalRanksAggregateType<T>>

    /**
     * Group by JournalRanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalRanksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalRanksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalRanksGroupByArgs['orderBy'] }
        : { orderBy?: JournalRanksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalRanksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalRanksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalRanks model
   */
  readonly fields: JournalRanksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalRanks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalRanksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    FieldOfResearchs<T extends FieldOfResearchsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FieldOfResearchsDefaultArgs<ExtArgs>>): Prisma__FieldOfResearchsClient<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Journals<T extends JournalsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JournalsDefaultArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Ranks<T extends RanksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RanksDefaultArgs<ExtArgs>>): Prisma__RanksClient<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalRanks model
   */ 
  interface JournalRanksFieldRefs {
    readonly id: FieldRef<"JournalRanks", 'String'>
    readonly year: FieldRef<"JournalRanks", 'Int'>
    readonly journalId: FieldRef<"JournalRanks", 'String'>
    readonly fieldOfResearchId: FieldRef<"JournalRanks", 'String'>
    readonly rankId: FieldRef<"JournalRanks", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JournalRanks findUnique
   */
  export type JournalRanksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
    /**
     * Filter, which JournalRanks to fetch.
     */
    where: JournalRanksWhereUniqueInput
  }

  /**
   * JournalRanks findUniqueOrThrow
   */
  export type JournalRanksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
    /**
     * Filter, which JournalRanks to fetch.
     */
    where: JournalRanksWhereUniqueInput
  }

  /**
   * JournalRanks findFirst
   */
  export type JournalRanksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
    /**
     * Filter, which JournalRanks to fetch.
     */
    where?: JournalRanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalRanks to fetch.
     */
    orderBy?: JournalRanksOrderByWithRelationInput | JournalRanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalRanks.
     */
    cursor?: JournalRanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalRanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalRanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalRanks.
     */
    distinct?: JournalRanksScalarFieldEnum | JournalRanksScalarFieldEnum[]
  }

  /**
   * JournalRanks findFirstOrThrow
   */
  export type JournalRanksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
    /**
     * Filter, which JournalRanks to fetch.
     */
    where?: JournalRanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalRanks to fetch.
     */
    orderBy?: JournalRanksOrderByWithRelationInput | JournalRanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalRanks.
     */
    cursor?: JournalRanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalRanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalRanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalRanks.
     */
    distinct?: JournalRanksScalarFieldEnum | JournalRanksScalarFieldEnum[]
  }

  /**
   * JournalRanks findMany
   */
  export type JournalRanksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
    /**
     * Filter, which JournalRanks to fetch.
     */
    where?: JournalRanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalRanks to fetch.
     */
    orderBy?: JournalRanksOrderByWithRelationInput | JournalRanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalRanks.
     */
    cursor?: JournalRanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalRanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalRanks.
     */
    skip?: number
    distinct?: JournalRanksScalarFieldEnum | JournalRanksScalarFieldEnum[]
  }

  /**
   * JournalRanks create
   */
  export type JournalRanksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalRanks.
     */
    data: XOR<JournalRanksCreateInput, JournalRanksUncheckedCreateInput>
  }

  /**
   * JournalRanks createMany
   */
  export type JournalRanksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalRanks.
     */
    data: JournalRanksCreateManyInput | JournalRanksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalRanks createManyAndReturn
   */
  export type JournalRanksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * The data used to create many JournalRanks.
     */
    data: JournalRanksCreateManyInput | JournalRanksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalRanks update
   */
  export type JournalRanksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalRanks.
     */
    data: XOR<JournalRanksUpdateInput, JournalRanksUncheckedUpdateInput>
    /**
     * Choose, which JournalRanks to update.
     */
    where: JournalRanksWhereUniqueInput
  }

  /**
   * JournalRanks updateMany
   */
  export type JournalRanksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalRanks.
     */
    data: XOR<JournalRanksUpdateManyMutationInput, JournalRanksUncheckedUpdateManyInput>
    /**
     * Filter which JournalRanks to update
     */
    where?: JournalRanksWhereInput
    /**
     * Limit how many JournalRanks to update.
     */
    limit?: number
  }

  /**
   * JournalRanks updateManyAndReturn
   */
  export type JournalRanksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * The data used to update JournalRanks.
     */
    data: XOR<JournalRanksUpdateManyMutationInput, JournalRanksUncheckedUpdateManyInput>
    /**
     * Filter which JournalRanks to update
     */
    where?: JournalRanksWhereInput
    /**
     * Limit how many JournalRanks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalRanks upsert
   */
  export type JournalRanksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalRanks to update in case it exists.
     */
    where: JournalRanksWhereUniqueInput
    /**
     * In case the JournalRanks found by the `where` argument doesn't exist, create a new JournalRanks with this data.
     */
    create: XOR<JournalRanksCreateInput, JournalRanksUncheckedCreateInput>
    /**
     * In case the JournalRanks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalRanksUpdateInput, JournalRanksUncheckedUpdateInput>
  }

  /**
   * JournalRanks delete
   */
  export type JournalRanksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
    /**
     * Filter which JournalRanks to delete.
     */
    where: JournalRanksWhereUniqueInput
  }

  /**
   * JournalRanks deleteMany
   */
  export type JournalRanksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalRanks to delete
     */
    where?: JournalRanksWhereInput
    /**
     * Limit how many JournalRanks to delete.
     */
    limit?: number
  }

  /**
   * JournalRanks without action
   */
  export type JournalRanksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
  }


  /**
   * Model JournalTopics
   */

  export type AggregateJournalTopics = {
    _count: JournalTopicsCountAggregateOutputType | null
    _min: JournalTopicsMinAggregateOutputType | null
    _max: JournalTopicsMaxAggregateOutputType | null
  }

  export type JournalTopicsMinAggregateOutputType = {
    id: string | null
    journalId: string | null
    topicId: string | null
  }

  export type JournalTopicsMaxAggregateOutputType = {
    id: string | null
    journalId: string | null
    topicId: string | null
  }

  export type JournalTopicsCountAggregateOutputType = {
    id: number
    journalId: number
    topicId: number
    _all: number
  }


  export type JournalTopicsMinAggregateInputType = {
    id?: true
    journalId?: true
    topicId?: true
  }

  export type JournalTopicsMaxAggregateInputType = {
    id?: true
    journalId?: true
    topicId?: true
  }

  export type JournalTopicsCountAggregateInputType = {
    id?: true
    journalId?: true
    topicId?: true
    _all?: true
  }

  export type JournalTopicsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalTopics to aggregate.
     */
    where?: JournalTopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalTopics to fetch.
     */
    orderBy?: JournalTopicsOrderByWithRelationInput | JournalTopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalTopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalTopics
    **/
    _count?: true | JournalTopicsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalTopicsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalTopicsMaxAggregateInputType
  }

  export type GetJournalTopicsAggregateType<T extends JournalTopicsAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalTopics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalTopics[P]>
      : GetScalarType<T[P], AggregateJournalTopics[P]>
  }




  export type JournalTopicsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalTopicsWhereInput
    orderBy?: JournalTopicsOrderByWithAggregationInput | JournalTopicsOrderByWithAggregationInput[]
    by: JournalTopicsScalarFieldEnum[] | JournalTopicsScalarFieldEnum
    having?: JournalTopicsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalTopicsCountAggregateInputType | true
    _min?: JournalTopicsMinAggregateInputType
    _max?: JournalTopicsMaxAggregateInputType
  }

  export type JournalTopicsGroupByOutputType = {
    id: string
    journalId: string
    topicId: string
    _count: JournalTopicsCountAggregateOutputType | null
    _min: JournalTopicsMinAggregateOutputType | null
    _max: JournalTopicsMaxAggregateOutputType | null
  }

  type GetJournalTopicsGroupByPayload<T extends JournalTopicsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalTopicsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalTopicsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalTopicsGroupByOutputType[P]>
            : GetScalarType<T[P], JournalTopicsGroupByOutputType[P]>
        }
      >
    >


  export type JournalTopicsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    topicId?: boolean
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
    Topics?: boolean | TopicsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalTopics"]>

  export type JournalTopicsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    topicId?: boolean
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
    Topics?: boolean | TopicsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalTopics"]>

  export type JournalTopicsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    topicId?: boolean
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
    Topics?: boolean | TopicsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalTopics"]>

  export type JournalTopicsSelectScalar = {
    id?: boolean
    journalId?: boolean
    topicId?: boolean
  }

  export type JournalTopicsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "journalId" | "topicId", ExtArgs["result"]["journalTopics"]>
  export type JournalTopicsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
    Topics?: boolean | TopicsDefaultArgs<ExtArgs>
  }
  export type JournalTopicsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
    Topics?: boolean | TopicsDefaultArgs<ExtArgs>
  }
  export type JournalTopicsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Journals?: boolean | JournalsDefaultArgs<ExtArgs>
    Topics?: boolean | TopicsDefaultArgs<ExtArgs>
  }

  export type $JournalTopicsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalTopics"
    objects: {
      Journals: Prisma.$JournalsPayload<ExtArgs>
      Topics: Prisma.$TopicsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      journalId: string
      topicId: string
    }, ExtArgs["result"]["journalTopics"]>
    composites: {}
  }

  type JournalTopicsGetPayload<S extends boolean | null | undefined | JournalTopicsDefaultArgs> = $Result.GetResult<Prisma.$JournalTopicsPayload, S>

  type JournalTopicsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalTopicsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalTopicsCountAggregateInputType | true
    }

  export interface JournalTopicsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalTopics'], meta: { name: 'JournalTopics' } }
    /**
     * Find zero or one JournalTopics that matches the filter.
     * @param {JournalTopicsFindUniqueArgs} args - Arguments to find a JournalTopics
     * @example
     * // Get one JournalTopics
     * const journalTopics = await prisma.journalTopics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalTopicsFindUniqueArgs>(args: SelectSubset<T, JournalTopicsFindUniqueArgs<ExtArgs>>): Prisma__JournalTopicsClient<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JournalTopics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalTopicsFindUniqueOrThrowArgs} args - Arguments to find a JournalTopics
     * @example
     * // Get one JournalTopics
     * const journalTopics = await prisma.journalTopics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalTopicsFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalTopicsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalTopicsClient<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalTopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalTopicsFindFirstArgs} args - Arguments to find a JournalTopics
     * @example
     * // Get one JournalTopics
     * const journalTopics = await prisma.journalTopics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalTopicsFindFirstArgs>(args?: SelectSubset<T, JournalTopicsFindFirstArgs<ExtArgs>>): Prisma__JournalTopicsClient<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalTopics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalTopicsFindFirstOrThrowArgs} args - Arguments to find a JournalTopics
     * @example
     * // Get one JournalTopics
     * const journalTopics = await prisma.journalTopics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalTopicsFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalTopicsFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalTopicsClient<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JournalTopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalTopicsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalTopics
     * const journalTopics = await prisma.journalTopics.findMany()
     * 
     * // Get first 10 JournalTopics
     * const journalTopics = await prisma.journalTopics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalTopicsWithIdOnly = await prisma.journalTopics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalTopicsFindManyArgs>(args?: SelectSubset<T, JournalTopicsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JournalTopics.
     * @param {JournalTopicsCreateArgs} args - Arguments to create a JournalTopics.
     * @example
     * // Create one JournalTopics
     * const JournalTopics = await prisma.journalTopics.create({
     *   data: {
     *     // ... data to create a JournalTopics
     *   }
     * })
     * 
     */
    create<T extends JournalTopicsCreateArgs>(args: SelectSubset<T, JournalTopicsCreateArgs<ExtArgs>>): Prisma__JournalTopicsClient<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JournalTopics.
     * @param {JournalTopicsCreateManyArgs} args - Arguments to create many JournalTopics.
     * @example
     * // Create many JournalTopics
     * const journalTopics = await prisma.journalTopics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalTopicsCreateManyArgs>(args?: SelectSubset<T, JournalTopicsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalTopics and returns the data saved in the database.
     * @param {JournalTopicsCreateManyAndReturnArgs} args - Arguments to create many JournalTopics.
     * @example
     * // Create many JournalTopics
     * const journalTopics = await prisma.journalTopics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalTopics and only return the `id`
     * const journalTopicsWithIdOnly = await prisma.journalTopics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalTopicsCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalTopicsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JournalTopics.
     * @param {JournalTopicsDeleteArgs} args - Arguments to delete one JournalTopics.
     * @example
     * // Delete one JournalTopics
     * const JournalTopics = await prisma.journalTopics.delete({
     *   where: {
     *     // ... filter to delete one JournalTopics
     *   }
     * })
     * 
     */
    delete<T extends JournalTopicsDeleteArgs>(args: SelectSubset<T, JournalTopicsDeleteArgs<ExtArgs>>): Prisma__JournalTopicsClient<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JournalTopics.
     * @param {JournalTopicsUpdateArgs} args - Arguments to update one JournalTopics.
     * @example
     * // Update one JournalTopics
     * const journalTopics = await prisma.journalTopics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalTopicsUpdateArgs>(args: SelectSubset<T, JournalTopicsUpdateArgs<ExtArgs>>): Prisma__JournalTopicsClient<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JournalTopics.
     * @param {JournalTopicsDeleteManyArgs} args - Arguments to filter JournalTopics to delete.
     * @example
     * // Delete a few JournalTopics
     * const { count } = await prisma.journalTopics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalTopicsDeleteManyArgs>(args?: SelectSubset<T, JournalTopicsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalTopicsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalTopics
     * const journalTopics = await prisma.journalTopics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalTopicsUpdateManyArgs>(args: SelectSubset<T, JournalTopicsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalTopics and returns the data updated in the database.
     * @param {JournalTopicsUpdateManyAndReturnArgs} args - Arguments to update many JournalTopics.
     * @example
     * // Update many JournalTopics
     * const journalTopics = await prisma.journalTopics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JournalTopics and only return the `id`
     * const journalTopicsWithIdOnly = await prisma.journalTopics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalTopicsUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalTopicsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JournalTopics.
     * @param {JournalTopicsUpsertArgs} args - Arguments to update or create a JournalTopics.
     * @example
     * // Update or create a JournalTopics
     * const journalTopics = await prisma.journalTopics.upsert({
     *   create: {
     *     // ... data to create a JournalTopics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalTopics we want to update
     *   }
     * })
     */
    upsert<T extends JournalTopicsUpsertArgs>(args: SelectSubset<T, JournalTopicsUpsertArgs<ExtArgs>>): Prisma__JournalTopicsClient<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JournalTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalTopicsCountArgs} args - Arguments to filter JournalTopics to count.
     * @example
     * // Count the number of JournalTopics
     * const count = await prisma.journalTopics.count({
     *   where: {
     *     // ... the filter for the JournalTopics we want to count
     *   }
     * })
    **/
    count<T extends JournalTopicsCountArgs>(
      args?: Subset<T, JournalTopicsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalTopicsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalTopicsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalTopicsAggregateArgs>(args: Subset<T, JournalTopicsAggregateArgs>): Prisma.PrismaPromise<GetJournalTopicsAggregateType<T>>

    /**
     * Group by JournalTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalTopicsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalTopicsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalTopicsGroupByArgs['orderBy'] }
        : { orderBy?: JournalTopicsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalTopicsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalTopicsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalTopics model
   */
  readonly fields: JournalTopicsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalTopics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalTopicsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Journals<T extends JournalsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JournalsDefaultArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Topics<T extends TopicsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TopicsDefaultArgs<ExtArgs>>): Prisma__TopicsClient<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalTopics model
   */ 
  interface JournalTopicsFieldRefs {
    readonly id: FieldRef<"JournalTopics", 'String'>
    readonly journalId: FieldRef<"JournalTopics", 'String'>
    readonly topicId: FieldRef<"JournalTopics", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JournalTopics findUnique
   */
  export type JournalTopicsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsInclude<ExtArgs> | null
    /**
     * Filter, which JournalTopics to fetch.
     */
    where: JournalTopicsWhereUniqueInput
  }

  /**
   * JournalTopics findUniqueOrThrow
   */
  export type JournalTopicsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsInclude<ExtArgs> | null
    /**
     * Filter, which JournalTopics to fetch.
     */
    where: JournalTopicsWhereUniqueInput
  }

  /**
   * JournalTopics findFirst
   */
  export type JournalTopicsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsInclude<ExtArgs> | null
    /**
     * Filter, which JournalTopics to fetch.
     */
    where?: JournalTopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalTopics to fetch.
     */
    orderBy?: JournalTopicsOrderByWithRelationInput | JournalTopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalTopics.
     */
    cursor?: JournalTopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalTopics.
     */
    distinct?: JournalTopicsScalarFieldEnum | JournalTopicsScalarFieldEnum[]
  }

  /**
   * JournalTopics findFirstOrThrow
   */
  export type JournalTopicsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsInclude<ExtArgs> | null
    /**
     * Filter, which JournalTopics to fetch.
     */
    where?: JournalTopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalTopics to fetch.
     */
    orderBy?: JournalTopicsOrderByWithRelationInput | JournalTopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalTopics.
     */
    cursor?: JournalTopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalTopics.
     */
    distinct?: JournalTopicsScalarFieldEnum | JournalTopicsScalarFieldEnum[]
  }

  /**
   * JournalTopics findMany
   */
  export type JournalTopicsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsInclude<ExtArgs> | null
    /**
     * Filter, which JournalTopics to fetch.
     */
    where?: JournalTopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalTopics to fetch.
     */
    orderBy?: JournalTopicsOrderByWithRelationInput | JournalTopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalTopics.
     */
    cursor?: JournalTopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalTopics.
     */
    skip?: number
    distinct?: JournalTopicsScalarFieldEnum | JournalTopicsScalarFieldEnum[]
  }

  /**
   * JournalTopics create
   */
  export type JournalTopicsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalTopics.
     */
    data: XOR<JournalTopicsCreateInput, JournalTopicsUncheckedCreateInput>
  }

  /**
   * JournalTopics createMany
   */
  export type JournalTopicsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalTopics.
     */
    data: JournalTopicsCreateManyInput | JournalTopicsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalTopics createManyAndReturn
   */
  export type JournalTopicsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * The data used to create many JournalTopics.
     */
    data: JournalTopicsCreateManyInput | JournalTopicsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalTopics update
   */
  export type JournalTopicsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalTopics.
     */
    data: XOR<JournalTopicsUpdateInput, JournalTopicsUncheckedUpdateInput>
    /**
     * Choose, which JournalTopics to update.
     */
    where: JournalTopicsWhereUniqueInput
  }

  /**
   * JournalTopics updateMany
   */
  export type JournalTopicsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalTopics.
     */
    data: XOR<JournalTopicsUpdateManyMutationInput, JournalTopicsUncheckedUpdateManyInput>
    /**
     * Filter which JournalTopics to update
     */
    where?: JournalTopicsWhereInput
    /**
     * Limit how many JournalTopics to update.
     */
    limit?: number
  }

  /**
   * JournalTopics updateManyAndReturn
   */
  export type JournalTopicsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * The data used to update JournalTopics.
     */
    data: XOR<JournalTopicsUpdateManyMutationInput, JournalTopicsUncheckedUpdateManyInput>
    /**
     * Filter which JournalTopics to update
     */
    where?: JournalTopicsWhereInput
    /**
     * Limit how many JournalTopics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalTopics upsert
   */
  export type JournalTopicsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalTopics to update in case it exists.
     */
    where: JournalTopicsWhereUniqueInput
    /**
     * In case the JournalTopics found by the `where` argument doesn't exist, create a new JournalTopics with this data.
     */
    create: XOR<JournalTopicsCreateInput, JournalTopicsUncheckedCreateInput>
    /**
     * In case the JournalTopics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalTopicsUpdateInput, JournalTopicsUncheckedUpdateInput>
  }

  /**
   * JournalTopics delete
   */
  export type JournalTopicsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsInclude<ExtArgs> | null
    /**
     * Filter which JournalTopics to delete.
     */
    where: JournalTopicsWhereUniqueInput
  }

  /**
   * JournalTopics deleteMany
   */
  export type JournalTopicsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalTopics to delete
     */
    where?: JournalTopicsWhereInput
    /**
     * Limit how many JournalTopics to delete.
     */
    limit?: number
  }

  /**
   * JournalTopics without action
   */
  export type JournalTopicsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsInclude<ExtArgs> | null
  }


  /**
   * Model Journals
   */

  export type AggregateJournals = {
    _count: JournalsCountAggregateOutputType | null
    _avg: JournalsAvgAggregateOutputType | null
    _sum: JournalsSumAggregateOutputType | null
    _min: JournalsMinAggregateOutputType | null
    _max: JournalsMaxAggregateOutputType | null
  }

  export type JournalsAvgAggregateOutputType = {
    hIndex: number | null
  }

  export type JournalsSumAggregateOutputType = {
    hIndex: number | null
  }

  export type JournalsMinAggregateOutputType = {
    id: string | null
    name: string | null
    issn: string | null
    hIndex: number | null
    publisher: string | null
    nation: string | null
    scope: string | null
    emailSubmission: string | null
    creator: string | null
  }

  export type JournalsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    issn: string | null
    hIndex: number | null
    publisher: string | null
    nation: string | null
    scope: string | null
    emailSubmission: string | null
    creator: string | null
  }

  export type JournalsCountAggregateOutputType = {
    id: number
    name: number
    issn: number
    hIndex: number
    publisher: number
    nation: number
    scope: number
    emailSubmission: number
    creator: number
    _all: number
  }


  export type JournalsAvgAggregateInputType = {
    hIndex?: true
  }

  export type JournalsSumAggregateInputType = {
    hIndex?: true
  }

  export type JournalsMinAggregateInputType = {
    id?: true
    name?: true
    issn?: true
    hIndex?: true
    publisher?: true
    nation?: true
    scope?: true
    emailSubmission?: true
    creator?: true
  }

  export type JournalsMaxAggregateInputType = {
    id?: true
    name?: true
    issn?: true
    hIndex?: true
    publisher?: true
    nation?: true
    scope?: true
    emailSubmission?: true
    creator?: true
  }

  export type JournalsCountAggregateInputType = {
    id?: true
    name?: true
    issn?: true
    hIndex?: true
    publisher?: true
    nation?: true
    scope?: true
    emailSubmission?: true
    creator?: true
    _all?: true
  }

  export type JournalsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Journals to aggregate.
     */
    where?: JournalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalsOrderByWithRelationInput | JournalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Journals
    **/
    _count?: true | JournalsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JournalsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JournalsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalsMaxAggregateInputType
  }

  export type GetJournalsAggregateType<T extends JournalsAggregateArgs> = {
        [P in keyof T & keyof AggregateJournals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournals[P]>
      : GetScalarType<T[P], AggregateJournals[P]>
  }




  export type JournalsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalsWhereInput
    orderBy?: JournalsOrderByWithAggregationInput | JournalsOrderByWithAggregationInput[]
    by: JournalsScalarFieldEnum[] | JournalsScalarFieldEnum
    having?: JournalsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalsCountAggregateInputType | true
    _avg?: JournalsAvgAggregateInputType
    _sum?: JournalsSumAggregateInputType
    _min?: JournalsMinAggregateInputType
    _max?: JournalsMaxAggregateInputType
  }

  export type JournalsGroupByOutputType = {
    id: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    creator: string
    _count: JournalsCountAggregateOutputType | null
    _avg: JournalsAvgAggregateOutputType | null
    _sum: JournalsSumAggregateOutputType | null
    _min: JournalsMinAggregateOutputType | null
    _max: JournalsMaxAggregateOutputType | null
  }

  type GetJournalsGroupByPayload<T extends JournalsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalsGroupByOutputType[P]>
            : GetScalarType<T[P], JournalsGroupByOutputType[P]>
        }
      >
    >


  export type JournalsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    issn?: boolean
    hIndex?: boolean
    publisher?: boolean
    nation?: boolean
    scope?: boolean
    emailSubmission?: boolean
    creator?: boolean
    JournalCrawlJobs?: boolean | Journals$JournalCrawlJobsArgs<ExtArgs>
    JournalFollows?: boolean | Journals$JournalFollowsArgs<ExtArgs>
    JournalLikes?: boolean | Journals$JournalLikesArgs<ExtArgs>
    JournalRanks?: boolean | Journals$JournalRanksArgs<ExtArgs>
    JournalTopics?: boolean | Journals$JournalTopicsArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    _count?: boolean | JournalsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journals"]>

  export type JournalsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    issn?: boolean
    hIndex?: boolean
    publisher?: boolean
    nation?: boolean
    scope?: boolean
    emailSubmission?: boolean
    creator?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journals"]>

  export type JournalsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    issn?: boolean
    hIndex?: boolean
    publisher?: boolean
    nation?: boolean
    scope?: boolean
    emailSubmission?: boolean
    creator?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journals"]>

  export type JournalsSelectScalar = {
    id?: boolean
    name?: boolean
    issn?: boolean
    hIndex?: boolean
    publisher?: boolean
    nation?: boolean
    scope?: boolean
    emailSubmission?: boolean
    creator?: boolean
  }

  export type JournalsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "issn" | "hIndex" | "publisher" | "nation" | "scope" | "emailSubmission" | "creator", ExtArgs["result"]["journals"]>
  export type JournalsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    JournalCrawlJobs?: boolean | Journals$JournalCrawlJobsArgs<ExtArgs>
    JournalFollows?: boolean | Journals$JournalFollowsArgs<ExtArgs>
    JournalLikes?: boolean | Journals$JournalLikesArgs<ExtArgs>
    JournalRanks?: boolean | Journals$JournalRanksArgs<ExtArgs>
    JournalTopics?: boolean | Journals$JournalTopicsArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    _count?: boolean | JournalsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JournalsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type JournalsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $JournalsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Journals"
    objects: {
      JournalCrawlJobs: Prisma.$JournalCrawlJobsPayload<ExtArgs>[]
      JournalFollows: Prisma.$JournalFollowsPayload<ExtArgs>[]
      JournalLikes: Prisma.$JournalLikesPayload<ExtArgs>[]
      JournalRanks: Prisma.$JournalRanksPayload<ExtArgs>[]
      JournalTopics: Prisma.$JournalTopicsPayload<ExtArgs>[]
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      issn: string
      hIndex: number
      publisher: string
      nation: string
      scope: string
      emailSubmission: string
      creator: string
    }, ExtArgs["result"]["journals"]>
    composites: {}
  }

  type JournalsGetPayload<S extends boolean | null | undefined | JournalsDefaultArgs> = $Result.GetResult<Prisma.$JournalsPayload, S>

  type JournalsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalsCountAggregateInputType | true
    }

  export interface JournalsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Journals'], meta: { name: 'Journals' } }
    /**
     * Find zero or one Journals that matches the filter.
     * @param {JournalsFindUniqueArgs} args - Arguments to find a Journals
     * @example
     * // Get one Journals
     * const journals = await prisma.journals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalsFindUniqueArgs>(args: SelectSubset<T, JournalsFindUniqueArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Journals that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalsFindUniqueOrThrowArgs} args - Arguments to find a Journals
     * @example
     * // Get one Journals
     * const journals = await prisma.journals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalsFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Journals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalsFindFirstArgs} args - Arguments to find a Journals
     * @example
     * // Get one Journals
     * const journals = await prisma.journals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalsFindFirstArgs>(args?: SelectSubset<T, JournalsFindFirstArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Journals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalsFindFirstOrThrowArgs} args - Arguments to find a Journals
     * @example
     * // Get one Journals
     * const journals = await prisma.journals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalsFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalsFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Journals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Journals
     * const journals = await prisma.journals.findMany()
     * 
     * // Get first 10 Journals
     * const journals = await prisma.journals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalsWithIdOnly = await prisma.journals.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalsFindManyArgs>(args?: SelectSubset<T, JournalsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Journals.
     * @param {JournalsCreateArgs} args - Arguments to create a Journals.
     * @example
     * // Create one Journals
     * const Journals = await prisma.journals.create({
     *   data: {
     *     // ... data to create a Journals
     *   }
     * })
     * 
     */
    create<T extends JournalsCreateArgs>(args: SelectSubset<T, JournalsCreateArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Journals.
     * @param {JournalsCreateManyArgs} args - Arguments to create many Journals.
     * @example
     * // Create many Journals
     * const journals = await prisma.journals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalsCreateManyArgs>(args?: SelectSubset<T, JournalsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Journals and returns the data saved in the database.
     * @param {JournalsCreateManyAndReturnArgs} args - Arguments to create many Journals.
     * @example
     * // Create many Journals
     * const journals = await prisma.journals.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Journals and only return the `id`
     * const journalsWithIdOnly = await prisma.journals.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalsCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Journals.
     * @param {JournalsDeleteArgs} args - Arguments to delete one Journals.
     * @example
     * // Delete one Journals
     * const Journals = await prisma.journals.delete({
     *   where: {
     *     // ... filter to delete one Journals
     *   }
     * })
     * 
     */
    delete<T extends JournalsDeleteArgs>(args: SelectSubset<T, JournalsDeleteArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Journals.
     * @param {JournalsUpdateArgs} args - Arguments to update one Journals.
     * @example
     * // Update one Journals
     * const journals = await prisma.journals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalsUpdateArgs>(args: SelectSubset<T, JournalsUpdateArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Journals.
     * @param {JournalsDeleteManyArgs} args - Arguments to filter Journals to delete.
     * @example
     * // Delete a few Journals
     * const { count } = await prisma.journals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalsDeleteManyArgs>(args?: SelectSubset<T, JournalsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Journals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Journals
     * const journals = await prisma.journals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalsUpdateManyArgs>(args: SelectSubset<T, JournalsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Journals and returns the data updated in the database.
     * @param {JournalsUpdateManyAndReturnArgs} args - Arguments to update many Journals.
     * @example
     * // Update many Journals
     * const journals = await prisma.journals.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Journals and only return the `id`
     * const journalsWithIdOnly = await prisma.journals.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalsUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Journals.
     * @param {JournalsUpsertArgs} args - Arguments to update or create a Journals.
     * @example
     * // Update or create a Journals
     * const journals = await prisma.journals.upsert({
     *   create: {
     *     // ... data to create a Journals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Journals we want to update
     *   }
     * })
     */
    upsert<T extends JournalsUpsertArgs>(args: SelectSubset<T, JournalsUpsertArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Journals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalsCountArgs} args - Arguments to filter Journals to count.
     * @example
     * // Count the number of Journals
     * const count = await prisma.journals.count({
     *   where: {
     *     // ... the filter for the Journals we want to count
     *   }
     * })
    **/
    count<T extends JournalsCountArgs>(
      args?: Subset<T, JournalsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Journals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalsAggregateArgs>(args: Subset<T, JournalsAggregateArgs>): Prisma.PrismaPromise<GetJournalsAggregateType<T>>

    /**
     * Group by Journals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalsGroupByArgs['orderBy'] }
        : { orderBy?: JournalsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Journals model
   */
  readonly fields: JournalsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Journals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    JournalCrawlJobs<T extends Journals$JournalCrawlJobsArgs<ExtArgs> = {}>(args?: Subset<T, Journals$JournalCrawlJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalCrawlJobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    JournalFollows<T extends Journals$JournalFollowsArgs<ExtArgs> = {}>(args?: Subset<T, Journals$JournalFollowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    JournalLikes<T extends Journals$JournalLikesArgs<ExtArgs> = {}>(args?: Subset<T, Journals$JournalLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    JournalRanks<T extends Journals$JournalRanksArgs<ExtArgs> = {}>(args?: Subset<T, Journals$JournalRanksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    JournalTopics<T extends Journals$JournalTopicsArgs<ExtArgs> = {}>(args?: Subset<T, Journals$JournalTopicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Journals model
   */ 
  interface JournalsFieldRefs {
    readonly id: FieldRef<"Journals", 'String'>
    readonly name: FieldRef<"Journals", 'String'>
    readonly issn: FieldRef<"Journals", 'String'>
    readonly hIndex: FieldRef<"Journals", 'Int'>
    readonly publisher: FieldRef<"Journals", 'String'>
    readonly nation: FieldRef<"Journals", 'String'>
    readonly scope: FieldRef<"Journals", 'String'>
    readonly emailSubmission: FieldRef<"Journals", 'String'>
    readonly creator: FieldRef<"Journals", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Journals findUnique
   */
  export type JournalsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsInclude<ExtArgs> | null
    /**
     * Filter, which Journals to fetch.
     */
    where: JournalsWhereUniqueInput
  }

  /**
   * Journals findUniqueOrThrow
   */
  export type JournalsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsInclude<ExtArgs> | null
    /**
     * Filter, which Journals to fetch.
     */
    where: JournalsWhereUniqueInput
  }

  /**
   * Journals findFirst
   */
  export type JournalsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsInclude<ExtArgs> | null
    /**
     * Filter, which Journals to fetch.
     */
    where?: JournalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalsOrderByWithRelationInput | JournalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Journals.
     */
    cursor?: JournalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Journals.
     */
    distinct?: JournalsScalarFieldEnum | JournalsScalarFieldEnum[]
  }

  /**
   * Journals findFirstOrThrow
   */
  export type JournalsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsInclude<ExtArgs> | null
    /**
     * Filter, which Journals to fetch.
     */
    where?: JournalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalsOrderByWithRelationInput | JournalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Journals.
     */
    cursor?: JournalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Journals.
     */
    distinct?: JournalsScalarFieldEnum | JournalsScalarFieldEnum[]
  }

  /**
   * Journals findMany
   */
  export type JournalsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsInclude<ExtArgs> | null
    /**
     * Filter, which Journals to fetch.
     */
    where?: JournalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalsOrderByWithRelationInput | JournalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Journals.
     */
    cursor?: JournalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    distinct?: JournalsScalarFieldEnum | JournalsScalarFieldEnum[]
  }

  /**
   * Journals create
   */
  export type JournalsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsInclude<ExtArgs> | null
    /**
     * The data needed to create a Journals.
     */
    data: XOR<JournalsCreateInput, JournalsUncheckedCreateInput>
  }

  /**
   * Journals createMany
   */
  export type JournalsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Journals.
     */
    data: JournalsCreateManyInput | JournalsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Journals createManyAndReturn
   */
  export type JournalsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * The data used to create many Journals.
     */
    data: JournalsCreateManyInput | JournalsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Journals update
   */
  export type JournalsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsInclude<ExtArgs> | null
    /**
     * The data needed to update a Journals.
     */
    data: XOR<JournalsUpdateInput, JournalsUncheckedUpdateInput>
    /**
     * Choose, which Journals to update.
     */
    where: JournalsWhereUniqueInput
  }

  /**
   * Journals updateMany
   */
  export type JournalsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Journals.
     */
    data: XOR<JournalsUpdateManyMutationInput, JournalsUncheckedUpdateManyInput>
    /**
     * Filter which Journals to update
     */
    where?: JournalsWhereInput
    /**
     * Limit how many Journals to update.
     */
    limit?: number
  }

  /**
   * Journals updateManyAndReturn
   */
  export type JournalsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * The data used to update Journals.
     */
    data: XOR<JournalsUpdateManyMutationInput, JournalsUncheckedUpdateManyInput>
    /**
     * Filter which Journals to update
     */
    where?: JournalsWhereInput
    /**
     * Limit how many Journals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Journals upsert
   */
  export type JournalsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsInclude<ExtArgs> | null
    /**
     * The filter to search for the Journals to update in case it exists.
     */
    where: JournalsWhereUniqueInput
    /**
     * In case the Journals found by the `where` argument doesn't exist, create a new Journals with this data.
     */
    create: XOR<JournalsCreateInput, JournalsUncheckedCreateInput>
    /**
     * In case the Journals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalsUpdateInput, JournalsUncheckedUpdateInput>
  }

  /**
   * Journals delete
   */
  export type JournalsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsInclude<ExtArgs> | null
    /**
     * Filter which Journals to delete.
     */
    where: JournalsWhereUniqueInput
  }

  /**
   * Journals deleteMany
   */
  export type JournalsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Journals to delete
     */
    where?: JournalsWhereInput
    /**
     * Limit how many Journals to delete.
     */
    limit?: number
  }

  /**
   * Journals.JournalCrawlJobs
   */
  export type Journals$JournalCrawlJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsInclude<ExtArgs> | null
    where?: JournalCrawlJobsWhereInput
    orderBy?: JournalCrawlJobsOrderByWithRelationInput | JournalCrawlJobsOrderByWithRelationInput[]
    cursor?: JournalCrawlJobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalCrawlJobsScalarFieldEnum | JournalCrawlJobsScalarFieldEnum[]
  }

  /**
   * Journals.JournalFollows
   */
  export type Journals$JournalFollowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsInclude<ExtArgs> | null
    where?: JournalFollowsWhereInput
    orderBy?: JournalFollowsOrderByWithRelationInput | JournalFollowsOrderByWithRelationInput[]
    cursor?: JournalFollowsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalFollowsScalarFieldEnum | JournalFollowsScalarFieldEnum[]
  }

  /**
   * Journals.JournalLikes
   */
  export type Journals$JournalLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesInclude<ExtArgs> | null
    where?: JournalLikesWhereInput
    orderBy?: JournalLikesOrderByWithRelationInput | JournalLikesOrderByWithRelationInput[]
    cursor?: JournalLikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalLikesScalarFieldEnum | JournalLikesScalarFieldEnum[]
  }

  /**
   * Journals.JournalRanks
   */
  export type Journals$JournalRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
    where?: JournalRanksWhereInput
    orderBy?: JournalRanksOrderByWithRelationInput | JournalRanksOrderByWithRelationInput[]
    cursor?: JournalRanksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalRanksScalarFieldEnum | JournalRanksScalarFieldEnum[]
  }

  /**
   * Journals.JournalTopics
   */
  export type Journals$JournalTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsInclude<ExtArgs> | null
    where?: JournalTopicsWhereInput
    orderBy?: JournalTopicsOrderByWithRelationInput | JournalTopicsOrderByWithRelationInput[]
    cursor?: JournalTopicsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalTopicsScalarFieldEnum | JournalTopicsScalarFieldEnum[]
  }

  /**
   * Journals without action
   */
  export type JournalsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsInclude<ExtArgs> | null
  }


  /**
   * Model Locations
   */

  export type AggregateLocations = {
    _count: LocationsCountAggregateOutputType | null
    _min: LocationsMinAggregateOutputType | null
    _max: LocationsMaxAggregateOutputType | null
  }

  export type LocationsMinAggregateOutputType = {
    id: string | null
    address: string | null
    cityStateProvince: string | null
    country: string | null
    continent: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isAvailable: boolean | null
    organizeId: string | null
  }

  export type LocationsMaxAggregateOutputType = {
    id: string | null
    address: string | null
    cityStateProvince: string | null
    country: string | null
    continent: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isAvailable: boolean | null
    organizeId: string | null
  }

  export type LocationsCountAggregateOutputType = {
    id: number
    address: number
    cityStateProvince: number
    country: number
    continent: number
    createdAt: number
    updatedAt: number
    isAvailable: number
    organizeId: number
    _all: number
  }


  export type LocationsMinAggregateInputType = {
    id?: true
    address?: true
    cityStateProvince?: true
    country?: true
    continent?: true
    createdAt?: true
    updatedAt?: true
    isAvailable?: true
    organizeId?: true
  }

  export type LocationsMaxAggregateInputType = {
    id?: true
    address?: true
    cityStateProvince?: true
    country?: true
    continent?: true
    createdAt?: true
    updatedAt?: true
    isAvailable?: true
    organizeId?: true
  }

  export type LocationsCountAggregateInputType = {
    id?: true
    address?: true
    cityStateProvince?: true
    country?: true
    continent?: true
    createdAt?: true
    updatedAt?: true
    isAvailable?: true
    organizeId?: true
    _all?: true
  }

  export type LocationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to aggregate.
     */
    where?: LocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationsOrderByWithRelationInput | LocationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationsMaxAggregateInputType
  }

  export type GetLocationsAggregateType<T extends LocationsAggregateArgs> = {
        [P in keyof T & keyof AggregateLocations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocations[P]>
      : GetScalarType<T[P], AggregateLocations[P]>
  }




  export type LocationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationsWhereInput
    orderBy?: LocationsOrderByWithAggregationInput | LocationsOrderByWithAggregationInput[]
    by: LocationsScalarFieldEnum[] | LocationsScalarFieldEnum
    having?: LocationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationsCountAggregateInputType | true
    _min?: LocationsMinAggregateInputType
    _max?: LocationsMaxAggregateInputType
  }

  export type LocationsGroupByOutputType = {
    id: string
    address: string | null
    cityStateProvince: string | null
    country: string | null
    continent: string | null
    createdAt: Date
    updatedAt: Date
    isAvailable: boolean
    organizeId: string
    _count: LocationsCountAggregateOutputType | null
    _min: LocationsMinAggregateOutputType | null
    _max: LocationsMaxAggregateOutputType | null
  }

  type GetLocationsGroupByPayload<T extends LocationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationsGroupByOutputType[P]>
            : GetScalarType<T[P], LocationsGroupByOutputType[P]>
        }
      >
    >


  export type LocationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    cityStateProvince?: boolean
    country?: boolean
    continent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAvailable?: boolean
    organizeId?: boolean
    ConferenceOrganizations?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locations"]>

  export type LocationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    cityStateProvince?: boolean
    country?: boolean
    continent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAvailable?: boolean
    organizeId?: boolean
    ConferenceOrganizations?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locations"]>

  export type LocationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    cityStateProvince?: boolean
    country?: boolean
    continent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAvailable?: boolean
    organizeId?: boolean
    ConferenceOrganizations?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locations"]>

  export type LocationsSelectScalar = {
    id?: boolean
    address?: boolean
    cityStateProvince?: boolean
    country?: boolean
    continent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAvailable?: boolean
    organizeId?: boolean
  }

  export type LocationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "address" | "cityStateProvince" | "country" | "continent" | "createdAt" | "updatedAt" | "isAvailable" | "organizeId", ExtArgs["result"]["locations"]>
  export type LocationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConferenceOrganizations?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
  }
  export type LocationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConferenceOrganizations?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
  }
  export type LocationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConferenceOrganizations?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
  }

  export type $LocationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Locations"
    objects: {
      ConferenceOrganizations: Prisma.$ConferenceOrganizationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      address: string | null
      cityStateProvince: string | null
      country: string | null
      continent: string | null
      createdAt: Date
      updatedAt: Date
      isAvailable: boolean
      organizeId: string
    }, ExtArgs["result"]["locations"]>
    composites: {}
  }

  type LocationsGetPayload<S extends boolean | null | undefined | LocationsDefaultArgs> = $Result.GetResult<Prisma.$LocationsPayload, S>

  type LocationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationsCountAggregateInputType | true
    }

  export interface LocationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Locations'], meta: { name: 'Locations' } }
    /**
     * Find zero or one Locations that matches the filter.
     * @param {LocationsFindUniqueArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationsFindUniqueArgs>(args: SelectSubset<T, LocationsFindUniqueArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Locations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationsFindUniqueOrThrowArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationsFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsFindFirstArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationsFindFirstArgs>(args?: SelectSubset<T, LocationsFindFirstArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Locations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsFindFirstOrThrowArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationsFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.locations.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.locations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationsWithIdOnly = await prisma.locations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationsFindManyArgs>(args?: SelectSubset<T, LocationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Locations.
     * @param {LocationsCreateArgs} args - Arguments to create a Locations.
     * @example
     * // Create one Locations
     * const Locations = await prisma.locations.create({
     *   data: {
     *     // ... data to create a Locations
     *   }
     * })
     * 
     */
    create<T extends LocationsCreateArgs>(args: SelectSubset<T, LocationsCreateArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationsCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const locations = await prisma.locations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationsCreateManyArgs>(args?: SelectSubset<T, LocationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationsCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const locations = await prisma.locations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationsWithIdOnly = await prisma.locations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationsCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Locations.
     * @param {LocationsDeleteArgs} args - Arguments to delete one Locations.
     * @example
     * // Delete one Locations
     * const Locations = await prisma.locations.delete({
     *   where: {
     *     // ... filter to delete one Locations
     *   }
     * })
     * 
     */
    delete<T extends LocationsDeleteArgs>(args: SelectSubset<T, LocationsDeleteArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Locations.
     * @param {LocationsUpdateArgs} args - Arguments to update one Locations.
     * @example
     * // Update one Locations
     * const locations = await prisma.locations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationsUpdateArgs>(args: SelectSubset<T, LocationsUpdateArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationsDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.locations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationsDeleteManyArgs>(args?: SelectSubset<T, LocationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const locations = await prisma.locations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationsUpdateManyArgs>(args: SelectSubset<T, LocationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationsUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const locations = await prisma.locations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationsWithIdOnly = await prisma.locations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationsUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Locations.
     * @param {LocationsUpsertArgs} args - Arguments to update or create a Locations.
     * @example
     * // Update or create a Locations
     * const locations = await prisma.locations.upsert({
     *   create: {
     *     // ... data to create a Locations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Locations we want to update
     *   }
     * })
     */
    upsert<T extends LocationsUpsertArgs>(args: SelectSubset<T, LocationsUpsertArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.locations.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationsCountArgs>(
      args?: Subset<T, LocationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationsAggregateArgs>(args: Subset<T, LocationsAggregateArgs>): Prisma.PrismaPromise<GetLocationsAggregateType<T>>

    /**
     * Group by Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationsGroupByArgs['orderBy'] }
        : { orderBy?: LocationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Locations model
   */
  readonly fields: LocationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Locations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ConferenceOrganizations<T extends ConferenceOrganizationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferenceOrganizationsDefaultArgs<ExtArgs>>): Prisma__ConferenceOrganizationsClient<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Locations model
   */ 
  interface LocationsFieldRefs {
    readonly id: FieldRef<"Locations", 'String'>
    readonly address: FieldRef<"Locations", 'String'>
    readonly cityStateProvince: FieldRef<"Locations", 'String'>
    readonly country: FieldRef<"Locations", 'String'>
    readonly continent: FieldRef<"Locations", 'String'>
    readonly createdAt: FieldRef<"Locations", 'DateTime'>
    readonly updatedAt: FieldRef<"Locations", 'DateTime'>
    readonly isAvailable: FieldRef<"Locations", 'Boolean'>
    readonly organizeId: FieldRef<"Locations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Locations findUnique
   */
  export type LocationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where: LocationsWhereUniqueInput
  }

  /**
   * Locations findUniqueOrThrow
   */
  export type LocationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where: LocationsWhereUniqueInput
  }

  /**
   * Locations findFirst
   */
  export type LocationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationsOrderByWithRelationInput | LocationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * Locations findFirstOrThrow
   */
  export type LocationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationsOrderByWithRelationInput | LocationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * Locations findMany
   */
  export type LocationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationsOrderByWithRelationInput | LocationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * Locations create
   */
  export type LocationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * The data needed to create a Locations.
     */
    data: XOR<LocationsCreateInput, LocationsUncheckedCreateInput>
  }

  /**
   * Locations createMany
   */
  export type LocationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationsCreateManyInput | LocationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Locations createManyAndReturn
   */
  export type LocationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationsCreateManyInput | LocationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Locations update
   */
  export type LocationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * The data needed to update a Locations.
     */
    data: XOR<LocationsUpdateInput, LocationsUncheckedUpdateInput>
    /**
     * Choose, which Locations to update.
     */
    where: LocationsWhereUniqueInput
  }

  /**
   * Locations updateMany
   */
  export type LocationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationsUpdateManyMutationInput, LocationsUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationsWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Locations updateManyAndReturn
   */
  export type LocationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationsUpdateManyMutationInput, LocationsUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationsWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Locations upsert
   */
  export type LocationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * The filter to search for the Locations to update in case it exists.
     */
    where: LocationsWhereUniqueInput
    /**
     * In case the Locations found by the `where` argument doesn't exist, create a new Locations with this data.
     */
    create: XOR<LocationsCreateInput, LocationsUncheckedCreateInput>
    /**
     * In case the Locations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationsUpdateInput, LocationsUncheckedUpdateInput>
  }

  /**
   * Locations delete
   */
  export type LocationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * Filter which Locations to delete.
     */
    where: LocationsWhereUniqueInput
  }

  /**
   * Locations deleteMany
   */
  export type LocationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationsWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Locations without action
   */
  export type LocationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
  }


  /**
   * Model NotificationSettings
   */

  export type AggregateNotificationSettings = {
    _count: NotificationSettingsCountAggregateOutputType | null
    _min: NotificationSettingsMinAggregateOutputType | null
    _max: NotificationSettingsMaxAggregateOutputType | null
  }

  export type NotificationSettingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    notificationId: string | null
    isEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationSettingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    notificationId: string | null
    isEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationSettingsCountAggregateOutputType = {
    id: number
    userId: number
    notificationId: number
    isEnabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationSettingsMinAggregateInputType = {
    id?: true
    userId?: true
    notificationId?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationSettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    notificationId?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationSettingsCountAggregateInputType = {
    id?: true
    userId?: true
    notificationId?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSettings to aggregate.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationSettings
    **/
    _count?: true | NotificationSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationSettingsMaxAggregateInputType
  }

  export type GetNotificationSettingsAggregateType<T extends NotificationSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationSettings[P]>
      : GetScalarType<T[P], AggregateNotificationSettings[P]>
  }




  export type NotificationSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationSettingsWhereInput
    orderBy?: NotificationSettingsOrderByWithAggregationInput | NotificationSettingsOrderByWithAggregationInput[]
    by: NotificationSettingsScalarFieldEnum[] | NotificationSettingsScalarFieldEnum
    having?: NotificationSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationSettingsCountAggregateInputType | true
    _min?: NotificationSettingsMinAggregateInputType
    _max?: NotificationSettingsMaxAggregateInputType
  }

  export type NotificationSettingsGroupByOutputType = {
    id: string
    userId: string
    notificationId: string
    isEnabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationSettingsCountAggregateOutputType | null
    _min: NotificationSettingsMinAggregateOutputType | null
    _max: NotificationSettingsMaxAggregateOutputType | null
  }

  type GetNotificationSettingsGroupByPayload<T extends NotificationSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationSettingsGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    notificationId?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    NotificationsTypes?: boolean | NotificationsTypesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    notificationId?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    NotificationsTypes?: boolean | NotificationsTypesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    notificationId?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    NotificationsTypes?: boolean | NotificationsTypesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectScalar = {
    id?: boolean
    userId?: boolean
    notificationId?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "notificationId" | "isEnabled" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationSettings"]>
  export type NotificationSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    NotificationsTypes?: boolean | NotificationsTypesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type NotificationSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    NotificationsTypes?: boolean | NotificationsTypesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type NotificationSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    NotificationsTypes?: boolean | NotificationsTypesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $NotificationSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationSettings"
    objects: {
      NotificationsTypes: Prisma.$NotificationsTypesPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      notificationId: string
      isEnabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationSettings"]>
    composites: {}
  }

  type NotificationSettingsGetPayload<S extends boolean | null | undefined | NotificationSettingsDefaultArgs> = $Result.GetResult<Prisma.$NotificationSettingsPayload, S>

  type NotificationSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationSettingsCountAggregateInputType | true
    }

  export interface NotificationSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationSettings'], meta: { name: 'NotificationSettings' } }
    /**
     * Find zero or one NotificationSettings that matches the filter.
     * @param {NotificationSettingsFindUniqueArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationSettingsFindUniqueArgs>(args: SelectSubset<T, NotificationSettingsFindUniqueArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationSettingsFindUniqueOrThrowArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindFirstArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationSettingsFindFirstArgs>(args?: SelectSubset<T, NotificationSettingsFindFirstArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindFirstOrThrowArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findMany()
     * 
     * // Get first 10 NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationSettingsWithIdOnly = await prisma.notificationSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationSettingsFindManyArgs>(args?: SelectSubset<T, NotificationSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationSettings.
     * @param {NotificationSettingsCreateArgs} args - Arguments to create a NotificationSettings.
     * @example
     * // Create one NotificationSettings
     * const NotificationSettings = await prisma.notificationSettings.create({
     *   data: {
     *     // ... data to create a NotificationSettings
     *   }
     * })
     * 
     */
    create<T extends NotificationSettingsCreateArgs>(args: SelectSubset<T, NotificationSettingsCreateArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationSettings.
     * @param {NotificationSettingsCreateManyArgs} args - Arguments to create many NotificationSettings.
     * @example
     * // Create many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationSettingsCreateManyArgs>(args?: SelectSubset<T, NotificationSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationSettings and returns the data saved in the database.
     * @param {NotificationSettingsCreateManyAndReturnArgs} args - Arguments to create many NotificationSettings.
     * @example
     * // Create many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationSettings and only return the `id`
     * const notificationSettingsWithIdOnly = await prisma.notificationSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationSettings.
     * @param {NotificationSettingsDeleteArgs} args - Arguments to delete one NotificationSettings.
     * @example
     * // Delete one NotificationSettings
     * const NotificationSettings = await prisma.notificationSettings.delete({
     *   where: {
     *     // ... filter to delete one NotificationSettings
     *   }
     * })
     * 
     */
    delete<T extends NotificationSettingsDeleteArgs>(args: SelectSubset<T, NotificationSettingsDeleteArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationSettings.
     * @param {NotificationSettingsUpdateArgs} args - Arguments to update one NotificationSettings.
     * @example
     * // Update one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationSettingsUpdateArgs>(args: SelectSubset<T, NotificationSettingsUpdateArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationSettings.
     * @param {NotificationSettingsDeleteManyArgs} args - Arguments to filter NotificationSettings to delete.
     * @example
     * // Delete a few NotificationSettings
     * const { count } = await prisma.notificationSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationSettingsDeleteManyArgs>(args?: SelectSubset<T, NotificationSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationSettingsUpdateManyArgs>(args: SelectSubset<T, NotificationSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationSettings and returns the data updated in the database.
     * @param {NotificationSettingsUpdateManyAndReturnArgs} args - Arguments to update many NotificationSettings.
     * @example
     * // Update many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationSettings and only return the `id`
     * const notificationSettingsWithIdOnly = await prisma.notificationSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationSettings.
     * @param {NotificationSettingsUpsertArgs} args - Arguments to update or create a NotificationSettings.
     * @example
     * // Update or create a NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.upsert({
     *   create: {
     *     // ... data to create a NotificationSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationSettings we want to update
     *   }
     * })
     */
    upsert<T extends NotificationSettingsUpsertArgs>(args: SelectSubset<T, NotificationSettingsUpsertArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsCountArgs} args - Arguments to filter NotificationSettings to count.
     * @example
     * // Count the number of NotificationSettings
     * const count = await prisma.notificationSettings.count({
     *   where: {
     *     // ... the filter for the NotificationSettings we want to count
     *   }
     * })
    **/
    count<T extends NotificationSettingsCountArgs>(
      args?: Subset<T, NotificationSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationSettingsAggregateArgs>(args: Subset<T, NotificationSettingsAggregateArgs>): Prisma.PrismaPromise<GetNotificationSettingsAggregateType<T>>

    /**
     * Group by NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationSettingsGroupByArgs['orderBy'] }
        : { orderBy?: NotificationSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationSettings model
   */
  readonly fields: NotificationSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    NotificationsTypes<T extends NotificationsTypesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NotificationsTypesDefaultArgs<ExtArgs>>): Prisma__NotificationsTypesClient<$Result.GetResult<Prisma.$NotificationsTypesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationSettings model
   */ 
  interface NotificationSettingsFieldRefs {
    readonly id: FieldRef<"NotificationSettings", 'String'>
    readonly userId: FieldRef<"NotificationSettings", 'String'>
    readonly notificationId: FieldRef<"NotificationSettings", 'String'>
    readonly isEnabled: FieldRef<"NotificationSettings", 'Boolean'>
    readonly createdAt: FieldRef<"NotificationSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationSettings findUnique
   */
  export type NotificationSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings findUniqueOrThrow
   */
  export type NotificationSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings findFirst
   */
  export type NotificationSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSettings.
     */
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings findFirstOrThrow
   */
  export type NotificationSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSettings.
     */
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings findMany
   */
  export type NotificationSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings create
   */
  export type NotificationSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationSettings.
     */
    data: XOR<NotificationSettingsCreateInput, NotificationSettingsUncheckedCreateInput>
  }

  /**
   * NotificationSettings createMany
   */
  export type NotificationSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationSettings.
     */
    data: NotificationSettingsCreateManyInput | NotificationSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationSettings createManyAndReturn
   */
  export type NotificationSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationSettings.
     */
    data: NotificationSettingsCreateManyInput | NotificationSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationSettings update
   */
  export type NotificationSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateInput, NotificationSettingsUncheckedUpdateInput>
    /**
     * Choose, which NotificationSettings to update.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings updateMany
   */
  export type NotificationSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateManyMutationInput, NotificationSettingsUncheckedUpdateManyInput>
    /**
     * Filter which NotificationSettings to update
     */
    where?: NotificationSettingsWhereInput
    /**
     * Limit how many NotificationSettings to update.
     */
    limit?: number
  }

  /**
   * NotificationSettings updateManyAndReturn
   */
  export type NotificationSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * The data used to update NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateManyMutationInput, NotificationSettingsUncheckedUpdateManyInput>
    /**
     * Filter which NotificationSettings to update
     */
    where?: NotificationSettingsWhereInput
    /**
     * Limit how many NotificationSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationSettings upsert
   */
  export type NotificationSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationSettings to update in case it exists.
     */
    where: NotificationSettingsWhereUniqueInput
    /**
     * In case the NotificationSettings found by the `where` argument doesn't exist, create a new NotificationSettings with this data.
     */
    create: XOR<NotificationSettingsCreateInput, NotificationSettingsUncheckedCreateInput>
    /**
     * In case the NotificationSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationSettingsUpdateInput, NotificationSettingsUncheckedUpdateInput>
  }

  /**
   * NotificationSettings delete
   */
  export type NotificationSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter which NotificationSettings to delete.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings deleteMany
   */
  export type NotificationSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSettings to delete
     */
    where?: NotificationSettingsWhereInput
    /**
     * Limit how many NotificationSettings to delete.
     */
    limit?: number
  }

  /**
   * NotificationSettings without action
   */
  export type NotificationSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
  }


  /**
   * Model Notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: string | null
    notificationId: string | null
    userId: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: string | null
    notificationId: string | null
    userId: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    notificationId: number
    userId: number
    message: number
    isRead: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationsMinAggregateInputType = {
    id?: true
    notificationId?: true
    userId?: true
    message?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    notificationId?: true
    userId?: true
    message?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    notificationId?: true
    userId?: true
    message?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to aggregate.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type NotificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationsWhereInput
    orderBy?: NotificationsOrderByWithAggregationInput | NotificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: NotificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: string
    notificationId: string
    userId: string
    message: string
    isRead: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends NotificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type NotificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    userId?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    NotificationsTypes?: boolean | NotificationsTypesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type NotificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    userId?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    NotificationsTypes?: boolean | NotificationsTypesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type NotificationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    userId?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    NotificationsTypes?: boolean | NotificationsTypesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type NotificationsSelectScalar = {
    id?: boolean
    notificationId?: boolean
    userId?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "notificationId" | "userId" | "message" | "isRead" | "createdAt" | "updatedAt", ExtArgs["result"]["notifications"]>
  export type NotificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    NotificationsTypes?: boolean | NotificationsTypesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type NotificationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    NotificationsTypes?: boolean | NotificationsTypesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type NotificationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    NotificationsTypes?: boolean | NotificationsTypesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $NotificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notifications"
    objects: {
      NotificationsTypes: Prisma.$NotificationsTypesPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      notificationId: string
      userId: string
      message: string
      isRead: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type NotificationsGetPayload<S extends boolean | null | undefined | NotificationsDefaultArgs> = $Result.GetResult<Prisma.$NotificationsPayload, S>

  type NotificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface NotificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notifications'], meta: { name: 'Notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {NotificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationsFindUniqueArgs>(args: SelectSubset<T, NotificationsFindUniqueArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationsFindFirstArgs>(args?: SelectSubset<T, NotificationsFindFirstArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationsFindManyArgs>(args?: SelectSubset<T, NotificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notifications.
     * @param {NotificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends NotificationsCreateArgs>(args: SelectSubset<T, NotificationsCreateArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationsCreateManyArgs>(args?: SelectSubset<T, NotificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationsCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notifications.
     * @param {NotificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends NotificationsDeleteArgs>(args: SelectSubset<T, NotificationsDeleteArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notifications.
     * @param {NotificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationsUpdateArgs>(args: SelectSubset<T, NotificationsUpdateArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationsDeleteManyArgs>(args?: SelectSubset<T, NotificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationsUpdateManyArgs>(args: SelectSubset<T, NotificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationsUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationsUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notifications.
     * @param {NotificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends NotificationsUpsertArgs>(args: SelectSubset<T, NotificationsUpsertArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationsCountArgs>(
      args?: Subset<T, NotificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationsGroupByArgs['orderBy'] }
        : { orderBy?: NotificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notifications model
   */
  readonly fields: NotificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    NotificationsTypes<T extends NotificationsTypesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NotificationsTypesDefaultArgs<ExtArgs>>): Prisma__NotificationsTypesClient<$Result.GetResult<Prisma.$NotificationsTypesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notifications model
   */ 
  interface NotificationsFieldRefs {
    readonly id: FieldRef<"Notifications", 'String'>
    readonly notificationId: FieldRef<"Notifications", 'String'>
    readonly userId: FieldRef<"Notifications", 'String'>
    readonly message: FieldRef<"Notifications", 'String'>
    readonly isRead: FieldRef<"Notifications", 'Boolean'>
    readonly createdAt: FieldRef<"Notifications", 'DateTime'>
    readonly updatedAt: FieldRef<"Notifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notifications findUnique
   */
  export type NotificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications findUniqueOrThrow
   */
  export type NotificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications findFirst
   */
  export type NotificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Notifications findFirstOrThrow
   */
  export type NotificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Notifications findMany
   */
  export type NotificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Notifications create
   */
  export type NotificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a Notifications.
     */
    data: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>
  }

  /**
   * Notifications createMany
   */
  export type NotificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationsCreateManyInput | NotificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notifications createManyAndReturn
   */
  export type NotificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationsCreateManyInput | NotificationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notifications update
   */
  export type NotificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a Notifications.
     */
    data: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>
    /**
     * Choose, which Notifications to update.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications updateMany
   */
  export type NotificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationsWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notifications updateManyAndReturn
   */
  export type NotificationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationsWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notifications upsert
   */
  export type NotificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the Notifications to update in case it exists.
     */
    where: NotificationsWhereUniqueInput
    /**
     * In case the Notifications found by the `where` argument doesn't exist, create a new Notifications with this data.
     */
    create: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>
    /**
     * In case the Notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>
  }

  /**
   * Notifications delete
   */
  export type NotificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter which Notifications to delete.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications deleteMany
   */
  export type NotificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationsWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notifications without action
   */
  export type NotificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
  }


  /**
   * Model NotificationsTypes
   */

  export type AggregateNotificationsTypes = {
    _count: NotificationsTypesCountAggregateOutputType | null
    _min: NotificationsTypesMinAggregateOutputType | null
    _max: NotificationsTypesMaxAggregateOutputType | null
  }

  export type NotificationsTypesMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationsTypesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationsTypesCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationsTypesMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationsTypesMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationsTypesCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationsTypesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationsTypes to aggregate.
     */
    where?: NotificationsTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationsTypes to fetch.
     */
    orderBy?: NotificationsTypesOrderByWithRelationInput | NotificationsTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationsTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationsTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationsTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationsTypes
    **/
    _count?: true | NotificationsTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsTypesMaxAggregateInputType
  }

  export type GetNotificationsTypesAggregateType<T extends NotificationsTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationsTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationsTypes[P]>
      : GetScalarType<T[P], AggregateNotificationsTypes[P]>
  }




  export type NotificationsTypesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationsTypesWhereInput
    orderBy?: NotificationsTypesOrderByWithAggregationInput | NotificationsTypesOrderByWithAggregationInput[]
    by: NotificationsTypesScalarFieldEnum[] | NotificationsTypesScalarFieldEnum
    having?: NotificationsTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsTypesCountAggregateInputType | true
    _min?: NotificationsTypesMinAggregateInputType
    _max?: NotificationsTypesMaxAggregateInputType
  }

  export type NotificationsTypesGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: NotificationsTypesCountAggregateOutputType | null
    _min: NotificationsTypesMinAggregateOutputType | null
    _max: NotificationsTypesMaxAggregateOutputType | null
  }

  type GetNotificationsTypesGroupByPayload<T extends NotificationsTypesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsTypesGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsTypesGroupByOutputType[P]>
        }
      >
    >


  export type NotificationsTypesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    NotificationSettings?: boolean | NotificationsTypes$NotificationSettingsArgs<ExtArgs>
    Notifications?: boolean | NotificationsTypes$NotificationsArgs<ExtArgs>
    _count?: boolean | NotificationsTypesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationsTypes"]>

  export type NotificationsTypesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notificationsTypes"]>

  export type NotificationsTypesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notificationsTypes"]>

  export type NotificationsTypesSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationsTypesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationsTypes"]>
  export type NotificationsTypesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    NotificationSettings?: boolean | NotificationsTypes$NotificationSettingsArgs<ExtArgs>
    Notifications?: boolean | NotificationsTypes$NotificationsArgs<ExtArgs>
    _count?: boolean | NotificationsTypesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NotificationsTypesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type NotificationsTypesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NotificationsTypesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationsTypes"
    objects: {
      NotificationSettings: Prisma.$NotificationSettingsPayload<ExtArgs>[]
      Notifications: Prisma.$NotificationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationsTypes"]>
    composites: {}
  }

  type NotificationsTypesGetPayload<S extends boolean | null | undefined | NotificationsTypesDefaultArgs> = $Result.GetResult<Prisma.$NotificationsTypesPayload, S>

  type NotificationsTypesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationsTypesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationsTypesCountAggregateInputType | true
    }

  export interface NotificationsTypesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationsTypes'], meta: { name: 'NotificationsTypes' } }
    /**
     * Find zero or one NotificationsTypes that matches the filter.
     * @param {NotificationsTypesFindUniqueArgs} args - Arguments to find a NotificationsTypes
     * @example
     * // Get one NotificationsTypes
     * const notificationsTypes = await prisma.notificationsTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationsTypesFindUniqueArgs>(args: SelectSubset<T, NotificationsTypesFindUniqueArgs<ExtArgs>>): Prisma__NotificationsTypesClient<$Result.GetResult<Prisma.$NotificationsTypesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationsTypes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationsTypesFindUniqueOrThrowArgs} args - Arguments to find a NotificationsTypes
     * @example
     * // Get one NotificationsTypes
     * const notificationsTypes = await prisma.notificationsTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationsTypesFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationsTypesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationsTypesClient<$Result.GetResult<Prisma.$NotificationsTypesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationsTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsTypesFindFirstArgs} args - Arguments to find a NotificationsTypes
     * @example
     * // Get one NotificationsTypes
     * const notificationsTypes = await prisma.notificationsTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationsTypesFindFirstArgs>(args?: SelectSubset<T, NotificationsTypesFindFirstArgs<ExtArgs>>): Prisma__NotificationsTypesClient<$Result.GetResult<Prisma.$NotificationsTypesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationsTypes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsTypesFindFirstOrThrowArgs} args - Arguments to find a NotificationsTypes
     * @example
     * // Get one NotificationsTypes
     * const notificationsTypes = await prisma.notificationsTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationsTypesFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationsTypesFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationsTypesClient<$Result.GetResult<Prisma.$NotificationsTypesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationsTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsTypesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationsTypes
     * const notificationsTypes = await prisma.notificationsTypes.findMany()
     * 
     * // Get first 10 NotificationsTypes
     * const notificationsTypes = await prisma.notificationsTypes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsTypesWithIdOnly = await prisma.notificationsTypes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationsTypesFindManyArgs>(args?: SelectSubset<T, NotificationsTypesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsTypesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationsTypes.
     * @param {NotificationsTypesCreateArgs} args - Arguments to create a NotificationsTypes.
     * @example
     * // Create one NotificationsTypes
     * const NotificationsTypes = await prisma.notificationsTypes.create({
     *   data: {
     *     // ... data to create a NotificationsTypes
     *   }
     * })
     * 
     */
    create<T extends NotificationsTypesCreateArgs>(args: SelectSubset<T, NotificationsTypesCreateArgs<ExtArgs>>): Prisma__NotificationsTypesClient<$Result.GetResult<Prisma.$NotificationsTypesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationsTypes.
     * @param {NotificationsTypesCreateManyArgs} args - Arguments to create many NotificationsTypes.
     * @example
     * // Create many NotificationsTypes
     * const notificationsTypes = await prisma.notificationsTypes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationsTypesCreateManyArgs>(args?: SelectSubset<T, NotificationsTypesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationsTypes and returns the data saved in the database.
     * @param {NotificationsTypesCreateManyAndReturnArgs} args - Arguments to create many NotificationsTypes.
     * @example
     * // Create many NotificationsTypes
     * const notificationsTypes = await prisma.notificationsTypes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationsTypes and only return the `id`
     * const notificationsTypesWithIdOnly = await prisma.notificationsTypes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationsTypesCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationsTypesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsTypesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationsTypes.
     * @param {NotificationsTypesDeleteArgs} args - Arguments to delete one NotificationsTypes.
     * @example
     * // Delete one NotificationsTypes
     * const NotificationsTypes = await prisma.notificationsTypes.delete({
     *   where: {
     *     // ... filter to delete one NotificationsTypes
     *   }
     * })
     * 
     */
    delete<T extends NotificationsTypesDeleteArgs>(args: SelectSubset<T, NotificationsTypesDeleteArgs<ExtArgs>>): Prisma__NotificationsTypesClient<$Result.GetResult<Prisma.$NotificationsTypesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationsTypes.
     * @param {NotificationsTypesUpdateArgs} args - Arguments to update one NotificationsTypes.
     * @example
     * // Update one NotificationsTypes
     * const notificationsTypes = await prisma.notificationsTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationsTypesUpdateArgs>(args: SelectSubset<T, NotificationsTypesUpdateArgs<ExtArgs>>): Prisma__NotificationsTypesClient<$Result.GetResult<Prisma.$NotificationsTypesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationsTypes.
     * @param {NotificationsTypesDeleteManyArgs} args - Arguments to filter NotificationsTypes to delete.
     * @example
     * // Delete a few NotificationsTypes
     * const { count } = await prisma.notificationsTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationsTypesDeleteManyArgs>(args?: SelectSubset<T, NotificationsTypesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationsTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationsTypes
     * const notificationsTypes = await prisma.notificationsTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationsTypesUpdateManyArgs>(args: SelectSubset<T, NotificationsTypesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationsTypes and returns the data updated in the database.
     * @param {NotificationsTypesUpdateManyAndReturnArgs} args - Arguments to update many NotificationsTypes.
     * @example
     * // Update many NotificationsTypes
     * const notificationsTypes = await prisma.notificationsTypes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationsTypes and only return the `id`
     * const notificationsTypesWithIdOnly = await prisma.notificationsTypes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationsTypesUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationsTypesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsTypesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationsTypes.
     * @param {NotificationsTypesUpsertArgs} args - Arguments to update or create a NotificationsTypes.
     * @example
     * // Update or create a NotificationsTypes
     * const notificationsTypes = await prisma.notificationsTypes.upsert({
     *   create: {
     *     // ... data to create a NotificationsTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationsTypes we want to update
     *   }
     * })
     */
    upsert<T extends NotificationsTypesUpsertArgs>(args: SelectSubset<T, NotificationsTypesUpsertArgs<ExtArgs>>): Prisma__NotificationsTypesClient<$Result.GetResult<Prisma.$NotificationsTypesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationsTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsTypesCountArgs} args - Arguments to filter NotificationsTypes to count.
     * @example
     * // Count the number of NotificationsTypes
     * const count = await prisma.notificationsTypes.count({
     *   where: {
     *     // ... the filter for the NotificationsTypes we want to count
     *   }
     * })
    **/
    count<T extends NotificationsTypesCountArgs>(
      args?: Subset<T, NotificationsTypesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationsTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsTypesAggregateArgs>(args: Subset<T, NotificationsTypesAggregateArgs>): Prisma.PrismaPromise<GetNotificationsTypesAggregateType<T>>

    /**
     * Group by NotificationsTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationsTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationsTypesGroupByArgs['orderBy'] }
        : { orderBy?: NotificationsTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationsTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsTypesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationsTypes model
   */
  readonly fields: NotificationsTypesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationsTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationsTypesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    NotificationSettings<T extends NotificationsTypes$NotificationSettingsArgs<ExtArgs> = {}>(args?: Subset<T, NotificationsTypes$NotificationSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Notifications<T extends NotificationsTypes$NotificationsArgs<ExtArgs> = {}>(args?: Subset<T, NotificationsTypes$NotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationsTypes model
   */ 
  interface NotificationsTypesFieldRefs {
    readonly id: FieldRef<"NotificationsTypes", 'String'>
    readonly name: FieldRef<"NotificationsTypes", 'String'>
    readonly createdAt: FieldRef<"NotificationsTypes", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationsTypes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationsTypes findUnique
   */
  export type NotificationsTypesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationsTypes
     */
    select?: NotificationsTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationsTypes
     */
    omit?: NotificationsTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsTypesInclude<ExtArgs> | null
    /**
     * Filter, which NotificationsTypes to fetch.
     */
    where: NotificationsTypesWhereUniqueInput
  }

  /**
   * NotificationsTypes findUniqueOrThrow
   */
  export type NotificationsTypesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationsTypes
     */
    select?: NotificationsTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationsTypes
     */
    omit?: NotificationsTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsTypesInclude<ExtArgs> | null
    /**
     * Filter, which NotificationsTypes to fetch.
     */
    where: NotificationsTypesWhereUniqueInput
  }

  /**
   * NotificationsTypes findFirst
   */
  export type NotificationsTypesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationsTypes
     */
    select?: NotificationsTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationsTypes
     */
    omit?: NotificationsTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsTypesInclude<ExtArgs> | null
    /**
     * Filter, which NotificationsTypes to fetch.
     */
    where?: NotificationsTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationsTypes to fetch.
     */
    orderBy?: NotificationsTypesOrderByWithRelationInput | NotificationsTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationsTypes.
     */
    cursor?: NotificationsTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationsTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationsTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationsTypes.
     */
    distinct?: NotificationsTypesScalarFieldEnum | NotificationsTypesScalarFieldEnum[]
  }

  /**
   * NotificationsTypes findFirstOrThrow
   */
  export type NotificationsTypesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationsTypes
     */
    select?: NotificationsTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationsTypes
     */
    omit?: NotificationsTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsTypesInclude<ExtArgs> | null
    /**
     * Filter, which NotificationsTypes to fetch.
     */
    where?: NotificationsTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationsTypes to fetch.
     */
    orderBy?: NotificationsTypesOrderByWithRelationInput | NotificationsTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationsTypes.
     */
    cursor?: NotificationsTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationsTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationsTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationsTypes.
     */
    distinct?: NotificationsTypesScalarFieldEnum | NotificationsTypesScalarFieldEnum[]
  }

  /**
   * NotificationsTypes findMany
   */
  export type NotificationsTypesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationsTypes
     */
    select?: NotificationsTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationsTypes
     */
    omit?: NotificationsTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsTypesInclude<ExtArgs> | null
    /**
     * Filter, which NotificationsTypes to fetch.
     */
    where?: NotificationsTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationsTypes to fetch.
     */
    orderBy?: NotificationsTypesOrderByWithRelationInput | NotificationsTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationsTypes.
     */
    cursor?: NotificationsTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationsTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationsTypes.
     */
    skip?: number
    distinct?: NotificationsTypesScalarFieldEnum | NotificationsTypesScalarFieldEnum[]
  }

  /**
   * NotificationsTypes create
   */
  export type NotificationsTypesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationsTypes
     */
    select?: NotificationsTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationsTypes
     */
    omit?: NotificationsTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsTypesInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationsTypes.
     */
    data: XOR<NotificationsTypesCreateInput, NotificationsTypesUncheckedCreateInput>
  }

  /**
   * NotificationsTypes createMany
   */
  export type NotificationsTypesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationsTypes.
     */
    data: NotificationsTypesCreateManyInput | NotificationsTypesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationsTypes createManyAndReturn
   */
  export type NotificationsTypesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationsTypes
     */
    select?: NotificationsTypesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationsTypes
     */
    omit?: NotificationsTypesOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationsTypes.
     */
    data: NotificationsTypesCreateManyInput | NotificationsTypesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationsTypes update
   */
  export type NotificationsTypesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationsTypes
     */
    select?: NotificationsTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationsTypes
     */
    omit?: NotificationsTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsTypesInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationsTypes.
     */
    data: XOR<NotificationsTypesUpdateInput, NotificationsTypesUncheckedUpdateInput>
    /**
     * Choose, which NotificationsTypes to update.
     */
    where: NotificationsTypesWhereUniqueInput
  }

  /**
   * NotificationsTypes updateMany
   */
  export type NotificationsTypesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationsTypes.
     */
    data: XOR<NotificationsTypesUpdateManyMutationInput, NotificationsTypesUncheckedUpdateManyInput>
    /**
     * Filter which NotificationsTypes to update
     */
    where?: NotificationsTypesWhereInput
    /**
     * Limit how many NotificationsTypes to update.
     */
    limit?: number
  }

  /**
   * NotificationsTypes updateManyAndReturn
   */
  export type NotificationsTypesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationsTypes
     */
    select?: NotificationsTypesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationsTypes
     */
    omit?: NotificationsTypesOmit<ExtArgs> | null
    /**
     * The data used to update NotificationsTypes.
     */
    data: XOR<NotificationsTypesUpdateManyMutationInput, NotificationsTypesUncheckedUpdateManyInput>
    /**
     * Filter which NotificationsTypes to update
     */
    where?: NotificationsTypesWhereInput
    /**
     * Limit how many NotificationsTypes to update.
     */
    limit?: number
  }

  /**
   * NotificationsTypes upsert
   */
  export type NotificationsTypesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationsTypes
     */
    select?: NotificationsTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationsTypes
     */
    omit?: NotificationsTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsTypesInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationsTypes to update in case it exists.
     */
    where: NotificationsTypesWhereUniqueInput
    /**
     * In case the NotificationsTypes found by the `where` argument doesn't exist, create a new NotificationsTypes with this data.
     */
    create: XOR<NotificationsTypesCreateInput, NotificationsTypesUncheckedCreateInput>
    /**
     * In case the NotificationsTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationsTypesUpdateInput, NotificationsTypesUncheckedUpdateInput>
  }

  /**
   * NotificationsTypes delete
   */
  export type NotificationsTypesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationsTypes
     */
    select?: NotificationsTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationsTypes
     */
    omit?: NotificationsTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsTypesInclude<ExtArgs> | null
    /**
     * Filter which NotificationsTypes to delete.
     */
    where: NotificationsTypesWhereUniqueInput
  }

  /**
   * NotificationsTypes deleteMany
   */
  export type NotificationsTypesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationsTypes to delete
     */
    where?: NotificationsTypesWhereInput
    /**
     * Limit how many NotificationsTypes to delete.
     */
    limit?: number
  }

  /**
   * NotificationsTypes.NotificationSettings
   */
  export type NotificationsTypes$NotificationSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    where?: NotificationSettingsWhereInput
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    cursor?: NotificationSettingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationsTypes.Notifications
   */
  export type NotificationsTypes$NotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    where?: NotificationsWhereInput
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    cursor?: NotificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * NotificationsTypes without action
   */
  export type NotificationsTypesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationsTypes
     */
    select?: NotificationsTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationsTypes
     */
    omit?: NotificationsTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsTypesInclude<ExtArgs> | null
  }


  /**
   * Model Passenger
   */

  export type AggregatePassenger = {
    _count: PassengerCountAggregateOutputType | null
    _min: PassengerMinAggregateOutputType | null
    _max: PassengerMaxAggregateOutputType | null
  }

  export type PassengerMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
  }

  export type PassengerMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
  }

  export type PassengerCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    _all: number
  }


  export type PassengerMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
  }

  export type PassengerMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
  }

  export type PassengerCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    _all?: true
  }

  export type PassengerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Passenger to aggregate.
     */
    where?: PassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passengers to fetch.
     */
    orderBy?: PassengerOrderByWithRelationInput | PassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Passengers
    **/
    _count?: true | PassengerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PassengerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PassengerMaxAggregateInputType
  }

  export type GetPassengerAggregateType<T extends PassengerAggregateArgs> = {
        [P in keyof T & keyof AggregatePassenger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassenger[P]>
      : GetScalarType<T[P], AggregatePassenger[P]>
  }




  export type PassengerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PassengerWhereInput
    orderBy?: PassengerOrderByWithAggregationInput | PassengerOrderByWithAggregationInput[]
    by: PassengerScalarFieldEnum[] | PassengerScalarFieldEnum
    having?: PassengerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PassengerCountAggregateInputType | true
    _min?: PassengerMinAggregateInputType
    _max?: PassengerMaxAggregateInputType
  }

  export type PassengerGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    _count: PassengerCountAggregateOutputType | null
    _min: PassengerMinAggregateOutputType | null
    _max: PassengerMaxAggregateOutputType | null
  }

  type GetPassengerGroupByPayload<T extends PassengerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PassengerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PassengerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PassengerGroupByOutputType[P]>
            : GetScalarType<T[P], PassengerGroupByOutputType[P]>
        }
      >
    >


  export type PassengerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
  }, ExtArgs["result"]["passenger"]>

  export type PassengerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
  }, ExtArgs["result"]["passenger"]>

  export type PassengerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
  }, ExtArgs["result"]["passenger"]>

  export type PassengerSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
  }

  export type PassengerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName", ExtArgs["result"]["passenger"]>

  export type $PassengerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Passenger"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
    }, ExtArgs["result"]["passenger"]>
    composites: {}
  }

  type PassengerGetPayload<S extends boolean | null | undefined | PassengerDefaultArgs> = $Result.GetResult<Prisma.$PassengerPayload, S>

  type PassengerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PassengerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PassengerCountAggregateInputType | true
    }

  export interface PassengerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Passenger'], meta: { name: 'Passenger' } }
    /**
     * Find zero or one Passenger that matches the filter.
     * @param {PassengerFindUniqueArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PassengerFindUniqueArgs>(args: SelectSubset<T, PassengerFindUniqueArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Passenger that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PassengerFindUniqueOrThrowArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PassengerFindUniqueOrThrowArgs>(args: SelectSubset<T, PassengerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Passenger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerFindFirstArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PassengerFindFirstArgs>(args?: SelectSubset<T, PassengerFindFirstArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Passenger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerFindFirstOrThrowArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PassengerFindFirstOrThrowArgs>(args?: SelectSubset<T, PassengerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Passengers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Passengers
     * const passengers = await prisma.passenger.findMany()
     * 
     * // Get first 10 Passengers
     * const passengers = await prisma.passenger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passengerWithIdOnly = await prisma.passenger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PassengerFindManyArgs>(args?: SelectSubset<T, PassengerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Passenger.
     * @param {PassengerCreateArgs} args - Arguments to create a Passenger.
     * @example
     * // Create one Passenger
     * const Passenger = await prisma.passenger.create({
     *   data: {
     *     // ... data to create a Passenger
     *   }
     * })
     * 
     */
    create<T extends PassengerCreateArgs>(args: SelectSubset<T, PassengerCreateArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Passengers.
     * @param {PassengerCreateManyArgs} args - Arguments to create many Passengers.
     * @example
     * // Create many Passengers
     * const passenger = await prisma.passenger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PassengerCreateManyArgs>(args?: SelectSubset<T, PassengerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Passengers and returns the data saved in the database.
     * @param {PassengerCreateManyAndReturnArgs} args - Arguments to create many Passengers.
     * @example
     * // Create many Passengers
     * const passenger = await prisma.passenger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Passengers and only return the `id`
     * const passengerWithIdOnly = await prisma.passenger.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PassengerCreateManyAndReturnArgs>(args?: SelectSubset<T, PassengerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Passenger.
     * @param {PassengerDeleteArgs} args - Arguments to delete one Passenger.
     * @example
     * // Delete one Passenger
     * const Passenger = await prisma.passenger.delete({
     *   where: {
     *     // ... filter to delete one Passenger
     *   }
     * })
     * 
     */
    delete<T extends PassengerDeleteArgs>(args: SelectSubset<T, PassengerDeleteArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Passenger.
     * @param {PassengerUpdateArgs} args - Arguments to update one Passenger.
     * @example
     * // Update one Passenger
     * const passenger = await prisma.passenger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PassengerUpdateArgs>(args: SelectSubset<T, PassengerUpdateArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Passengers.
     * @param {PassengerDeleteManyArgs} args - Arguments to filter Passengers to delete.
     * @example
     * // Delete a few Passengers
     * const { count } = await prisma.passenger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PassengerDeleteManyArgs>(args?: SelectSubset<T, PassengerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passengers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Passengers
     * const passenger = await prisma.passenger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PassengerUpdateManyArgs>(args: SelectSubset<T, PassengerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passengers and returns the data updated in the database.
     * @param {PassengerUpdateManyAndReturnArgs} args - Arguments to update many Passengers.
     * @example
     * // Update many Passengers
     * const passenger = await prisma.passenger.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Passengers and only return the `id`
     * const passengerWithIdOnly = await prisma.passenger.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PassengerUpdateManyAndReturnArgs>(args: SelectSubset<T, PassengerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Passenger.
     * @param {PassengerUpsertArgs} args - Arguments to update or create a Passenger.
     * @example
     * // Update or create a Passenger
     * const passenger = await prisma.passenger.upsert({
     *   create: {
     *     // ... data to create a Passenger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Passenger we want to update
     *   }
     * })
     */
    upsert<T extends PassengerUpsertArgs>(args: SelectSubset<T, PassengerUpsertArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Passengers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerCountArgs} args - Arguments to filter Passengers to count.
     * @example
     * // Count the number of Passengers
     * const count = await prisma.passenger.count({
     *   where: {
     *     // ... the filter for the Passengers we want to count
     *   }
     * })
    **/
    count<T extends PassengerCountArgs>(
      args?: Subset<T, PassengerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PassengerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Passenger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PassengerAggregateArgs>(args: Subset<T, PassengerAggregateArgs>): Prisma.PrismaPromise<GetPassengerAggregateType<T>>

    /**
     * Group by Passenger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PassengerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PassengerGroupByArgs['orderBy'] }
        : { orderBy?: PassengerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PassengerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPassengerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Passenger model
   */
  readonly fields: PassengerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Passenger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PassengerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Passenger model
   */ 
  interface PassengerFieldRefs {
    readonly id: FieldRef<"Passenger", 'String'>
    readonly firstName: FieldRef<"Passenger", 'String'>
    readonly lastName: FieldRef<"Passenger", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Passenger findUnique
   */
  export type PassengerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Filter, which Passenger to fetch.
     */
    where: PassengerWhereUniqueInput
  }

  /**
   * Passenger findUniqueOrThrow
   */
  export type PassengerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Filter, which Passenger to fetch.
     */
    where: PassengerWhereUniqueInput
  }

  /**
   * Passenger findFirst
   */
  export type PassengerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Filter, which Passenger to fetch.
     */
    where?: PassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passengers to fetch.
     */
    orderBy?: PassengerOrderByWithRelationInput | PassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Passengers.
     */
    cursor?: PassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Passengers.
     */
    distinct?: PassengerScalarFieldEnum | PassengerScalarFieldEnum[]
  }

  /**
   * Passenger findFirstOrThrow
   */
  export type PassengerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Filter, which Passenger to fetch.
     */
    where?: PassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passengers to fetch.
     */
    orderBy?: PassengerOrderByWithRelationInput | PassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Passengers.
     */
    cursor?: PassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Passengers.
     */
    distinct?: PassengerScalarFieldEnum | PassengerScalarFieldEnum[]
  }

  /**
   * Passenger findMany
   */
  export type PassengerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Filter, which Passengers to fetch.
     */
    where?: PassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passengers to fetch.
     */
    orderBy?: PassengerOrderByWithRelationInput | PassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Passengers.
     */
    cursor?: PassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passengers.
     */
    skip?: number
    distinct?: PassengerScalarFieldEnum | PassengerScalarFieldEnum[]
  }

  /**
   * Passenger create
   */
  export type PassengerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * The data needed to create a Passenger.
     */
    data: XOR<PassengerCreateInput, PassengerUncheckedCreateInput>
  }

  /**
   * Passenger createMany
   */
  export type PassengerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Passengers.
     */
    data: PassengerCreateManyInput | PassengerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Passenger createManyAndReturn
   */
  export type PassengerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * The data used to create many Passengers.
     */
    data: PassengerCreateManyInput | PassengerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Passenger update
   */
  export type PassengerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * The data needed to update a Passenger.
     */
    data: XOR<PassengerUpdateInput, PassengerUncheckedUpdateInput>
    /**
     * Choose, which Passenger to update.
     */
    where: PassengerWhereUniqueInput
  }

  /**
   * Passenger updateMany
   */
  export type PassengerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Passengers.
     */
    data: XOR<PassengerUpdateManyMutationInput, PassengerUncheckedUpdateManyInput>
    /**
     * Filter which Passengers to update
     */
    where?: PassengerWhereInput
    /**
     * Limit how many Passengers to update.
     */
    limit?: number
  }

  /**
   * Passenger updateManyAndReturn
   */
  export type PassengerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * The data used to update Passengers.
     */
    data: XOR<PassengerUpdateManyMutationInput, PassengerUncheckedUpdateManyInput>
    /**
     * Filter which Passengers to update
     */
    where?: PassengerWhereInput
    /**
     * Limit how many Passengers to update.
     */
    limit?: number
  }

  /**
   * Passenger upsert
   */
  export type PassengerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * The filter to search for the Passenger to update in case it exists.
     */
    where: PassengerWhereUniqueInput
    /**
     * In case the Passenger found by the `where` argument doesn't exist, create a new Passenger with this data.
     */
    create: XOR<PassengerCreateInput, PassengerUncheckedCreateInput>
    /**
     * In case the Passenger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PassengerUpdateInput, PassengerUncheckedUpdateInput>
  }

  /**
   * Passenger delete
   */
  export type PassengerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Filter which Passenger to delete.
     */
    where: PassengerWhereUniqueInput
  }

  /**
   * Passenger deleteMany
   */
  export type PassengerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Passengers to delete
     */
    where?: PassengerWhereInput
    /**
     * Limit how many Passengers to delete.
     */
    limit?: number
  }

  /**
   * Passenger without action
   */
  export type PassengerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
  }


  /**
   * Model Ranks
   */

  export type AggregateRanks = {
    _count: RanksCountAggregateOutputType | null
    _avg: RanksAvgAggregateOutputType | null
    _sum: RanksSumAggregateOutputType | null
    _min: RanksMinAggregateOutputType | null
    _max: RanksMaxAggregateOutputType | null
  }

  export type RanksAvgAggregateOutputType = {
    value: number | null
  }

  export type RanksSumAggregateOutputType = {
    value: number | null
  }

  export type RanksMinAggregateOutputType = {
    id: string | null
    name: string | null
    value: number | null
    sourceId: string | null
  }

  export type RanksMaxAggregateOutputType = {
    id: string | null
    name: string | null
    value: number | null
    sourceId: string | null
  }

  export type RanksCountAggregateOutputType = {
    id: number
    name: number
    value: number
    sourceId: number
    _all: number
  }


  export type RanksAvgAggregateInputType = {
    value?: true
  }

  export type RanksSumAggregateInputType = {
    value?: true
  }

  export type RanksMinAggregateInputType = {
    id?: true
    name?: true
    value?: true
    sourceId?: true
  }

  export type RanksMaxAggregateInputType = {
    id?: true
    name?: true
    value?: true
    sourceId?: true
  }

  export type RanksCountAggregateInputType = {
    id?: true
    name?: true
    value?: true
    sourceId?: true
    _all?: true
  }

  export type RanksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ranks to aggregate.
     */
    where?: RanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ranks to fetch.
     */
    orderBy?: RanksOrderByWithRelationInput | RanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ranks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ranks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ranks
    **/
    _count?: true | RanksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RanksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RanksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RanksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RanksMaxAggregateInputType
  }

  export type GetRanksAggregateType<T extends RanksAggregateArgs> = {
        [P in keyof T & keyof AggregateRanks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRanks[P]>
      : GetScalarType<T[P], AggregateRanks[P]>
  }




  export type RanksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RanksWhereInput
    orderBy?: RanksOrderByWithAggregationInput | RanksOrderByWithAggregationInput[]
    by: RanksScalarFieldEnum[] | RanksScalarFieldEnum
    having?: RanksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RanksCountAggregateInputType | true
    _avg?: RanksAvgAggregateInputType
    _sum?: RanksSumAggregateInputType
    _min?: RanksMinAggregateInputType
    _max?: RanksMaxAggregateInputType
  }

  export type RanksGroupByOutputType = {
    id: string
    name: string
    value: number
    sourceId: string
    _count: RanksCountAggregateOutputType | null
    _avg: RanksAvgAggregateOutputType | null
    _sum: RanksSumAggregateOutputType | null
    _min: RanksMinAggregateOutputType | null
    _max: RanksMaxAggregateOutputType | null
  }

  type GetRanksGroupByPayload<T extends RanksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RanksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RanksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RanksGroupByOutputType[P]>
            : GetScalarType<T[P], RanksGroupByOutputType[P]>
        }
      >
    >


  export type RanksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    sourceId?: boolean
    ConferenceRanks?: boolean | Ranks$ConferenceRanksArgs<ExtArgs>
    JournalRanks?: boolean | Ranks$JournalRanksArgs<ExtArgs>
    Sources?: boolean | SourcesDefaultArgs<ExtArgs>
    _count?: boolean | RanksCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ranks"]>

  export type RanksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    sourceId?: boolean
    Sources?: boolean | SourcesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ranks"]>

  export type RanksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    sourceId?: boolean
    Sources?: boolean | SourcesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ranks"]>

  export type RanksSelectScalar = {
    id?: boolean
    name?: boolean
    value?: boolean
    sourceId?: boolean
  }

  export type RanksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "value" | "sourceId", ExtArgs["result"]["ranks"]>
  export type RanksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConferenceRanks?: boolean | Ranks$ConferenceRanksArgs<ExtArgs>
    JournalRanks?: boolean | Ranks$JournalRanksArgs<ExtArgs>
    Sources?: boolean | SourcesDefaultArgs<ExtArgs>
    _count?: boolean | RanksCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RanksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sources?: boolean | SourcesDefaultArgs<ExtArgs>
  }
  export type RanksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sources?: boolean | SourcesDefaultArgs<ExtArgs>
  }

  export type $RanksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ranks"
    objects: {
      ConferenceRanks: Prisma.$ConferenceRanksPayload<ExtArgs>[]
      JournalRanks: Prisma.$JournalRanksPayload<ExtArgs>[]
      Sources: Prisma.$SourcesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      value: number
      sourceId: string
    }, ExtArgs["result"]["ranks"]>
    composites: {}
  }

  type RanksGetPayload<S extends boolean | null | undefined | RanksDefaultArgs> = $Result.GetResult<Prisma.$RanksPayload, S>

  type RanksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RanksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RanksCountAggregateInputType | true
    }

  export interface RanksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ranks'], meta: { name: 'Ranks' } }
    /**
     * Find zero or one Ranks that matches the filter.
     * @param {RanksFindUniqueArgs} args - Arguments to find a Ranks
     * @example
     * // Get one Ranks
     * const ranks = await prisma.ranks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RanksFindUniqueArgs>(args: SelectSubset<T, RanksFindUniqueArgs<ExtArgs>>): Prisma__RanksClient<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ranks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RanksFindUniqueOrThrowArgs} args - Arguments to find a Ranks
     * @example
     * // Get one Ranks
     * const ranks = await prisma.ranks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RanksFindUniqueOrThrowArgs>(args: SelectSubset<T, RanksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RanksClient<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ranks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RanksFindFirstArgs} args - Arguments to find a Ranks
     * @example
     * // Get one Ranks
     * const ranks = await prisma.ranks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RanksFindFirstArgs>(args?: SelectSubset<T, RanksFindFirstArgs<ExtArgs>>): Prisma__RanksClient<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ranks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RanksFindFirstOrThrowArgs} args - Arguments to find a Ranks
     * @example
     * // Get one Ranks
     * const ranks = await prisma.ranks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RanksFindFirstOrThrowArgs>(args?: SelectSubset<T, RanksFindFirstOrThrowArgs<ExtArgs>>): Prisma__RanksClient<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ranks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RanksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ranks
     * const ranks = await prisma.ranks.findMany()
     * 
     * // Get first 10 Ranks
     * const ranks = await prisma.ranks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ranksWithIdOnly = await prisma.ranks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RanksFindManyArgs>(args?: SelectSubset<T, RanksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ranks.
     * @param {RanksCreateArgs} args - Arguments to create a Ranks.
     * @example
     * // Create one Ranks
     * const Ranks = await prisma.ranks.create({
     *   data: {
     *     // ... data to create a Ranks
     *   }
     * })
     * 
     */
    create<T extends RanksCreateArgs>(args: SelectSubset<T, RanksCreateArgs<ExtArgs>>): Prisma__RanksClient<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ranks.
     * @param {RanksCreateManyArgs} args - Arguments to create many Ranks.
     * @example
     * // Create many Ranks
     * const ranks = await prisma.ranks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RanksCreateManyArgs>(args?: SelectSubset<T, RanksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ranks and returns the data saved in the database.
     * @param {RanksCreateManyAndReturnArgs} args - Arguments to create many Ranks.
     * @example
     * // Create many Ranks
     * const ranks = await prisma.ranks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ranks and only return the `id`
     * const ranksWithIdOnly = await prisma.ranks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RanksCreateManyAndReturnArgs>(args?: SelectSubset<T, RanksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ranks.
     * @param {RanksDeleteArgs} args - Arguments to delete one Ranks.
     * @example
     * // Delete one Ranks
     * const Ranks = await prisma.ranks.delete({
     *   where: {
     *     // ... filter to delete one Ranks
     *   }
     * })
     * 
     */
    delete<T extends RanksDeleteArgs>(args: SelectSubset<T, RanksDeleteArgs<ExtArgs>>): Prisma__RanksClient<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ranks.
     * @param {RanksUpdateArgs} args - Arguments to update one Ranks.
     * @example
     * // Update one Ranks
     * const ranks = await prisma.ranks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RanksUpdateArgs>(args: SelectSubset<T, RanksUpdateArgs<ExtArgs>>): Prisma__RanksClient<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ranks.
     * @param {RanksDeleteManyArgs} args - Arguments to filter Ranks to delete.
     * @example
     * // Delete a few Ranks
     * const { count } = await prisma.ranks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RanksDeleteManyArgs>(args?: SelectSubset<T, RanksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ranks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RanksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ranks
     * const ranks = await prisma.ranks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RanksUpdateManyArgs>(args: SelectSubset<T, RanksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ranks and returns the data updated in the database.
     * @param {RanksUpdateManyAndReturnArgs} args - Arguments to update many Ranks.
     * @example
     * // Update many Ranks
     * const ranks = await prisma.ranks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ranks and only return the `id`
     * const ranksWithIdOnly = await prisma.ranks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RanksUpdateManyAndReturnArgs>(args: SelectSubset<T, RanksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ranks.
     * @param {RanksUpsertArgs} args - Arguments to update or create a Ranks.
     * @example
     * // Update or create a Ranks
     * const ranks = await prisma.ranks.upsert({
     *   create: {
     *     // ... data to create a Ranks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ranks we want to update
     *   }
     * })
     */
    upsert<T extends RanksUpsertArgs>(args: SelectSubset<T, RanksUpsertArgs<ExtArgs>>): Prisma__RanksClient<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ranks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RanksCountArgs} args - Arguments to filter Ranks to count.
     * @example
     * // Count the number of Ranks
     * const count = await prisma.ranks.count({
     *   where: {
     *     // ... the filter for the Ranks we want to count
     *   }
     * })
    **/
    count<T extends RanksCountArgs>(
      args?: Subset<T, RanksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RanksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ranks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RanksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RanksAggregateArgs>(args: Subset<T, RanksAggregateArgs>): Prisma.PrismaPromise<GetRanksAggregateType<T>>

    /**
     * Group by Ranks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RanksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RanksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RanksGroupByArgs['orderBy'] }
        : { orderBy?: RanksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RanksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRanksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ranks model
   */
  readonly fields: RanksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ranks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RanksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ConferenceRanks<T extends Ranks$ConferenceRanksArgs<ExtArgs> = {}>(args?: Subset<T, Ranks$ConferenceRanksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    JournalRanks<T extends Ranks$JournalRanksArgs<ExtArgs> = {}>(args?: Subset<T, Ranks$JournalRanksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Sources<T extends SourcesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SourcesDefaultArgs<ExtArgs>>): Prisma__SourcesClient<$Result.GetResult<Prisma.$SourcesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ranks model
   */ 
  interface RanksFieldRefs {
    readonly id: FieldRef<"Ranks", 'String'>
    readonly name: FieldRef<"Ranks", 'String'>
    readonly value: FieldRef<"Ranks", 'Int'>
    readonly sourceId: FieldRef<"Ranks", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Ranks findUnique
   */
  export type RanksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksInclude<ExtArgs> | null
    /**
     * Filter, which Ranks to fetch.
     */
    where: RanksWhereUniqueInput
  }

  /**
   * Ranks findUniqueOrThrow
   */
  export type RanksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksInclude<ExtArgs> | null
    /**
     * Filter, which Ranks to fetch.
     */
    where: RanksWhereUniqueInput
  }

  /**
   * Ranks findFirst
   */
  export type RanksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksInclude<ExtArgs> | null
    /**
     * Filter, which Ranks to fetch.
     */
    where?: RanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ranks to fetch.
     */
    orderBy?: RanksOrderByWithRelationInput | RanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ranks.
     */
    cursor?: RanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ranks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ranks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ranks.
     */
    distinct?: RanksScalarFieldEnum | RanksScalarFieldEnum[]
  }

  /**
   * Ranks findFirstOrThrow
   */
  export type RanksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksInclude<ExtArgs> | null
    /**
     * Filter, which Ranks to fetch.
     */
    where?: RanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ranks to fetch.
     */
    orderBy?: RanksOrderByWithRelationInput | RanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ranks.
     */
    cursor?: RanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ranks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ranks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ranks.
     */
    distinct?: RanksScalarFieldEnum | RanksScalarFieldEnum[]
  }

  /**
   * Ranks findMany
   */
  export type RanksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksInclude<ExtArgs> | null
    /**
     * Filter, which Ranks to fetch.
     */
    where?: RanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ranks to fetch.
     */
    orderBy?: RanksOrderByWithRelationInput | RanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ranks.
     */
    cursor?: RanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ranks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ranks.
     */
    skip?: number
    distinct?: RanksScalarFieldEnum | RanksScalarFieldEnum[]
  }

  /**
   * Ranks create
   */
  export type RanksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksInclude<ExtArgs> | null
    /**
     * The data needed to create a Ranks.
     */
    data: XOR<RanksCreateInput, RanksUncheckedCreateInput>
  }

  /**
   * Ranks createMany
   */
  export type RanksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ranks.
     */
    data: RanksCreateManyInput | RanksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ranks createManyAndReturn
   */
  export type RanksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * The data used to create many Ranks.
     */
    data: RanksCreateManyInput | RanksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ranks update
   */
  export type RanksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksInclude<ExtArgs> | null
    /**
     * The data needed to update a Ranks.
     */
    data: XOR<RanksUpdateInput, RanksUncheckedUpdateInput>
    /**
     * Choose, which Ranks to update.
     */
    where: RanksWhereUniqueInput
  }

  /**
   * Ranks updateMany
   */
  export type RanksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ranks.
     */
    data: XOR<RanksUpdateManyMutationInput, RanksUncheckedUpdateManyInput>
    /**
     * Filter which Ranks to update
     */
    where?: RanksWhereInput
    /**
     * Limit how many Ranks to update.
     */
    limit?: number
  }

  /**
   * Ranks updateManyAndReturn
   */
  export type RanksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * The data used to update Ranks.
     */
    data: XOR<RanksUpdateManyMutationInput, RanksUncheckedUpdateManyInput>
    /**
     * Filter which Ranks to update
     */
    where?: RanksWhereInput
    /**
     * Limit how many Ranks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ranks upsert
   */
  export type RanksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksInclude<ExtArgs> | null
    /**
     * The filter to search for the Ranks to update in case it exists.
     */
    where: RanksWhereUniqueInput
    /**
     * In case the Ranks found by the `where` argument doesn't exist, create a new Ranks with this data.
     */
    create: XOR<RanksCreateInput, RanksUncheckedCreateInput>
    /**
     * In case the Ranks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RanksUpdateInput, RanksUncheckedUpdateInput>
  }

  /**
   * Ranks delete
   */
  export type RanksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksInclude<ExtArgs> | null
    /**
     * Filter which Ranks to delete.
     */
    where: RanksWhereUniqueInput
  }

  /**
   * Ranks deleteMany
   */
  export type RanksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ranks to delete
     */
    where?: RanksWhereInput
    /**
     * Limit how many Ranks to delete.
     */
    limit?: number
  }

  /**
   * Ranks.ConferenceRanks
   */
  export type Ranks$ConferenceRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
    where?: ConferenceRanksWhereInput
    orderBy?: ConferenceRanksOrderByWithRelationInput | ConferenceRanksOrderByWithRelationInput[]
    cursor?: ConferenceRanksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceRanksScalarFieldEnum | ConferenceRanksScalarFieldEnum[]
  }

  /**
   * Ranks.JournalRanks
   */
  export type Ranks$JournalRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
    where?: JournalRanksWhereInput
    orderBy?: JournalRanksOrderByWithRelationInput | JournalRanksOrderByWithRelationInput[]
    cursor?: JournalRanksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalRanksScalarFieldEnum | JournalRanksScalarFieldEnum[]
  }

  /**
   * Ranks without action
   */
  export type RanksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksInclude<ExtArgs> | null
  }


  /**
   * Model Sources
   */

  export type AggregateSources = {
    _count: SourcesCountAggregateOutputType | null
    _min: SourcesMinAggregateOutputType | null
    _max: SourcesMaxAggregateOutputType | null
  }

  export type SourcesMinAggregateOutputType = {
    id: string | null
    name: string | null
    link: string | null
  }

  export type SourcesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    link: string | null
  }

  export type SourcesCountAggregateOutputType = {
    id: number
    name: number
    link: number
    _all: number
  }


  export type SourcesMinAggregateInputType = {
    id?: true
    name?: true
    link?: true
  }

  export type SourcesMaxAggregateInputType = {
    id?: true
    name?: true
    link?: true
  }

  export type SourcesCountAggregateInputType = {
    id?: true
    name?: true
    link?: true
    _all?: true
  }

  export type SourcesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sources to aggregate.
     */
    where?: SourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourcesOrderByWithRelationInput | SourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sources
    **/
    _count?: true | SourcesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SourcesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SourcesMaxAggregateInputType
  }

  export type GetSourcesAggregateType<T extends SourcesAggregateArgs> = {
        [P in keyof T & keyof AggregateSources]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSources[P]>
      : GetScalarType<T[P], AggregateSources[P]>
  }




  export type SourcesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourcesWhereInput
    orderBy?: SourcesOrderByWithAggregationInput | SourcesOrderByWithAggregationInput[]
    by: SourcesScalarFieldEnum[] | SourcesScalarFieldEnum
    having?: SourcesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SourcesCountAggregateInputType | true
    _min?: SourcesMinAggregateInputType
    _max?: SourcesMaxAggregateInputType
  }

  export type SourcesGroupByOutputType = {
    id: string
    name: string
    link: string | null
    _count: SourcesCountAggregateOutputType | null
    _min: SourcesMinAggregateOutputType | null
    _max: SourcesMaxAggregateOutputType | null
  }

  type GetSourcesGroupByPayload<T extends SourcesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SourcesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SourcesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SourcesGroupByOutputType[P]>
            : GetScalarType<T[P], SourcesGroupByOutputType[P]>
        }
      >
    >


  export type SourcesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    link?: boolean
    Ranks?: boolean | Sources$RanksArgs<ExtArgs>
    _count?: boolean | SourcesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sources"]>

  export type SourcesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    link?: boolean
  }, ExtArgs["result"]["sources"]>

  export type SourcesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    link?: boolean
  }, ExtArgs["result"]["sources"]>

  export type SourcesSelectScalar = {
    id?: boolean
    name?: boolean
    link?: boolean
  }

  export type SourcesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "link", ExtArgs["result"]["sources"]>
  export type SourcesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Ranks?: boolean | Sources$RanksArgs<ExtArgs>
    _count?: boolean | SourcesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SourcesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SourcesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SourcesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sources"
    objects: {
      Ranks: Prisma.$RanksPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      link: string | null
    }, ExtArgs["result"]["sources"]>
    composites: {}
  }

  type SourcesGetPayload<S extends boolean | null | undefined | SourcesDefaultArgs> = $Result.GetResult<Prisma.$SourcesPayload, S>

  type SourcesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SourcesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SourcesCountAggregateInputType | true
    }

  export interface SourcesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sources'], meta: { name: 'Sources' } }
    /**
     * Find zero or one Sources that matches the filter.
     * @param {SourcesFindUniqueArgs} args - Arguments to find a Sources
     * @example
     * // Get one Sources
     * const sources = await prisma.sources.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SourcesFindUniqueArgs>(args: SelectSubset<T, SourcesFindUniqueArgs<ExtArgs>>): Prisma__SourcesClient<$Result.GetResult<Prisma.$SourcesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sources that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SourcesFindUniqueOrThrowArgs} args - Arguments to find a Sources
     * @example
     * // Get one Sources
     * const sources = await prisma.sources.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SourcesFindUniqueOrThrowArgs>(args: SelectSubset<T, SourcesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SourcesClient<$Result.GetResult<Prisma.$SourcesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourcesFindFirstArgs} args - Arguments to find a Sources
     * @example
     * // Get one Sources
     * const sources = await prisma.sources.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SourcesFindFirstArgs>(args?: SelectSubset<T, SourcesFindFirstArgs<ExtArgs>>): Prisma__SourcesClient<$Result.GetResult<Prisma.$SourcesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sources that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourcesFindFirstOrThrowArgs} args - Arguments to find a Sources
     * @example
     * // Get one Sources
     * const sources = await prisma.sources.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SourcesFindFirstOrThrowArgs>(args?: SelectSubset<T, SourcesFindFirstOrThrowArgs<ExtArgs>>): Prisma__SourcesClient<$Result.GetResult<Prisma.$SourcesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourcesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sources
     * const sources = await prisma.sources.findMany()
     * 
     * // Get first 10 Sources
     * const sources = await prisma.sources.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sourcesWithIdOnly = await prisma.sources.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SourcesFindManyArgs>(args?: SelectSubset<T, SourcesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sources.
     * @param {SourcesCreateArgs} args - Arguments to create a Sources.
     * @example
     * // Create one Sources
     * const Sources = await prisma.sources.create({
     *   data: {
     *     // ... data to create a Sources
     *   }
     * })
     * 
     */
    create<T extends SourcesCreateArgs>(args: SelectSubset<T, SourcesCreateArgs<ExtArgs>>): Prisma__SourcesClient<$Result.GetResult<Prisma.$SourcesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sources.
     * @param {SourcesCreateManyArgs} args - Arguments to create many Sources.
     * @example
     * // Create many Sources
     * const sources = await prisma.sources.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SourcesCreateManyArgs>(args?: SelectSubset<T, SourcesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sources and returns the data saved in the database.
     * @param {SourcesCreateManyAndReturnArgs} args - Arguments to create many Sources.
     * @example
     * // Create many Sources
     * const sources = await prisma.sources.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sources and only return the `id`
     * const sourcesWithIdOnly = await prisma.sources.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SourcesCreateManyAndReturnArgs>(args?: SelectSubset<T, SourcesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sources.
     * @param {SourcesDeleteArgs} args - Arguments to delete one Sources.
     * @example
     * // Delete one Sources
     * const Sources = await prisma.sources.delete({
     *   where: {
     *     // ... filter to delete one Sources
     *   }
     * })
     * 
     */
    delete<T extends SourcesDeleteArgs>(args: SelectSubset<T, SourcesDeleteArgs<ExtArgs>>): Prisma__SourcesClient<$Result.GetResult<Prisma.$SourcesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sources.
     * @param {SourcesUpdateArgs} args - Arguments to update one Sources.
     * @example
     * // Update one Sources
     * const sources = await prisma.sources.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SourcesUpdateArgs>(args: SelectSubset<T, SourcesUpdateArgs<ExtArgs>>): Prisma__SourcesClient<$Result.GetResult<Prisma.$SourcesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sources.
     * @param {SourcesDeleteManyArgs} args - Arguments to filter Sources to delete.
     * @example
     * // Delete a few Sources
     * const { count } = await prisma.sources.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SourcesDeleteManyArgs>(args?: SelectSubset<T, SourcesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourcesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sources
     * const sources = await prisma.sources.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SourcesUpdateManyArgs>(args: SelectSubset<T, SourcesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sources and returns the data updated in the database.
     * @param {SourcesUpdateManyAndReturnArgs} args - Arguments to update many Sources.
     * @example
     * // Update many Sources
     * const sources = await prisma.sources.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sources and only return the `id`
     * const sourcesWithIdOnly = await prisma.sources.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SourcesUpdateManyAndReturnArgs>(args: SelectSubset<T, SourcesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sources.
     * @param {SourcesUpsertArgs} args - Arguments to update or create a Sources.
     * @example
     * // Update or create a Sources
     * const sources = await prisma.sources.upsert({
     *   create: {
     *     // ... data to create a Sources
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sources we want to update
     *   }
     * })
     */
    upsert<T extends SourcesUpsertArgs>(args: SelectSubset<T, SourcesUpsertArgs<ExtArgs>>): Prisma__SourcesClient<$Result.GetResult<Prisma.$SourcesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourcesCountArgs} args - Arguments to filter Sources to count.
     * @example
     * // Count the number of Sources
     * const count = await prisma.sources.count({
     *   where: {
     *     // ... the filter for the Sources we want to count
     *   }
     * })
    **/
    count<T extends SourcesCountArgs>(
      args?: Subset<T, SourcesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SourcesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourcesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SourcesAggregateArgs>(args: Subset<T, SourcesAggregateArgs>): Prisma.PrismaPromise<GetSourcesAggregateType<T>>

    /**
     * Group by Sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourcesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SourcesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SourcesGroupByArgs['orderBy'] }
        : { orderBy?: SourcesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SourcesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSourcesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sources model
   */
  readonly fields: SourcesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sources.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SourcesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Ranks<T extends Sources$RanksArgs<ExtArgs> = {}>(args?: Subset<T, Sources$RanksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sources model
   */ 
  interface SourcesFieldRefs {
    readonly id: FieldRef<"Sources", 'String'>
    readonly name: FieldRef<"Sources", 'String'>
    readonly link: FieldRef<"Sources", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Sources findUnique
   */
  export type SourcesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sources
     */
    select?: SourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sources
     */
    omit?: SourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcesInclude<ExtArgs> | null
    /**
     * Filter, which Sources to fetch.
     */
    where: SourcesWhereUniqueInput
  }

  /**
   * Sources findUniqueOrThrow
   */
  export type SourcesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sources
     */
    select?: SourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sources
     */
    omit?: SourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcesInclude<ExtArgs> | null
    /**
     * Filter, which Sources to fetch.
     */
    where: SourcesWhereUniqueInput
  }

  /**
   * Sources findFirst
   */
  export type SourcesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sources
     */
    select?: SourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sources
     */
    omit?: SourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcesInclude<ExtArgs> | null
    /**
     * Filter, which Sources to fetch.
     */
    where?: SourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourcesOrderByWithRelationInput | SourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sources.
     */
    cursor?: SourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sources.
     */
    distinct?: SourcesScalarFieldEnum | SourcesScalarFieldEnum[]
  }

  /**
   * Sources findFirstOrThrow
   */
  export type SourcesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sources
     */
    select?: SourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sources
     */
    omit?: SourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcesInclude<ExtArgs> | null
    /**
     * Filter, which Sources to fetch.
     */
    where?: SourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourcesOrderByWithRelationInput | SourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sources.
     */
    cursor?: SourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sources.
     */
    distinct?: SourcesScalarFieldEnum | SourcesScalarFieldEnum[]
  }

  /**
   * Sources findMany
   */
  export type SourcesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sources
     */
    select?: SourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sources
     */
    omit?: SourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcesInclude<ExtArgs> | null
    /**
     * Filter, which Sources to fetch.
     */
    where?: SourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourcesOrderByWithRelationInput | SourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sources.
     */
    cursor?: SourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    distinct?: SourcesScalarFieldEnum | SourcesScalarFieldEnum[]
  }

  /**
   * Sources create
   */
  export type SourcesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sources
     */
    select?: SourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sources
     */
    omit?: SourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcesInclude<ExtArgs> | null
    /**
     * The data needed to create a Sources.
     */
    data: XOR<SourcesCreateInput, SourcesUncheckedCreateInput>
  }

  /**
   * Sources createMany
   */
  export type SourcesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sources.
     */
    data: SourcesCreateManyInput | SourcesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sources createManyAndReturn
   */
  export type SourcesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sources
     */
    select?: SourcesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sources
     */
    omit?: SourcesOmit<ExtArgs> | null
    /**
     * The data used to create many Sources.
     */
    data: SourcesCreateManyInput | SourcesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sources update
   */
  export type SourcesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sources
     */
    select?: SourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sources
     */
    omit?: SourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcesInclude<ExtArgs> | null
    /**
     * The data needed to update a Sources.
     */
    data: XOR<SourcesUpdateInput, SourcesUncheckedUpdateInput>
    /**
     * Choose, which Sources to update.
     */
    where: SourcesWhereUniqueInput
  }

  /**
   * Sources updateMany
   */
  export type SourcesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sources.
     */
    data: XOR<SourcesUpdateManyMutationInput, SourcesUncheckedUpdateManyInput>
    /**
     * Filter which Sources to update
     */
    where?: SourcesWhereInput
    /**
     * Limit how many Sources to update.
     */
    limit?: number
  }

  /**
   * Sources updateManyAndReturn
   */
  export type SourcesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sources
     */
    select?: SourcesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sources
     */
    omit?: SourcesOmit<ExtArgs> | null
    /**
     * The data used to update Sources.
     */
    data: XOR<SourcesUpdateManyMutationInput, SourcesUncheckedUpdateManyInput>
    /**
     * Filter which Sources to update
     */
    where?: SourcesWhereInput
    /**
     * Limit how many Sources to update.
     */
    limit?: number
  }

  /**
   * Sources upsert
   */
  export type SourcesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sources
     */
    select?: SourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sources
     */
    omit?: SourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcesInclude<ExtArgs> | null
    /**
     * The filter to search for the Sources to update in case it exists.
     */
    where: SourcesWhereUniqueInput
    /**
     * In case the Sources found by the `where` argument doesn't exist, create a new Sources with this data.
     */
    create: XOR<SourcesCreateInput, SourcesUncheckedCreateInput>
    /**
     * In case the Sources was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SourcesUpdateInput, SourcesUncheckedUpdateInput>
  }

  /**
   * Sources delete
   */
  export type SourcesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sources
     */
    select?: SourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sources
     */
    omit?: SourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcesInclude<ExtArgs> | null
    /**
     * Filter which Sources to delete.
     */
    where: SourcesWhereUniqueInput
  }

  /**
   * Sources deleteMany
   */
  export type SourcesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sources to delete
     */
    where?: SourcesWhereInput
    /**
     * Limit how many Sources to delete.
     */
    limit?: number
  }

  /**
   * Sources.Ranks
   */
  export type Sources$RanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksInclude<ExtArgs> | null
    where?: RanksWhereInput
    orderBy?: RanksOrderByWithRelationInput | RanksOrderByWithRelationInput[]
    cursor?: RanksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RanksScalarFieldEnum | RanksScalarFieldEnum[]
  }

  /**
   * Sources without action
   */
  export type SourcesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sources
     */
    select?: SourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sources
     */
    omit?: SourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcesInclude<ExtArgs> | null
  }


  /**
   * Model TopicUserInteresteds
   */

  export type AggregateTopicUserInteresteds = {
    _count: TopicUserInterestedsCountAggregateOutputType | null
    _min: TopicUserInterestedsMinAggregateOutputType | null
    _max: TopicUserInterestedsMaxAggregateOutputType | null
  }

  export type TopicUserInterestedsMinAggregateOutputType = {
    userId: string | null
    topicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TopicUserInterestedsMaxAggregateOutputType = {
    userId: string | null
    topicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TopicUserInterestedsCountAggregateOutputType = {
    userId: number
    topicId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TopicUserInterestedsMinAggregateInputType = {
    userId?: true
    topicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TopicUserInterestedsMaxAggregateInputType = {
    userId?: true
    topicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TopicUserInterestedsCountAggregateInputType = {
    userId?: true
    topicId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TopicUserInterestedsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TopicUserInteresteds to aggregate.
     */
    where?: TopicUserInterestedsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopicUserInteresteds to fetch.
     */
    orderBy?: TopicUserInterestedsOrderByWithRelationInput | TopicUserInterestedsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopicUserInterestedsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopicUserInteresteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopicUserInteresteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TopicUserInteresteds
    **/
    _count?: true | TopicUserInterestedsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicUserInterestedsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicUserInterestedsMaxAggregateInputType
  }

  export type GetTopicUserInterestedsAggregateType<T extends TopicUserInterestedsAggregateArgs> = {
        [P in keyof T & keyof AggregateTopicUserInteresteds]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopicUserInteresteds[P]>
      : GetScalarType<T[P], AggregateTopicUserInteresteds[P]>
  }




  export type TopicUserInterestedsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicUserInterestedsWhereInput
    orderBy?: TopicUserInterestedsOrderByWithAggregationInput | TopicUserInterestedsOrderByWithAggregationInput[]
    by: TopicUserInterestedsScalarFieldEnum[] | TopicUserInterestedsScalarFieldEnum
    having?: TopicUserInterestedsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicUserInterestedsCountAggregateInputType | true
    _min?: TopicUserInterestedsMinAggregateInputType
    _max?: TopicUserInterestedsMaxAggregateInputType
  }

  export type TopicUserInterestedsGroupByOutputType = {
    userId: string
    topicId: string
    createdAt: Date
    updatedAt: Date
    _count: TopicUserInterestedsCountAggregateOutputType | null
    _min: TopicUserInterestedsMinAggregateOutputType | null
    _max: TopicUserInterestedsMaxAggregateOutputType | null
  }

  type GetTopicUserInterestedsGroupByPayload<T extends TopicUserInterestedsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopicUserInterestedsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicUserInterestedsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicUserInterestedsGroupByOutputType[P]>
            : GetScalarType<T[P], TopicUserInterestedsGroupByOutputType[P]>
        }
      >
    >


  export type TopicUserInterestedsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Topics?: boolean | TopicsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topicUserInteresteds"]>

  export type TopicUserInterestedsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Topics?: boolean | TopicsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topicUserInteresteds"]>

  export type TopicUserInterestedsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Topics?: boolean | TopicsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topicUserInteresteds"]>

  export type TopicUserInterestedsSelectScalar = {
    userId?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TopicUserInterestedsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "topicId" | "createdAt" | "updatedAt", ExtArgs["result"]["topicUserInteresteds"]>
  export type TopicUserInterestedsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Topics?: boolean | TopicsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type TopicUserInterestedsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Topics?: boolean | TopicsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type TopicUserInterestedsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Topics?: boolean | TopicsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $TopicUserInterestedsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TopicUserInteresteds"
    objects: {
      Topics: Prisma.$TopicsPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      topicId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["topicUserInteresteds"]>
    composites: {}
  }

  type TopicUserInterestedsGetPayload<S extends boolean | null | undefined | TopicUserInterestedsDefaultArgs> = $Result.GetResult<Prisma.$TopicUserInterestedsPayload, S>

  type TopicUserInterestedsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TopicUserInterestedsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TopicUserInterestedsCountAggregateInputType | true
    }

  export interface TopicUserInterestedsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TopicUserInteresteds'], meta: { name: 'TopicUserInteresteds' } }
    /**
     * Find zero or one TopicUserInteresteds that matches the filter.
     * @param {TopicUserInterestedsFindUniqueArgs} args - Arguments to find a TopicUserInteresteds
     * @example
     * // Get one TopicUserInteresteds
     * const topicUserInteresteds = await prisma.topicUserInteresteds.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopicUserInterestedsFindUniqueArgs>(args: SelectSubset<T, TopicUserInterestedsFindUniqueArgs<ExtArgs>>): Prisma__TopicUserInterestedsClient<$Result.GetResult<Prisma.$TopicUserInterestedsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TopicUserInteresteds that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TopicUserInterestedsFindUniqueOrThrowArgs} args - Arguments to find a TopicUserInteresteds
     * @example
     * // Get one TopicUserInteresteds
     * const topicUserInteresteds = await prisma.topicUserInteresteds.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopicUserInterestedsFindUniqueOrThrowArgs>(args: SelectSubset<T, TopicUserInterestedsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TopicUserInterestedsClient<$Result.GetResult<Prisma.$TopicUserInterestedsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TopicUserInteresteds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicUserInterestedsFindFirstArgs} args - Arguments to find a TopicUserInteresteds
     * @example
     * // Get one TopicUserInteresteds
     * const topicUserInteresteds = await prisma.topicUserInteresteds.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopicUserInterestedsFindFirstArgs>(args?: SelectSubset<T, TopicUserInterestedsFindFirstArgs<ExtArgs>>): Prisma__TopicUserInterestedsClient<$Result.GetResult<Prisma.$TopicUserInterestedsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TopicUserInteresteds that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicUserInterestedsFindFirstOrThrowArgs} args - Arguments to find a TopicUserInteresteds
     * @example
     * // Get one TopicUserInteresteds
     * const topicUserInteresteds = await prisma.topicUserInteresteds.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopicUserInterestedsFindFirstOrThrowArgs>(args?: SelectSubset<T, TopicUserInterestedsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TopicUserInterestedsClient<$Result.GetResult<Prisma.$TopicUserInterestedsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TopicUserInteresteds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicUserInterestedsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TopicUserInteresteds
     * const topicUserInteresteds = await prisma.topicUserInteresteds.findMany()
     * 
     * // Get first 10 TopicUserInteresteds
     * const topicUserInteresteds = await prisma.topicUserInteresteds.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const topicUserInterestedsWithUserIdOnly = await prisma.topicUserInteresteds.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends TopicUserInterestedsFindManyArgs>(args?: SelectSubset<T, TopicUserInterestedsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicUserInterestedsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TopicUserInteresteds.
     * @param {TopicUserInterestedsCreateArgs} args - Arguments to create a TopicUserInteresteds.
     * @example
     * // Create one TopicUserInteresteds
     * const TopicUserInteresteds = await prisma.topicUserInteresteds.create({
     *   data: {
     *     // ... data to create a TopicUserInteresteds
     *   }
     * })
     * 
     */
    create<T extends TopicUserInterestedsCreateArgs>(args: SelectSubset<T, TopicUserInterestedsCreateArgs<ExtArgs>>): Prisma__TopicUserInterestedsClient<$Result.GetResult<Prisma.$TopicUserInterestedsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TopicUserInteresteds.
     * @param {TopicUserInterestedsCreateManyArgs} args - Arguments to create many TopicUserInteresteds.
     * @example
     * // Create many TopicUserInteresteds
     * const topicUserInteresteds = await prisma.topicUserInteresteds.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TopicUserInterestedsCreateManyArgs>(args?: SelectSubset<T, TopicUserInterestedsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TopicUserInteresteds and returns the data saved in the database.
     * @param {TopicUserInterestedsCreateManyAndReturnArgs} args - Arguments to create many TopicUserInteresteds.
     * @example
     * // Create many TopicUserInteresteds
     * const topicUserInteresteds = await prisma.topicUserInteresteds.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TopicUserInteresteds and only return the `userId`
     * const topicUserInterestedsWithUserIdOnly = await prisma.topicUserInteresteds.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TopicUserInterestedsCreateManyAndReturnArgs>(args?: SelectSubset<T, TopicUserInterestedsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicUserInterestedsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TopicUserInteresteds.
     * @param {TopicUserInterestedsDeleteArgs} args - Arguments to delete one TopicUserInteresteds.
     * @example
     * // Delete one TopicUserInteresteds
     * const TopicUserInteresteds = await prisma.topicUserInteresteds.delete({
     *   where: {
     *     // ... filter to delete one TopicUserInteresteds
     *   }
     * })
     * 
     */
    delete<T extends TopicUserInterestedsDeleteArgs>(args: SelectSubset<T, TopicUserInterestedsDeleteArgs<ExtArgs>>): Prisma__TopicUserInterestedsClient<$Result.GetResult<Prisma.$TopicUserInterestedsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TopicUserInteresteds.
     * @param {TopicUserInterestedsUpdateArgs} args - Arguments to update one TopicUserInteresteds.
     * @example
     * // Update one TopicUserInteresteds
     * const topicUserInteresteds = await prisma.topicUserInteresteds.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TopicUserInterestedsUpdateArgs>(args: SelectSubset<T, TopicUserInterestedsUpdateArgs<ExtArgs>>): Prisma__TopicUserInterestedsClient<$Result.GetResult<Prisma.$TopicUserInterestedsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TopicUserInteresteds.
     * @param {TopicUserInterestedsDeleteManyArgs} args - Arguments to filter TopicUserInteresteds to delete.
     * @example
     * // Delete a few TopicUserInteresteds
     * const { count } = await prisma.topicUserInteresteds.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TopicUserInterestedsDeleteManyArgs>(args?: SelectSubset<T, TopicUserInterestedsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TopicUserInteresteds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicUserInterestedsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TopicUserInteresteds
     * const topicUserInteresteds = await prisma.topicUserInteresteds.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TopicUserInterestedsUpdateManyArgs>(args: SelectSubset<T, TopicUserInterestedsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TopicUserInteresteds and returns the data updated in the database.
     * @param {TopicUserInterestedsUpdateManyAndReturnArgs} args - Arguments to update many TopicUserInteresteds.
     * @example
     * // Update many TopicUserInteresteds
     * const topicUserInteresteds = await prisma.topicUserInteresteds.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TopicUserInteresteds and only return the `userId`
     * const topicUserInterestedsWithUserIdOnly = await prisma.topicUserInteresteds.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TopicUserInterestedsUpdateManyAndReturnArgs>(args: SelectSubset<T, TopicUserInterestedsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicUserInterestedsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TopicUserInteresteds.
     * @param {TopicUserInterestedsUpsertArgs} args - Arguments to update or create a TopicUserInteresteds.
     * @example
     * // Update or create a TopicUserInteresteds
     * const topicUserInteresteds = await prisma.topicUserInteresteds.upsert({
     *   create: {
     *     // ... data to create a TopicUserInteresteds
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TopicUserInteresteds we want to update
     *   }
     * })
     */
    upsert<T extends TopicUserInterestedsUpsertArgs>(args: SelectSubset<T, TopicUserInterestedsUpsertArgs<ExtArgs>>): Prisma__TopicUserInterestedsClient<$Result.GetResult<Prisma.$TopicUserInterestedsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TopicUserInteresteds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicUserInterestedsCountArgs} args - Arguments to filter TopicUserInteresteds to count.
     * @example
     * // Count the number of TopicUserInteresteds
     * const count = await prisma.topicUserInteresteds.count({
     *   where: {
     *     // ... the filter for the TopicUserInteresteds we want to count
     *   }
     * })
    **/
    count<T extends TopicUserInterestedsCountArgs>(
      args?: Subset<T, TopicUserInterestedsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicUserInterestedsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TopicUserInteresteds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicUserInterestedsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicUserInterestedsAggregateArgs>(args: Subset<T, TopicUserInterestedsAggregateArgs>): Prisma.PrismaPromise<GetTopicUserInterestedsAggregateType<T>>

    /**
     * Group by TopicUserInteresteds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicUserInterestedsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopicUserInterestedsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicUserInterestedsGroupByArgs['orderBy'] }
        : { orderBy?: TopicUserInterestedsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopicUserInterestedsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicUserInterestedsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TopicUserInteresteds model
   */
  readonly fields: TopicUserInterestedsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TopicUserInteresteds.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopicUserInterestedsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Topics<T extends TopicsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TopicsDefaultArgs<ExtArgs>>): Prisma__TopicsClient<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TopicUserInteresteds model
   */ 
  interface TopicUserInterestedsFieldRefs {
    readonly userId: FieldRef<"TopicUserInteresteds", 'String'>
    readonly topicId: FieldRef<"TopicUserInteresteds", 'String'>
    readonly createdAt: FieldRef<"TopicUserInteresteds", 'DateTime'>
    readonly updatedAt: FieldRef<"TopicUserInteresteds", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TopicUserInteresteds findUnique
   */
  export type TopicUserInterestedsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicUserInteresteds
     */
    select?: TopicUserInterestedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicUserInteresteds
     */
    omit?: TopicUserInterestedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicUserInterestedsInclude<ExtArgs> | null
    /**
     * Filter, which TopicUserInteresteds to fetch.
     */
    where: TopicUserInterestedsWhereUniqueInput
  }

  /**
   * TopicUserInteresteds findUniqueOrThrow
   */
  export type TopicUserInterestedsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicUserInteresteds
     */
    select?: TopicUserInterestedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicUserInteresteds
     */
    omit?: TopicUserInterestedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicUserInterestedsInclude<ExtArgs> | null
    /**
     * Filter, which TopicUserInteresteds to fetch.
     */
    where: TopicUserInterestedsWhereUniqueInput
  }

  /**
   * TopicUserInteresteds findFirst
   */
  export type TopicUserInterestedsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicUserInteresteds
     */
    select?: TopicUserInterestedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicUserInteresteds
     */
    omit?: TopicUserInterestedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicUserInterestedsInclude<ExtArgs> | null
    /**
     * Filter, which TopicUserInteresteds to fetch.
     */
    where?: TopicUserInterestedsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopicUserInteresteds to fetch.
     */
    orderBy?: TopicUserInterestedsOrderByWithRelationInput | TopicUserInterestedsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TopicUserInteresteds.
     */
    cursor?: TopicUserInterestedsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopicUserInteresteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopicUserInteresteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TopicUserInteresteds.
     */
    distinct?: TopicUserInterestedsScalarFieldEnum | TopicUserInterestedsScalarFieldEnum[]
  }

  /**
   * TopicUserInteresteds findFirstOrThrow
   */
  export type TopicUserInterestedsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicUserInteresteds
     */
    select?: TopicUserInterestedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicUserInteresteds
     */
    omit?: TopicUserInterestedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicUserInterestedsInclude<ExtArgs> | null
    /**
     * Filter, which TopicUserInteresteds to fetch.
     */
    where?: TopicUserInterestedsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopicUserInteresteds to fetch.
     */
    orderBy?: TopicUserInterestedsOrderByWithRelationInput | TopicUserInterestedsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TopicUserInteresteds.
     */
    cursor?: TopicUserInterestedsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopicUserInteresteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopicUserInteresteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TopicUserInteresteds.
     */
    distinct?: TopicUserInterestedsScalarFieldEnum | TopicUserInterestedsScalarFieldEnum[]
  }

  /**
   * TopicUserInteresteds findMany
   */
  export type TopicUserInterestedsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicUserInteresteds
     */
    select?: TopicUserInterestedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicUserInteresteds
     */
    omit?: TopicUserInterestedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicUserInterestedsInclude<ExtArgs> | null
    /**
     * Filter, which TopicUserInteresteds to fetch.
     */
    where?: TopicUserInterestedsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopicUserInteresteds to fetch.
     */
    orderBy?: TopicUserInterestedsOrderByWithRelationInput | TopicUserInterestedsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TopicUserInteresteds.
     */
    cursor?: TopicUserInterestedsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopicUserInteresteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopicUserInteresteds.
     */
    skip?: number
    distinct?: TopicUserInterestedsScalarFieldEnum | TopicUserInterestedsScalarFieldEnum[]
  }

  /**
   * TopicUserInteresteds create
   */
  export type TopicUserInterestedsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicUserInteresteds
     */
    select?: TopicUserInterestedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicUserInteresteds
     */
    omit?: TopicUserInterestedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicUserInterestedsInclude<ExtArgs> | null
    /**
     * The data needed to create a TopicUserInteresteds.
     */
    data: XOR<TopicUserInterestedsCreateInput, TopicUserInterestedsUncheckedCreateInput>
  }

  /**
   * TopicUserInteresteds createMany
   */
  export type TopicUserInterestedsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TopicUserInteresteds.
     */
    data: TopicUserInterestedsCreateManyInput | TopicUserInterestedsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TopicUserInteresteds createManyAndReturn
   */
  export type TopicUserInterestedsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicUserInteresteds
     */
    select?: TopicUserInterestedsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TopicUserInteresteds
     */
    omit?: TopicUserInterestedsOmit<ExtArgs> | null
    /**
     * The data used to create many TopicUserInteresteds.
     */
    data: TopicUserInterestedsCreateManyInput | TopicUserInterestedsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicUserInterestedsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TopicUserInteresteds update
   */
  export type TopicUserInterestedsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicUserInteresteds
     */
    select?: TopicUserInterestedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicUserInteresteds
     */
    omit?: TopicUserInterestedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicUserInterestedsInclude<ExtArgs> | null
    /**
     * The data needed to update a TopicUserInteresteds.
     */
    data: XOR<TopicUserInterestedsUpdateInput, TopicUserInterestedsUncheckedUpdateInput>
    /**
     * Choose, which TopicUserInteresteds to update.
     */
    where: TopicUserInterestedsWhereUniqueInput
  }

  /**
   * TopicUserInteresteds updateMany
   */
  export type TopicUserInterestedsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TopicUserInteresteds.
     */
    data: XOR<TopicUserInterestedsUpdateManyMutationInput, TopicUserInterestedsUncheckedUpdateManyInput>
    /**
     * Filter which TopicUserInteresteds to update
     */
    where?: TopicUserInterestedsWhereInput
    /**
     * Limit how many TopicUserInteresteds to update.
     */
    limit?: number
  }

  /**
   * TopicUserInteresteds updateManyAndReturn
   */
  export type TopicUserInterestedsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicUserInteresteds
     */
    select?: TopicUserInterestedsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TopicUserInteresteds
     */
    omit?: TopicUserInterestedsOmit<ExtArgs> | null
    /**
     * The data used to update TopicUserInteresteds.
     */
    data: XOR<TopicUserInterestedsUpdateManyMutationInput, TopicUserInterestedsUncheckedUpdateManyInput>
    /**
     * Filter which TopicUserInteresteds to update
     */
    where?: TopicUserInterestedsWhereInput
    /**
     * Limit how many TopicUserInteresteds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicUserInterestedsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TopicUserInteresteds upsert
   */
  export type TopicUserInterestedsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicUserInteresteds
     */
    select?: TopicUserInterestedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicUserInteresteds
     */
    omit?: TopicUserInterestedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicUserInterestedsInclude<ExtArgs> | null
    /**
     * The filter to search for the TopicUserInteresteds to update in case it exists.
     */
    where: TopicUserInterestedsWhereUniqueInput
    /**
     * In case the TopicUserInteresteds found by the `where` argument doesn't exist, create a new TopicUserInteresteds with this data.
     */
    create: XOR<TopicUserInterestedsCreateInput, TopicUserInterestedsUncheckedCreateInput>
    /**
     * In case the TopicUserInteresteds was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopicUserInterestedsUpdateInput, TopicUserInterestedsUncheckedUpdateInput>
  }

  /**
   * TopicUserInteresteds delete
   */
  export type TopicUserInterestedsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicUserInteresteds
     */
    select?: TopicUserInterestedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicUserInteresteds
     */
    omit?: TopicUserInterestedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicUserInterestedsInclude<ExtArgs> | null
    /**
     * Filter which TopicUserInteresteds to delete.
     */
    where: TopicUserInterestedsWhereUniqueInput
  }

  /**
   * TopicUserInteresteds deleteMany
   */
  export type TopicUserInterestedsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TopicUserInteresteds to delete
     */
    where?: TopicUserInterestedsWhereInput
    /**
     * Limit how many TopicUserInteresteds to delete.
     */
    limit?: number
  }

  /**
   * TopicUserInteresteds without action
   */
  export type TopicUserInterestedsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicUserInteresteds
     */
    select?: TopicUserInterestedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicUserInteresteds
     */
    omit?: TopicUserInterestedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicUserInterestedsInclude<ExtArgs> | null
  }


  /**
   * Model Topics
   */

  export type AggregateTopics = {
    _count: TopicsCountAggregateOutputType | null
    _min: TopicsMinAggregateOutputType | null
    _max: TopicsMaxAggregateOutputType | null
  }

  export type TopicsMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TopicsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TopicsCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TopicsMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TopicsMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TopicsCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TopicsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topics to aggregate.
     */
    where?: TopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicsOrderByWithRelationInput | TopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Topics
    **/
    _count?: true | TopicsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicsMaxAggregateInputType
  }

  export type GetTopicsAggregateType<T extends TopicsAggregateArgs> = {
        [P in keyof T & keyof AggregateTopics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopics[P]>
      : GetScalarType<T[P], AggregateTopics[P]>
  }




  export type TopicsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicsWhereInput
    orderBy?: TopicsOrderByWithAggregationInput | TopicsOrderByWithAggregationInput[]
    by: TopicsScalarFieldEnum[] | TopicsScalarFieldEnum
    having?: TopicsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicsCountAggregateInputType | true
    _min?: TopicsMinAggregateInputType
    _max?: TopicsMaxAggregateInputType
  }

  export type TopicsGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: TopicsCountAggregateOutputType | null
    _min: TopicsMinAggregateOutputType | null
    _max: TopicsMaxAggregateOutputType | null
  }

  type GetTopicsGroupByPayload<T extends TopicsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopicsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicsGroupByOutputType[P]>
            : GetScalarType<T[P], TopicsGroupByOutputType[P]>
        }
      >
    >


  export type TopicsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ConferenceTopics?: boolean | Topics$ConferenceTopicsArgs<ExtArgs>
    JournalTopics?: boolean | Topics$JournalTopicsArgs<ExtArgs>
    TopicUserInteresteds?: boolean | Topics$TopicUserInterestedsArgs<ExtArgs>
    _count?: boolean | TopicsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topics"]>

  export type TopicsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["topics"]>

  export type TopicsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["topics"]>

  export type TopicsSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TopicsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["topics"]>
  export type TopicsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConferenceTopics?: boolean | Topics$ConferenceTopicsArgs<ExtArgs>
    JournalTopics?: boolean | Topics$JournalTopicsArgs<ExtArgs>
    TopicUserInteresteds?: boolean | Topics$TopicUserInterestedsArgs<ExtArgs>
    _count?: boolean | TopicsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TopicsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TopicsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TopicsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Topics"
    objects: {
      ConferenceTopics: Prisma.$ConferenceTopicsPayload<ExtArgs>[]
      JournalTopics: Prisma.$JournalTopicsPayload<ExtArgs>[]
      TopicUserInteresteds: Prisma.$TopicUserInterestedsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["topics"]>
    composites: {}
  }

  type TopicsGetPayload<S extends boolean | null | undefined | TopicsDefaultArgs> = $Result.GetResult<Prisma.$TopicsPayload, S>

  type TopicsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TopicsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TopicsCountAggregateInputType | true
    }

  export interface TopicsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Topics'], meta: { name: 'Topics' } }
    /**
     * Find zero or one Topics that matches the filter.
     * @param {TopicsFindUniqueArgs} args - Arguments to find a Topics
     * @example
     * // Get one Topics
     * const topics = await prisma.topics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopicsFindUniqueArgs>(args: SelectSubset<T, TopicsFindUniqueArgs<ExtArgs>>): Prisma__TopicsClient<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Topics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TopicsFindUniqueOrThrowArgs} args - Arguments to find a Topics
     * @example
     * // Get one Topics
     * const topics = await prisma.topics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopicsFindUniqueOrThrowArgs>(args: SelectSubset<T, TopicsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TopicsClient<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicsFindFirstArgs} args - Arguments to find a Topics
     * @example
     * // Get one Topics
     * const topics = await prisma.topics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopicsFindFirstArgs>(args?: SelectSubset<T, TopicsFindFirstArgs<ExtArgs>>): Prisma__TopicsClient<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Topics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicsFindFirstOrThrowArgs} args - Arguments to find a Topics
     * @example
     * // Get one Topics
     * const topics = await prisma.topics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopicsFindFirstOrThrowArgs>(args?: SelectSubset<T, TopicsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TopicsClient<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Topics
     * const topics = await prisma.topics.findMany()
     * 
     * // Get first 10 Topics
     * const topics = await prisma.topics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topicsWithIdOnly = await prisma.topics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TopicsFindManyArgs>(args?: SelectSubset<T, TopicsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Topics.
     * @param {TopicsCreateArgs} args - Arguments to create a Topics.
     * @example
     * // Create one Topics
     * const Topics = await prisma.topics.create({
     *   data: {
     *     // ... data to create a Topics
     *   }
     * })
     * 
     */
    create<T extends TopicsCreateArgs>(args: SelectSubset<T, TopicsCreateArgs<ExtArgs>>): Prisma__TopicsClient<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Topics.
     * @param {TopicsCreateManyArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topics = await prisma.topics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TopicsCreateManyArgs>(args?: SelectSubset<T, TopicsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Topics and returns the data saved in the database.
     * @param {TopicsCreateManyAndReturnArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topics = await prisma.topics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Topics and only return the `id`
     * const topicsWithIdOnly = await prisma.topics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TopicsCreateManyAndReturnArgs>(args?: SelectSubset<T, TopicsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Topics.
     * @param {TopicsDeleteArgs} args - Arguments to delete one Topics.
     * @example
     * // Delete one Topics
     * const Topics = await prisma.topics.delete({
     *   where: {
     *     // ... filter to delete one Topics
     *   }
     * })
     * 
     */
    delete<T extends TopicsDeleteArgs>(args: SelectSubset<T, TopicsDeleteArgs<ExtArgs>>): Prisma__TopicsClient<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Topics.
     * @param {TopicsUpdateArgs} args - Arguments to update one Topics.
     * @example
     * // Update one Topics
     * const topics = await prisma.topics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TopicsUpdateArgs>(args: SelectSubset<T, TopicsUpdateArgs<ExtArgs>>): Prisma__TopicsClient<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Topics.
     * @param {TopicsDeleteManyArgs} args - Arguments to filter Topics to delete.
     * @example
     * // Delete a few Topics
     * const { count } = await prisma.topics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TopicsDeleteManyArgs>(args?: SelectSubset<T, TopicsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Topics
     * const topics = await prisma.topics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TopicsUpdateManyArgs>(args: SelectSubset<T, TopicsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics and returns the data updated in the database.
     * @param {TopicsUpdateManyAndReturnArgs} args - Arguments to update many Topics.
     * @example
     * // Update many Topics
     * const topics = await prisma.topics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Topics and only return the `id`
     * const topicsWithIdOnly = await prisma.topics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TopicsUpdateManyAndReturnArgs>(args: SelectSubset<T, TopicsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Topics.
     * @param {TopicsUpsertArgs} args - Arguments to update or create a Topics.
     * @example
     * // Update or create a Topics
     * const topics = await prisma.topics.upsert({
     *   create: {
     *     // ... data to create a Topics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Topics we want to update
     *   }
     * })
     */
    upsert<T extends TopicsUpsertArgs>(args: SelectSubset<T, TopicsUpsertArgs<ExtArgs>>): Prisma__TopicsClient<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicsCountArgs} args - Arguments to filter Topics to count.
     * @example
     * // Count the number of Topics
     * const count = await prisma.topics.count({
     *   where: {
     *     // ... the filter for the Topics we want to count
     *   }
     * })
    **/
    count<T extends TopicsCountArgs>(
      args?: Subset<T, TopicsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicsAggregateArgs>(args: Subset<T, TopicsAggregateArgs>): Prisma.PrismaPromise<GetTopicsAggregateType<T>>

    /**
     * Group by Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopicsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicsGroupByArgs['orderBy'] }
        : { orderBy?: TopicsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopicsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Topics model
   */
  readonly fields: TopicsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Topics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopicsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ConferenceTopics<T extends Topics$ConferenceTopicsArgs<ExtArgs> = {}>(args?: Subset<T, Topics$ConferenceTopicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    JournalTopics<T extends Topics$JournalTopicsArgs<ExtArgs> = {}>(args?: Subset<T, Topics$JournalTopicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TopicUserInteresteds<T extends Topics$TopicUserInterestedsArgs<ExtArgs> = {}>(args?: Subset<T, Topics$TopicUserInterestedsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicUserInterestedsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Topics model
   */ 
  interface TopicsFieldRefs {
    readonly id: FieldRef<"Topics", 'String'>
    readonly name: FieldRef<"Topics", 'String'>
    readonly createdAt: FieldRef<"Topics", 'DateTime'>
    readonly updatedAt: FieldRef<"Topics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Topics findUnique
   */
  export type TopicsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topics
     */
    select?: TopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topics
     */
    omit?: TopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicsInclude<ExtArgs> | null
    /**
     * Filter, which Topics to fetch.
     */
    where: TopicsWhereUniqueInput
  }

  /**
   * Topics findUniqueOrThrow
   */
  export type TopicsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topics
     */
    select?: TopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topics
     */
    omit?: TopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicsInclude<ExtArgs> | null
    /**
     * Filter, which Topics to fetch.
     */
    where: TopicsWhereUniqueInput
  }

  /**
   * Topics findFirst
   */
  export type TopicsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topics
     */
    select?: TopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topics
     */
    omit?: TopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicsInclude<ExtArgs> | null
    /**
     * Filter, which Topics to fetch.
     */
    where?: TopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicsOrderByWithRelationInput | TopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicsScalarFieldEnum | TopicsScalarFieldEnum[]
  }

  /**
   * Topics findFirstOrThrow
   */
  export type TopicsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topics
     */
    select?: TopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topics
     */
    omit?: TopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicsInclude<ExtArgs> | null
    /**
     * Filter, which Topics to fetch.
     */
    where?: TopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicsOrderByWithRelationInput | TopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicsScalarFieldEnum | TopicsScalarFieldEnum[]
  }

  /**
   * Topics findMany
   */
  export type TopicsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topics
     */
    select?: TopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topics
     */
    omit?: TopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicsInclude<ExtArgs> | null
    /**
     * Filter, which Topics to fetch.
     */
    where?: TopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicsOrderByWithRelationInput | TopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Topics.
     */
    cursor?: TopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    distinct?: TopicsScalarFieldEnum | TopicsScalarFieldEnum[]
  }

  /**
   * Topics create
   */
  export type TopicsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topics
     */
    select?: TopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topics
     */
    omit?: TopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicsInclude<ExtArgs> | null
    /**
     * The data needed to create a Topics.
     */
    data: XOR<TopicsCreateInput, TopicsUncheckedCreateInput>
  }

  /**
   * Topics createMany
   */
  export type TopicsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Topics.
     */
    data: TopicsCreateManyInput | TopicsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Topics createManyAndReturn
   */
  export type TopicsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topics
     */
    select?: TopicsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Topics
     */
    omit?: TopicsOmit<ExtArgs> | null
    /**
     * The data used to create many Topics.
     */
    data: TopicsCreateManyInput | TopicsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Topics update
   */
  export type TopicsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topics
     */
    select?: TopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topics
     */
    omit?: TopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicsInclude<ExtArgs> | null
    /**
     * The data needed to update a Topics.
     */
    data: XOR<TopicsUpdateInput, TopicsUncheckedUpdateInput>
    /**
     * Choose, which Topics to update.
     */
    where: TopicsWhereUniqueInput
  }

  /**
   * Topics updateMany
   */
  export type TopicsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicsUpdateManyMutationInput, TopicsUncheckedUpdateManyInput>
    /**
     * Filter which Topics to update
     */
    where?: TopicsWhereInput
    /**
     * Limit how many Topics to update.
     */
    limit?: number
  }

  /**
   * Topics updateManyAndReturn
   */
  export type TopicsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topics
     */
    select?: TopicsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Topics
     */
    omit?: TopicsOmit<ExtArgs> | null
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicsUpdateManyMutationInput, TopicsUncheckedUpdateManyInput>
    /**
     * Filter which Topics to update
     */
    where?: TopicsWhereInput
    /**
     * Limit how many Topics to update.
     */
    limit?: number
  }

  /**
   * Topics upsert
   */
  export type TopicsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topics
     */
    select?: TopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topics
     */
    omit?: TopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicsInclude<ExtArgs> | null
    /**
     * The filter to search for the Topics to update in case it exists.
     */
    where: TopicsWhereUniqueInput
    /**
     * In case the Topics found by the `where` argument doesn't exist, create a new Topics with this data.
     */
    create: XOR<TopicsCreateInput, TopicsUncheckedCreateInput>
    /**
     * In case the Topics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopicsUpdateInput, TopicsUncheckedUpdateInput>
  }

  /**
   * Topics delete
   */
  export type TopicsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topics
     */
    select?: TopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topics
     */
    omit?: TopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicsInclude<ExtArgs> | null
    /**
     * Filter which Topics to delete.
     */
    where: TopicsWhereUniqueInput
  }

  /**
   * Topics deleteMany
   */
  export type TopicsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topics to delete
     */
    where?: TopicsWhereInput
    /**
     * Limit how many Topics to delete.
     */
    limit?: number
  }

  /**
   * Topics.ConferenceTopics
   */
  export type Topics$ConferenceTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsInclude<ExtArgs> | null
    where?: ConferenceTopicsWhereInput
    orderBy?: ConferenceTopicsOrderByWithRelationInput | ConferenceTopicsOrderByWithRelationInput[]
    cursor?: ConferenceTopicsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceTopicsScalarFieldEnum | ConferenceTopicsScalarFieldEnum[]
  }

  /**
   * Topics.JournalTopics
   */
  export type Topics$JournalTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsInclude<ExtArgs> | null
    where?: JournalTopicsWhereInput
    orderBy?: JournalTopicsOrderByWithRelationInput | JournalTopicsOrderByWithRelationInput[]
    cursor?: JournalTopicsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalTopicsScalarFieldEnum | JournalTopicsScalarFieldEnum[]
  }

  /**
   * Topics.TopicUserInteresteds
   */
  export type Topics$TopicUserInterestedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicUserInteresteds
     */
    select?: TopicUserInterestedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicUserInteresteds
     */
    omit?: TopicUserInterestedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicUserInterestedsInclude<ExtArgs> | null
    where?: TopicUserInterestedsWhereInput
    orderBy?: TopicUserInterestedsOrderByWithRelationInput | TopicUserInterestedsOrderByWithRelationInput[]
    cursor?: TopicUserInterestedsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicUserInterestedsScalarFieldEnum | TopicUserInterestedsScalarFieldEnum[]
  }

  /**
   * Topics without action
   */
  export type TopicsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topics
     */
    select?: TopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topics
     */
    omit?: TopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicsInclude<ExtArgs> | null
  }


  /**
   * Model UserVerification
   */

  export type AggregateUserVerification = {
    _count: UserVerificationCountAggregateOutputType | null
    _min: UserVerificationMinAggregateOutputType | null
    _max: UserVerificationMaxAggregateOutputType | null
  }

  export type UserVerificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    verificationCode: string | null
    verificationCodeExpires: Date | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserVerificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    verificationCode: string | null
    verificationCodeExpires: Date | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserVerificationCountAggregateOutputType = {
    id: number
    userId: number
    verificationCode: number
    verificationCodeExpires: number
    isVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserVerificationMinAggregateInputType = {
    id?: true
    userId?: true
    verificationCode?: true
    verificationCodeExpires?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserVerificationMaxAggregateInputType = {
    id?: true
    userId?: true
    verificationCode?: true
    verificationCodeExpires?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserVerificationCountAggregateInputType = {
    id?: true
    userId?: true
    verificationCode?: true
    verificationCodeExpires?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserVerification to aggregate.
     */
    where?: UserVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserVerifications to fetch.
     */
    orderBy?: UserVerificationOrderByWithRelationInput | UserVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserVerifications
    **/
    _count?: true | UserVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserVerificationMaxAggregateInputType
  }

  export type GetUserVerificationAggregateType<T extends UserVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserVerification[P]>
      : GetScalarType<T[P], AggregateUserVerification[P]>
  }




  export type UserVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserVerificationWhereInput
    orderBy?: UserVerificationOrderByWithAggregationInput | UserVerificationOrderByWithAggregationInput[]
    by: UserVerificationScalarFieldEnum[] | UserVerificationScalarFieldEnum
    having?: UserVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserVerificationCountAggregateInputType | true
    _min?: UserVerificationMinAggregateInputType
    _max?: UserVerificationMaxAggregateInputType
  }

  export type UserVerificationGroupByOutputType = {
    id: string
    userId: string
    verificationCode: string
    verificationCodeExpires: Date
    isVerified: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserVerificationCountAggregateOutputType | null
    _min: UserVerificationMinAggregateOutputType | null
    _max: UserVerificationMaxAggregateOutputType | null
  }

  type GetUserVerificationGroupByPayload<T extends UserVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], UserVerificationGroupByOutputType[P]>
        }
      >
    >


  export type UserVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    verificationCode?: boolean
    verificationCodeExpires?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userVerification"]>

  export type UserVerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    verificationCode?: boolean
    verificationCodeExpires?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userVerification"]>

  export type UserVerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    verificationCode?: boolean
    verificationCodeExpires?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userVerification"]>

  export type UserVerificationSelectScalar = {
    id?: boolean
    userId?: boolean
    verificationCode?: boolean
    verificationCodeExpires?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserVerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "verificationCode" | "verificationCodeExpires" | "isVerified" | "createdAt" | "updatedAt", ExtArgs["result"]["userVerification"]>
  export type UserVerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type UserVerificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type UserVerificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $UserVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserVerification"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      verificationCode: string
      verificationCodeExpires: Date
      isVerified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userVerification"]>
    composites: {}
  }

  type UserVerificationGetPayload<S extends boolean | null | undefined | UserVerificationDefaultArgs> = $Result.GetResult<Prisma.$UserVerificationPayload, S>

  type UserVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserVerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserVerificationCountAggregateInputType | true
    }

  export interface UserVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserVerification'], meta: { name: 'UserVerification' } }
    /**
     * Find zero or one UserVerification that matches the filter.
     * @param {UserVerificationFindUniqueArgs} args - Arguments to find a UserVerification
     * @example
     * // Get one UserVerification
     * const userVerification = await prisma.userVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserVerificationFindUniqueArgs>(args: SelectSubset<T, UserVerificationFindUniqueArgs<ExtArgs>>): Prisma__UserVerificationClient<$Result.GetResult<Prisma.$UserVerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserVerification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserVerificationFindUniqueOrThrowArgs} args - Arguments to find a UserVerification
     * @example
     * // Get one UserVerification
     * const userVerification = await prisma.userVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, UserVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserVerificationClient<$Result.GetResult<Prisma.$UserVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserVerificationFindFirstArgs} args - Arguments to find a UserVerification
     * @example
     * // Get one UserVerification
     * const userVerification = await prisma.userVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserVerificationFindFirstArgs>(args?: SelectSubset<T, UserVerificationFindFirstArgs<ExtArgs>>): Prisma__UserVerificationClient<$Result.GetResult<Prisma.$UserVerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserVerificationFindFirstOrThrowArgs} args - Arguments to find a UserVerification
     * @example
     * // Get one UserVerification
     * const userVerification = await prisma.userVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, UserVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserVerificationClient<$Result.GetResult<Prisma.$UserVerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserVerifications
     * const userVerifications = await prisma.userVerification.findMany()
     * 
     * // Get first 10 UserVerifications
     * const userVerifications = await prisma.userVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userVerificationWithIdOnly = await prisma.userVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserVerificationFindManyArgs>(args?: SelectSubset<T, UserVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserVerification.
     * @param {UserVerificationCreateArgs} args - Arguments to create a UserVerification.
     * @example
     * // Create one UserVerification
     * const UserVerification = await prisma.userVerification.create({
     *   data: {
     *     // ... data to create a UserVerification
     *   }
     * })
     * 
     */
    create<T extends UserVerificationCreateArgs>(args: SelectSubset<T, UserVerificationCreateArgs<ExtArgs>>): Prisma__UserVerificationClient<$Result.GetResult<Prisma.$UserVerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserVerifications.
     * @param {UserVerificationCreateManyArgs} args - Arguments to create many UserVerifications.
     * @example
     * // Create many UserVerifications
     * const userVerification = await prisma.userVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserVerificationCreateManyArgs>(args?: SelectSubset<T, UserVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserVerifications and returns the data saved in the database.
     * @param {UserVerificationCreateManyAndReturnArgs} args - Arguments to create many UserVerifications.
     * @example
     * // Create many UserVerifications
     * const userVerification = await prisma.userVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserVerifications and only return the `id`
     * const userVerificationWithIdOnly = await prisma.userVerification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserVerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, UserVerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserVerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserVerification.
     * @param {UserVerificationDeleteArgs} args - Arguments to delete one UserVerification.
     * @example
     * // Delete one UserVerification
     * const UserVerification = await prisma.userVerification.delete({
     *   where: {
     *     // ... filter to delete one UserVerification
     *   }
     * })
     * 
     */
    delete<T extends UserVerificationDeleteArgs>(args: SelectSubset<T, UserVerificationDeleteArgs<ExtArgs>>): Prisma__UserVerificationClient<$Result.GetResult<Prisma.$UserVerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserVerification.
     * @param {UserVerificationUpdateArgs} args - Arguments to update one UserVerification.
     * @example
     * // Update one UserVerification
     * const userVerification = await prisma.userVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserVerificationUpdateArgs>(args: SelectSubset<T, UserVerificationUpdateArgs<ExtArgs>>): Prisma__UserVerificationClient<$Result.GetResult<Prisma.$UserVerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserVerifications.
     * @param {UserVerificationDeleteManyArgs} args - Arguments to filter UserVerifications to delete.
     * @example
     * // Delete a few UserVerifications
     * const { count } = await prisma.userVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserVerificationDeleteManyArgs>(args?: SelectSubset<T, UserVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserVerifications
     * const userVerification = await prisma.userVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserVerificationUpdateManyArgs>(args: SelectSubset<T, UserVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserVerifications and returns the data updated in the database.
     * @param {UserVerificationUpdateManyAndReturnArgs} args - Arguments to update many UserVerifications.
     * @example
     * // Update many UserVerifications
     * const userVerification = await prisma.userVerification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserVerifications and only return the `id`
     * const userVerificationWithIdOnly = await prisma.userVerification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserVerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, UserVerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserVerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserVerification.
     * @param {UserVerificationUpsertArgs} args - Arguments to update or create a UserVerification.
     * @example
     * // Update or create a UserVerification
     * const userVerification = await prisma.userVerification.upsert({
     *   create: {
     *     // ... data to create a UserVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserVerification we want to update
     *   }
     * })
     */
    upsert<T extends UserVerificationUpsertArgs>(args: SelectSubset<T, UserVerificationUpsertArgs<ExtArgs>>): Prisma__UserVerificationClient<$Result.GetResult<Prisma.$UserVerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserVerificationCountArgs} args - Arguments to filter UserVerifications to count.
     * @example
     * // Count the number of UserVerifications
     * const count = await prisma.userVerification.count({
     *   where: {
     *     // ... the filter for the UserVerifications we want to count
     *   }
     * })
    **/
    count<T extends UserVerificationCountArgs>(
      args?: Subset<T, UserVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserVerificationAggregateArgs>(args: Subset<T, UserVerificationAggregateArgs>): Prisma.PrismaPromise<GetUserVerificationAggregateType<T>>

    /**
     * Group by UserVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserVerificationGroupByArgs['orderBy'] }
        : { orderBy?: UserVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserVerification model
   */
  readonly fields: UserVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserVerification model
   */ 
  interface UserVerificationFieldRefs {
    readonly id: FieldRef<"UserVerification", 'String'>
    readonly userId: FieldRef<"UserVerification", 'String'>
    readonly verificationCode: FieldRef<"UserVerification", 'String'>
    readonly verificationCodeExpires: FieldRef<"UserVerification", 'DateTime'>
    readonly isVerified: FieldRef<"UserVerification", 'Boolean'>
    readonly createdAt: FieldRef<"UserVerification", 'DateTime'>
    readonly updatedAt: FieldRef<"UserVerification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserVerification findUnique
   */
  export type UserVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVerification
     */
    select?: UserVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserVerification
     */
    omit?: UserVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVerificationInclude<ExtArgs> | null
    /**
     * Filter, which UserVerification to fetch.
     */
    where: UserVerificationWhereUniqueInput
  }

  /**
   * UserVerification findUniqueOrThrow
   */
  export type UserVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVerification
     */
    select?: UserVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserVerification
     */
    omit?: UserVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVerificationInclude<ExtArgs> | null
    /**
     * Filter, which UserVerification to fetch.
     */
    where: UserVerificationWhereUniqueInput
  }

  /**
   * UserVerification findFirst
   */
  export type UserVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVerification
     */
    select?: UserVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserVerification
     */
    omit?: UserVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVerificationInclude<ExtArgs> | null
    /**
     * Filter, which UserVerification to fetch.
     */
    where?: UserVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserVerifications to fetch.
     */
    orderBy?: UserVerificationOrderByWithRelationInput | UserVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserVerifications.
     */
    cursor?: UserVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserVerifications.
     */
    distinct?: UserVerificationScalarFieldEnum | UserVerificationScalarFieldEnum[]
  }

  /**
   * UserVerification findFirstOrThrow
   */
  export type UserVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVerification
     */
    select?: UserVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserVerification
     */
    omit?: UserVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVerificationInclude<ExtArgs> | null
    /**
     * Filter, which UserVerification to fetch.
     */
    where?: UserVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserVerifications to fetch.
     */
    orderBy?: UserVerificationOrderByWithRelationInput | UserVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserVerifications.
     */
    cursor?: UserVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserVerifications.
     */
    distinct?: UserVerificationScalarFieldEnum | UserVerificationScalarFieldEnum[]
  }

  /**
   * UserVerification findMany
   */
  export type UserVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVerification
     */
    select?: UserVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserVerification
     */
    omit?: UserVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVerificationInclude<ExtArgs> | null
    /**
     * Filter, which UserVerifications to fetch.
     */
    where?: UserVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserVerifications to fetch.
     */
    orderBy?: UserVerificationOrderByWithRelationInput | UserVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserVerifications.
     */
    cursor?: UserVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserVerifications.
     */
    skip?: number
    distinct?: UserVerificationScalarFieldEnum | UserVerificationScalarFieldEnum[]
  }

  /**
   * UserVerification create
   */
  export type UserVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVerification
     */
    select?: UserVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserVerification
     */
    omit?: UserVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a UserVerification.
     */
    data: XOR<UserVerificationCreateInput, UserVerificationUncheckedCreateInput>
  }

  /**
   * UserVerification createMany
   */
  export type UserVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserVerifications.
     */
    data: UserVerificationCreateManyInput | UserVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserVerification createManyAndReturn
   */
  export type UserVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVerification
     */
    select?: UserVerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserVerification
     */
    omit?: UserVerificationOmit<ExtArgs> | null
    /**
     * The data used to create many UserVerifications.
     */
    data: UserVerificationCreateManyInput | UserVerificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVerificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserVerification update
   */
  export type UserVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVerification
     */
    select?: UserVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserVerification
     */
    omit?: UserVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a UserVerification.
     */
    data: XOR<UserVerificationUpdateInput, UserVerificationUncheckedUpdateInput>
    /**
     * Choose, which UserVerification to update.
     */
    where: UserVerificationWhereUniqueInput
  }

  /**
   * UserVerification updateMany
   */
  export type UserVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserVerifications.
     */
    data: XOR<UserVerificationUpdateManyMutationInput, UserVerificationUncheckedUpdateManyInput>
    /**
     * Filter which UserVerifications to update
     */
    where?: UserVerificationWhereInput
    /**
     * Limit how many UserVerifications to update.
     */
    limit?: number
  }

  /**
   * UserVerification updateManyAndReturn
   */
  export type UserVerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVerification
     */
    select?: UserVerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserVerification
     */
    omit?: UserVerificationOmit<ExtArgs> | null
    /**
     * The data used to update UserVerifications.
     */
    data: XOR<UserVerificationUpdateManyMutationInput, UserVerificationUncheckedUpdateManyInput>
    /**
     * Filter which UserVerifications to update
     */
    where?: UserVerificationWhereInput
    /**
     * Limit how many UserVerifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVerificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserVerification upsert
   */
  export type UserVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVerification
     */
    select?: UserVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserVerification
     */
    omit?: UserVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the UserVerification to update in case it exists.
     */
    where: UserVerificationWhereUniqueInput
    /**
     * In case the UserVerification found by the `where` argument doesn't exist, create a new UserVerification with this data.
     */
    create: XOR<UserVerificationCreateInput, UserVerificationUncheckedCreateInput>
    /**
     * In case the UserVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserVerificationUpdateInput, UserVerificationUncheckedUpdateInput>
  }

  /**
   * UserVerification delete
   */
  export type UserVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVerification
     */
    select?: UserVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserVerification
     */
    omit?: UserVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVerificationInclude<ExtArgs> | null
    /**
     * Filter which UserVerification to delete.
     */
    where: UserVerificationWhereUniqueInput
  }

  /**
   * UserVerification deleteMany
   */
  export type UserVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserVerifications to delete
     */
    where?: UserVerificationWhereInput
    /**
     * Limit how many UserVerifications to delete.
     */
    limit?: number
  }

  /**
   * UserVerification without action
   */
  export type UserVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVerification
     */
    select?: UserVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserVerification
     */
    omit?: UserVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVerificationInclude<ExtArgs> | null
  }


  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    dob: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    aboutMe: string | null
    avatar: string | null
    background: string | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    dob: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    aboutMe: string | null
    avatar: string | null
    background: string | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    email: number
    password: number
    firstName: number
    lastName: number
    dob: number
    createdAt: number
    updatedAt: number
    aboutMe: number
    avatar: number
    background: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    dob?: true
    createdAt?: true
    updatedAt?: true
    aboutMe?: true
    avatar?: true
    background?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    dob?: true
    createdAt?: true
    updatedAt?: true
    aboutMe?: true
    avatar?: true
    background?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    dob?: true
    createdAt?: true
    updatedAt?: true
    aboutMe?: true
    avatar?: true
    background?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date
    createdAt: Date
    updatedAt: Date
    aboutMe: string
    avatar: string
    background: string
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    dob?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aboutMe?: boolean
    avatar?: boolean
    background?: boolean
    ConferenceBlacklists?: boolean | Users$ConferenceBlacklistsArgs<ExtArgs>
    ConferenceCalendars?: boolean | Users$ConferenceCalendarsArgs<ExtArgs>
    ConferenceFeedbacks?: boolean | Users$ConferenceFeedbacksArgs<ExtArgs>
    ConferenceFollows?: boolean | Users$ConferenceFollowsArgs<ExtArgs>
    ConferenceLikes?: boolean | Users$ConferenceLikesArgs<ExtArgs>
    Conferences?: boolean | Users$ConferencesArgs<ExtArgs>
    JournalFollows?: boolean | Users$JournalFollowsArgs<ExtArgs>
    JournalLikes?: boolean | Users$JournalLikesArgs<ExtArgs>
    Journals?: boolean | Users$JournalsArgs<ExtArgs>
    NotificationSettings?: boolean | Users$NotificationSettingsArgs<ExtArgs>
    Notifications?: boolean | Users$NotificationsArgs<ExtArgs>
    TopicUserInteresteds?: boolean | Users$TopicUserInterestedsArgs<ExtArgs>
    UserVerification?: boolean | Users$UserVerificationArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    dob?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aboutMe?: boolean
    avatar?: boolean
    background?: boolean
  }, ExtArgs["result"]["users"]>

  export type UsersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    dob?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aboutMe?: boolean
    avatar?: boolean
    background?: boolean
  }, ExtArgs["result"]["users"]>

  export type UsersSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    dob?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aboutMe?: boolean
    avatar?: boolean
    background?: boolean
  }

  export type UsersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "firstName" | "lastName" | "dob" | "createdAt" | "updatedAt" | "aboutMe" | "avatar" | "background", ExtArgs["result"]["users"]>
  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConferenceBlacklists?: boolean | Users$ConferenceBlacklistsArgs<ExtArgs>
    ConferenceCalendars?: boolean | Users$ConferenceCalendarsArgs<ExtArgs>
    ConferenceFeedbacks?: boolean | Users$ConferenceFeedbacksArgs<ExtArgs>
    ConferenceFollows?: boolean | Users$ConferenceFollowsArgs<ExtArgs>
    ConferenceLikes?: boolean | Users$ConferenceLikesArgs<ExtArgs>
    Conferences?: boolean | Users$ConferencesArgs<ExtArgs>
    JournalFollows?: boolean | Users$JournalFollowsArgs<ExtArgs>
    JournalLikes?: boolean | Users$JournalLikesArgs<ExtArgs>
    Journals?: boolean | Users$JournalsArgs<ExtArgs>
    NotificationSettings?: boolean | Users$NotificationSettingsArgs<ExtArgs>
    Notifications?: boolean | Users$NotificationsArgs<ExtArgs>
    TopicUserInteresteds?: boolean | Users$TopicUserInterestedsArgs<ExtArgs>
    UserVerification?: boolean | Users$UserVerificationArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UsersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      ConferenceBlacklists: Prisma.$ConferenceBlacklistsPayload<ExtArgs>[]
      ConferenceCalendars: Prisma.$ConferenceCalendarsPayload<ExtArgs>[]
      ConferenceFeedbacks: Prisma.$ConferenceFeedbacksPayload<ExtArgs>[]
      ConferenceFollows: Prisma.$ConferenceFollowsPayload<ExtArgs>[]
      ConferenceLikes: Prisma.$ConferenceLikesPayload<ExtArgs>[]
      Conferences: Prisma.$ConferencesPayload<ExtArgs>[]
      JournalFollows: Prisma.$JournalFollowsPayload<ExtArgs>[]
      JournalLikes: Prisma.$JournalLikesPayload<ExtArgs>[]
      Journals: Prisma.$JournalsPayload<ExtArgs>[]
      NotificationSettings: Prisma.$NotificationSettingsPayload<ExtArgs>[]
      Notifications: Prisma.$NotificationsPayload<ExtArgs>[]
      TopicUserInteresteds: Prisma.$TopicUserInterestedsPayload<ExtArgs>[]
      UserVerification: Prisma.$UserVerificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      firstName: string
      lastName: string
      dob: Date
      createdAt: Date
      updatedAt: Date
      aboutMe: string
      avatar: string
      background: string
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersFindUniqueArgs>(args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersFindFirstArgs>(args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersFindManyArgs>(args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends UsersCreateArgs>(args: SelectSubset<T, UsersCreateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersCreateManyArgs>(args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UsersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsersCreateManyAndReturnArgs>(args?: SelectSubset<T, UsersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends UsersDeleteArgs>(args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersUpdateArgs>(args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersDeleteManyArgs>(args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersUpdateManyArgs>(args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UsersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsersUpdateManyAndReturnArgs>(args: SelectSubset<T, UsersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends UsersUpsertArgs>(args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ConferenceBlacklists<T extends Users$ConferenceBlacklistsArgs<ExtArgs> = {}>(args?: Subset<T, Users$ConferenceBlacklistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceBlacklistsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ConferenceCalendars<T extends Users$ConferenceCalendarsArgs<ExtArgs> = {}>(args?: Subset<T, Users$ConferenceCalendarsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ConferenceFeedbacks<T extends Users$ConferenceFeedbacksArgs<ExtArgs> = {}>(args?: Subset<T, Users$ConferenceFeedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ConferenceFollows<T extends Users$ConferenceFollowsArgs<ExtArgs> = {}>(args?: Subset<T, Users$ConferenceFollowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ConferenceLikes<T extends Users$ConferenceLikesArgs<ExtArgs> = {}>(args?: Subset<T, Users$ConferenceLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Conferences<T extends Users$ConferencesArgs<ExtArgs> = {}>(args?: Subset<T, Users$ConferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    JournalFollows<T extends Users$JournalFollowsArgs<ExtArgs> = {}>(args?: Subset<T, Users$JournalFollowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    JournalLikes<T extends Users$JournalLikesArgs<ExtArgs> = {}>(args?: Subset<T, Users$JournalLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Journals<T extends Users$JournalsArgs<ExtArgs> = {}>(args?: Subset<T, Users$JournalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    NotificationSettings<T extends Users$NotificationSettingsArgs<ExtArgs> = {}>(args?: Subset<T, Users$NotificationSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Notifications<T extends Users$NotificationsArgs<ExtArgs> = {}>(args?: Subset<T, Users$NotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TopicUserInteresteds<T extends Users$TopicUserInterestedsArgs<ExtArgs> = {}>(args?: Subset<T, Users$TopicUserInterestedsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicUserInterestedsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UserVerification<T extends Users$UserVerificationArgs<ExtArgs> = {}>(args?: Subset<T, Users$UserVerificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users model
   */ 
  interface UsersFieldRefs {
    readonly id: FieldRef<"Users", 'String'>
    readonly email: FieldRef<"Users", 'String'>
    readonly password: FieldRef<"Users", 'String'>
    readonly firstName: FieldRef<"Users", 'String'>
    readonly lastName: FieldRef<"Users", 'String'>
    readonly dob: FieldRef<"Users", 'DateTime'>
    readonly createdAt: FieldRef<"Users", 'DateTime'>
    readonly updatedAt: FieldRef<"Users", 'DateTime'>
    readonly aboutMe: FieldRef<"Users", 'String'>
    readonly avatar: FieldRef<"Users", 'String'>
    readonly background: FieldRef<"Users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users createManyAndReturn
   */
  export type UsersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users updateManyAndReturn
   */
  export type UsersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * Users.ConferenceBlacklists
   */
  export type Users$ConferenceBlacklistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceBlacklists
     */
    select?: ConferenceBlacklistsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceBlacklists
     */
    omit?: ConferenceBlacklistsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceBlacklistsInclude<ExtArgs> | null
    where?: ConferenceBlacklistsWhereInput
    orderBy?: ConferenceBlacklistsOrderByWithRelationInput | ConferenceBlacklistsOrderByWithRelationInput[]
    cursor?: ConferenceBlacklistsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceBlacklistsScalarFieldEnum | ConferenceBlacklistsScalarFieldEnum[]
  }

  /**
   * Users.ConferenceCalendars
   */
  export type Users$ConferenceCalendarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsInclude<ExtArgs> | null
    where?: ConferenceCalendarsWhereInput
    orderBy?: ConferenceCalendarsOrderByWithRelationInput | ConferenceCalendarsOrderByWithRelationInput[]
    cursor?: ConferenceCalendarsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceCalendarsScalarFieldEnum | ConferenceCalendarsScalarFieldEnum[]
  }

  /**
   * Users.ConferenceFeedbacks
   */
  export type Users$ConferenceFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksInclude<ExtArgs> | null
    where?: ConferenceFeedbacksWhereInput
    orderBy?: ConferenceFeedbacksOrderByWithRelationInput | ConferenceFeedbacksOrderByWithRelationInput[]
    cursor?: ConferenceFeedbacksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceFeedbacksScalarFieldEnum | ConferenceFeedbacksScalarFieldEnum[]
  }

  /**
   * Users.ConferenceFollows
   */
  export type Users$ConferenceFollowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsInclude<ExtArgs> | null
    where?: ConferenceFollowsWhereInput
    orderBy?: ConferenceFollowsOrderByWithRelationInput | ConferenceFollowsOrderByWithRelationInput[]
    cursor?: ConferenceFollowsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceFollowsScalarFieldEnum | ConferenceFollowsScalarFieldEnum[]
  }

  /**
   * Users.ConferenceLikes
   */
  export type Users$ConferenceLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesInclude<ExtArgs> | null
    where?: ConferenceLikesWhereInput
    orderBy?: ConferenceLikesOrderByWithRelationInput | ConferenceLikesOrderByWithRelationInput[]
    cursor?: ConferenceLikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceLikesScalarFieldEnum | ConferenceLikesScalarFieldEnum[]
  }

  /**
   * Users.Conferences
   */
  export type Users$ConferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesInclude<ExtArgs> | null
    where?: ConferencesWhereInput
    orderBy?: ConferencesOrderByWithRelationInput | ConferencesOrderByWithRelationInput[]
    cursor?: ConferencesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferencesScalarFieldEnum | ConferencesScalarFieldEnum[]
  }

  /**
   * Users.JournalFollows
   */
  export type Users$JournalFollowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsInclude<ExtArgs> | null
    where?: JournalFollowsWhereInput
    orderBy?: JournalFollowsOrderByWithRelationInput | JournalFollowsOrderByWithRelationInput[]
    cursor?: JournalFollowsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalFollowsScalarFieldEnum | JournalFollowsScalarFieldEnum[]
  }

  /**
   * Users.JournalLikes
   */
  export type Users$JournalLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesInclude<ExtArgs> | null
    where?: JournalLikesWhereInput
    orderBy?: JournalLikesOrderByWithRelationInput | JournalLikesOrderByWithRelationInput[]
    cursor?: JournalLikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalLikesScalarFieldEnum | JournalLikesScalarFieldEnum[]
  }

  /**
   * Users.Journals
   */
  export type Users$JournalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsInclude<ExtArgs> | null
    where?: JournalsWhereInput
    orderBy?: JournalsOrderByWithRelationInput | JournalsOrderByWithRelationInput[]
    cursor?: JournalsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalsScalarFieldEnum | JournalsScalarFieldEnum[]
  }

  /**
   * Users.NotificationSettings
   */
  export type Users$NotificationSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    where?: NotificationSettingsWhereInput
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    cursor?: NotificationSettingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * Users.Notifications
   */
  export type Users$NotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    where?: NotificationsWhereInput
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    cursor?: NotificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Users.TopicUserInteresteds
   */
  export type Users$TopicUserInterestedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicUserInteresteds
     */
    select?: TopicUserInterestedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicUserInteresteds
     */
    omit?: TopicUserInterestedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicUserInterestedsInclude<ExtArgs> | null
    where?: TopicUserInterestedsWhereInput
    orderBy?: TopicUserInterestedsOrderByWithRelationInput | TopicUserInterestedsOrderByWithRelationInput[]
    cursor?: TopicUserInterestedsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicUserInterestedsScalarFieldEnum | TopicUserInterestedsScalarFieldEnum[]
  }

  /**
   * Users.UserVerification
   */
  export type Users$UserVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserVerification
     */
    select?: UserVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserVerification
     */
    omit?: UserVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserVerificationInclude<ExtArgs> | null
    where?: UserVerificationWhereInput
    orderBy?: UserVerificationOrderByWithRelationInput | UserVerificationOrderByWithRelationInput[]
    cursor?: UserVerificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserVerificationScalarFieldEnum | UserVerificationScalarFieldEnum[]
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdminsScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    fullName: 'fullName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminsScalarFieldEnum = (typeof AdminsScalarFieldEnum)[keyof typeof AdminsScalarFieldEnum]


  export const ConferenceBlacklistsScalarFieldEnum: {
    id: 'id',
    conferenceId: 'conferenceId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConferenceBlacklistsScalarFieldEnum = (typeof ConferenceBlacklistsScalarFieldEnum)[keyof typeof ConferenceBlacklistsScalarFieldEnum]


  export const ConferenceCalendarsScalarFieldEnum: {
    id: 'id',
    conferenceId: 'conferenceId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConferenceCalendarsScalarFieldEnum = (typeof ConferenceCalendarsScalarFieldEnum)[keyof typeof ConferenceCalendarsScalarFieldEnum]


  export const ConferenceCrawlJobsScalarFieldEnum: {
    id: 'id',
    conferenceId: 'conferenceId',
    status: 'status',
    progress: 'progress',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConferenceCrawlJobsScalarFieldEnum = (typeof ConferenceCrawlJobsScalarFieldEnum)[keyof typeof ConferenceCrawlJobsScalarFieldEnum]


  export const ConferenceDatesScalarFieldEnum: {
    id: 'id',
    organizedId: 'organizedId',
    fromDate: 'fromDate',
    toDate: 'toDate',
    type: 'type',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isAvailable: 'isAvailable'
  };

  export type ConferenceDatesScalarFieldEnum = (typeof ConferenceDatesScalarFieldEnum)[keyof typeof ConferenceDatesScalarFieldEnum]


  export const ConferenceFeedbacksScalarFieldEnum: {
    id: 'id',
    conferenceId: 'conferenceId',
    creatorId: 'creatorId',
    description: 'description',
    star: 'star',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConferenceFeedbacksScalarFieldEnum = (typeof ConferenceFeedbacksScalarFieldEnum)[keyof typeof ConferenceFeedbacksScalarFieldEnum]


  export const ConferenceFollowsScalarFieldEnum: {
    id: 'id',
    conferenceId: 'conferenceId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConferenceFollowsScalarFieldEnum = (typeof ConferenceFollowsScalarFieldEnum)[keyof typeof ConferenceFollowsScalarFieldEnum]


  export const ConferenceLikesScalarFieldEnum: {
    id: 'id',
    conferenceId: 'conferenceId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConferenceLikesScalarFieldEnum = (typeof ConferenceLikesScalarFieldEnum)[keyof typeof ConferenceLikesScalarFieldEnum]


  export const ConferenceOrganizationsScalarFieldEnum: {
    id: 'id',
    year: 'year',
    accessType: 'accessType',
    isAvailable: 'isAvailable',
    conferenceId: 'conferenceId',
    publisher: 'publisher',
    summerize: 'summerize',
    callForPaper: 'callForPaper',
    link: 'link',
    cfpLink: 'cfpLink',
    impLink: 'impLink',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConferenceOrganizationsScalarFieldEnum = (typeof ConferenceOrganizationsScalarFieldEnum)[keyof typeof ConferenceOrganizationsScalarFieldEnum]


  export const ConferenceRanksScalarFieldEnum: {
    id: 'id',
    year: 'year',
    conferenceId: 'conferenceId',
    fieldOfResearchId: 'fieldOfResearchId',
    rankId: 'rankId'
  };

  export type ConferenceRanksScalarFieldEnum = (typeof ConferenceRanksScalarFieldEnum)[keyof typeof ConferenceRanksScalarFieldEnum]


  export const ConferenceTopicsScalarFieldEnum: {
    id: 'id',
    organizeId: 'organizeId',
    topicId: 'topicId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConferenceTopicsScalarFieldEnum = (typeof ConferenceTopicsScalarFieldEnum)[keyof typeof ConferenceTopicsScalarFieldEnum]


  export const ConferencesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    acronym: 'acronym',
    creatorId: 'creatorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status',
    adminId: 'adminId'
  };

  export type ConferencesScalarFieldEnum = (typeof ConferencesScalarFieldEnum)[keyof typeof ConferencesScalarFieldEnum]


  export const FieldOfResearchsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code'
  };

  export type FieldOfResearchsScalarFieldEnum = (typeof FieldOfResearchsScalarFieldEnum)[keyof typeof FieldOfResearchsScalarFieldEnum]


  export const JournalCrawlJobsScalarFieldEnum: {
    id: 'id',
    journalId: 'journalId',
    status: 'status',
    progress: 'progress',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JournalCrawlJobsScalarFieldEnum = (typeof JournalCrawlJobsScalarFieldEnum)[keyof typeof JournalCrawlJobsScalarFieldEnum]


  export const JournalFollowsScalarFieldEnum: {
    id: 'id',
    journalId: 'journalId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JournalFollowsScalarFieldEnum = (typeof JournalFollowsScalarFieldEnum)[keyof typeof JournalFollowsScalarFieldEnum]


  export const JournalLikesScalarFieldEnum: {
    id: 'id',
    journalId: 'journalId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JournalLikesScalarFieldEnum = (typeof JournalLikesScalarFieldEnum)[keyof typeof JournalLikesScalarFieldEnum]


  export const JournalRanksScalarFieldEnum: {
    id: 'id',
    year: 'year',
    journalId: 'journalId',
    fieldOfResearchId: 'fieldOfResearchId',
    rankId: 'rankId'
  };

  export type JournalRanksScalarFieldEnum = (typeof JournalRanksScalarFieldEnum)[keyof typeof JournalRanksScalarFieldEnum]


  export const JournalTopicsScalarFieldEnum: {
    id: 'id',
    journalId: 'journalId',
    topicId: 'topicId'
  };

  export type JournalTopicsScalarFieldEnum = (typeof JournalTopicsScalarFieldEnum)[keyof typeof JournalTopicsScalarFieldEnum]


  export const JournalsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    issn: 'issn',
    hIndex: 'hIndex',
    publisher: 'publisher',
    nation: 'nation',
    scope: 'scope',
    emailSubmission: 'emailSubmission',
    creator: 'creator'
  };

  export type JournalsScalarFieldEnum = (typeof JournalsScalarFieldEnum)[keyof typeof JournalsScalarFieldEnum]


  export const LocationsScalarFieldEnum: {
    id: 'id',
    address: 'address',
    cityStateProvince: 'cityStateProvince',
    country: 'country',
    continent: 'continent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isAvailable: 'isAvailable',
    organizeId: 'organizeId'
  };

  export type LocationsScalarFieldEnum = (typeof LocationsScalarFieldEnum)[keyof typeof LocationsScalarFieldEnum]


  export const NotificationSettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    notificationId: 'notificationId',
    isEnabled: 'isEnabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationSettingsScalarFieldEnum = (typeof NotificationSettingsScalarFieldEnum)[keyof typeof NotificationSettingsScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    notificationId: 'notificationId',
    userId: 'userId',
    message: 'message',
    isRead: 'isRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const NotificationsTypesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationsTypesScalarFieldEnum = (typeof NotificationsTypesScalarFieldEnum)[keyof typeof NotificationsTypesScalarFieldEnum]


  export const PassengerScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName'
  };

  export type PassengerScalarFieldEnum = (typeof PassengerScalarFieldEnum)[keyof typeof PassengerScalarFieldEnum]


  export const RanksScalarFieldEnum: {
    id: 'id',
    name: 'name',
    value: 'value',
    sourceId: 'sourceId'
  };

  export type RanksScalarFieldEnum = (typeof RanksScalarFieldEnum)[keyof typeof RanksScalarFieldEnum]


  export const SourcesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    link: 'link'
  };

  export type SourcesScalarFieldEnum = (typeof SourcesScalarFieldEnum)[keyof typeof SourcesScalarFieldEnum]


  export const TopicUserInterestedsScalarFieldEnum: {
    userId: 'userId',
    topicId: 'topicId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TopicUserInterestedsScalarFieldEnum = (typeof TopicUserInterestedsScalarFieldEnum)[keyof typeof TopicUserInterestedsScalarFieldEnum]


  export const TopicsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TopicsScalarFieldEnum = (typeof TopicsScalarFieldEnum)[keyof typeof TopicsScalarFieldEnum]


  export const UserVerificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    verificationCode: 'verificationCode',
    verificationCodeExpires: 'verificationCodeExpires',
    isVerified: 'isVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserVerificationScalarFieldEnum = (typeof UserVerificationScalarFieldEnum)[keyof typeof UserVerificationScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    dob: 'dob',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    aboutMe: 'aboutMe',
    avatar: 'avatar',
    background: 'background'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type AdminsWhereInput = {
    AND?: AdminsWhereInput | AdminsWhereInput[]
    OR?: AdminsWhereInput[]
    NOT?: AdminsWhereInput | AdminsWhereInput[]
    id?: StringFilter<"Admins"> | string
    email?: StringFilter<"Admins"> | string
    password?: StringFilter<"Admins"> | string
    fullName?: StringFilter<"Admins"> | string
    createdAt?: DateTimeFilter<"Admins"> | Date | string
    updatedAt?: DateTimeFilter<"Admins"> | Date | string
    Conferences?: ConferencesListRelationFilter
  }

  export type AdminsOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Conferences?: ConferencesOrderByRelationAggregateInput
  }

  export type AdminsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: AdminsWhereInput | AdminsWhereInput[]
    OR?: AdminsWhereInput[]
    NOT?: AdminsWhereInput | AdminsWhereInput[]
    password?: StringFilter<"Admins"> | string
    fullName?: StringFilter<"Admins"> | string
    createdAt?: DateTimeFilter<"Admins"> | Date | string
    updatedAt?: DateTimeFilter<"Admins"> | Date | string
    Conferences?: ConferencesListRelationFilter
  }, "id" | "email">

  export type AdminsOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminsCountOrderByAggregateInput
    _max?: AdminsMaxOrderByAggregateInput
    _min?: AdminsMinOrderByAggregateInput
  }

  export type AdminsScalarWhereWithAggregatesInput = {
    AND?: AdminsScalarWhereWithAggregatesInput | AdminsScalarWhereWithAggregatesInput[]
    OR?: AdminsScalarWhereWithAggregatesInput[]
    NOT?: AdminsScalarWhereWithAggregatesInput | AdminsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admins"> | string
    email?: StringWithAggregatesFilter<"Admins"> | string
    password?: StringWithAggregatesFilter<"Admins"> | string
    fullName?: StringWithAggregatesFilter<"Admins"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Admins"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admins"> | Date | string
  }

  export type ConferenceBlacklistsWhereInput = {
    AND?: ConferenceBlacklistsWhereInput | ConferenceBlacklistsWhereInput[]
    OR?: ConferenceBlacklistsWhereInput[]
    NOT?: ConferenceBlacklistsWhereInput | ConferenceBlacklistsWhereInput[]
    id?: StringFilter<"ConferenceBlacklists"> | string
    conferenceId?: StringFilter<"ConferenceBlacklists"> | string
    userId?: StringFilter<"ConferenceBlacklists"> | string
    createdAt?: DateTimeFilter<"ConferenceBlacklists"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceBlacklists"> | Date | string
    Conferences?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type ConferenceBlacklistsOrderByWithRelationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Conferences?: ConferencesOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type ConferenceBlacklistsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConferenceBlacklistsWhereInput | ConferenceBlacklistsWhereInput[]
    OR?: ConferenceBlacklistsWhereInput[]
    NOT?: ConferenceBlacklistsWhereInput | ConferenceBlacklistsWhereInput[]
    conferenceId?: StringFilter<"ConferenceBlacklists"> | string
    userId?: StringFilter<"ConferenceBlacklists"> | string
    createdAt?: DateTimeFilter<"ConferenceBlacklists"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceBlacklists"> | Date | string
    Conferences?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id">

  export type ConferenceBlacklistsOrderByWithAggregationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConferenceBlacklistsCountOrderByAggregateInput
    _max?: ConferenceBlacklistsMaxOrderByAggregateInput
    _min?: ConferenceBlacklistsMinOrderByAggregateInput
  }

  export type ConferenceBlacklistsScalarWhereWithAggregatesInput = {
    AND?: ConferenceBlacklistsScalarWhereWithAggregatesInput | ConferenceBlacklistsScalarWhereWithAggregatesInput[]
    OR?: ConferenceBlacklistsScalarWhereWithAggregatesInput[]
    NOT?: ConferenceBlacklistsScalarWhereWithAggregatesInput | ConferenceBlacklistsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConferenceBlacklists"> | string
    conferenceId?: StringWithAggregatesFilter<"ConferenceBlacklists"> | string
    userId?: StringWithAggregatesFilter<"ConferenceBlacklists"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConferenceBlacklists"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConferenceBlacklists"> | Date | string
  }

  export type ConferenceCalendarsWhereInput = {
    AND?: ConferenceCalendarsWhereInput | ConferenceCalendarsWhereInput[]
    OR?: ConferenceCalendarsWhereInput[]
    NOT?: ConferenceCalendarsWhereInput | ConferenceCalendarsWhereInput[]
    id?: StringFilter<"ConferenceCalendars"> | string
    conferenceId?: StringFilter<"ConferenceCalendars"> | string
    userId?: StringFilter<"ConferenceCalendars"> | string
    createdAt?: DateTimeFilter<"ConferenceCalendars"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceCalendars"> | Date | string
    Conferences?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type ConferenceCalendarsOrderByWithRelationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Conferences?: ConferencesOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type ConferenceCalendarsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conferenceId_userId?: ConferenceCalendarsConferenceIdUserIdCompoundUniqueInput
    AND?: ConferenceCalendarsWhereInput | ConferenceCalendarsWhereInput[]
    OR?: ConferenceCalendarsWhereInput[]
    NOT?: ConferenceCalendarsWhereInput | ConferenceCalendarsWhereInput[]
    conferenceId?: StringFilter<"ConferenceCalendars"> | string
    userId?: StringFilter<"ConferenceCalendars"> | string
    createdAt?: DateTimeFilter<"ConferenceCalendars"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceCalendars"> | Date | string
    Conferences?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id" | "conferenceId_userId">

  export type ConferenceCalendarsOrderByWithAggregationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConferenceCalendarsCountOrderByAggregateInput
    _max?: ConferenceCalendarsMaxOrderByAggregateInput
    _min?: ConferenceCalendarsMinOrderByAggregateInput
  }

  export type ConferenceCalendarsScalarWhereWithAggregatesInput = {
    AND?: ConferenceCalendarsScalarWhereWithAggregatesInput | ConferenceCalendarsScalarWhereWithAggregatesInput[]
    OR?: ConferenceCalendarsScalarWhereWithAggregatesInput[]
    NOT?: ConferenceCalendarsScalarWhereWithAggregatesInput | ConferenceCalendarsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConferenceCalendars"> | string
    conferenceId?: StringWithAggregatesFilter<"ConferenceCalendars"> | string
    userId?: StringWithAggregatesFilter<"ConferenceCalendars"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConferenceCalendars"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConferenceCalendars"> | Date | string
  }

  export type ConferenceCrawlJobsWhereInput = {
    AND?: ConferenceCrawlJobsWhereInput | ConferenceCrawlJobsWhereInput[]
    OR?: ConferenceCrawlJobsWhereInput[]
    NOT?: ConferenceCrawlJobsWhereInput | ConferenceCrawlJobsWhereInput[]
    id?: StringFilter<"ConferenceCrawlJobs"> | string
    conferenceId?: StringFilter<"ConferenceCrawlJobs"> | string
    status?: StringFilter<"ConferenceCrawlJobs"> | string
    progress?: IntFilter<"ConferenceCrawlJobs"> | number
    message?: StringFilter<"ConferenceCrawlJobs"> | string
    createdAt?: DateTimeFilter<"ConferenceCrawlJobs"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceCrawlJobs"> | Date | string
    Conferences?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
  }

  export type ConferenceCrawlJobsOrderByWithRelationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Conferences?: ConferencesOrderByWithRelationInput
  }

  export type ConferenceCrawlJobsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConferenceCrawlJobsWhereInput | ConferenceCrawlJobsWhereInput[]
    OR?: ConferenceCrawlJobsWhereInput[]
    NOT?: ConferenceCrawlJobsWhereInput | ConferenceCrawlJobsWhereInput[]
    conferenceId?: StringFilter<"ConferenceCrawlJobs"> | string
    status?: StringFilter<"ConferenceCrawlJobs"> | string
    progress?: IntFilter<"ConferenceCrawlJobs"> | number
    message?: StringFilter<"ConferenceCrawlJobs"> | string
    createdAt?: DateTimeFilter<"ConferenceCrawlJobs"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceCrawlJobs"> | Date | string
    Conferences?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
  }, "id">

  export type ConferenceCrawlJobsOrderByWithAggregationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConferenceCrawlJobsCountOrderByAggregateInput
    _avg?: ConferenceCrawlJobsAvgOrderByAggregateInput
    _max?: ConferenceCrawlJobsMaxOrderByAggregateInput
    _min?: ConferenceCrawlJobsMinOrderByAggregateInput
    _sum?: ConferenceCrawlJobsSumOrderByAggregateInput
  }

  export type ConferenceCrawlJobsScalarWhereWithAggregatesInput = {
    AND?: ConferenceCrawlJobsScalarWhereWithAggregatesInput | ConferenceCrawlJobsScalarWhereWithAggregatesInput[]
    OR?: ConferenceCrawlJobsScalarWhereWithAggregatesInput[]
    NOT?: ConferenceCrawlJobsScalarWhereWithAggregatesInput | ConferenceCrawlJobsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConferenceCrawlJobs"> | string
    conferenceId?: StringWithAggregatesFilter<"ConferenceCrawlJobs"> | string
    status?: StringWithAggregatesFilter<"ConferenceCrawlJobs"> | string
    progress?: IntWithAggregatesFilter<"ConferenceCrawlJobs"> | number
    message?: StringWithAggregatesFilter<"ConferenceCrawlJobs"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConferenceCrawlJobs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConferenceCrawlJobs"> | Date | string
  }

  export type ConferenceDatesWhereInput = {
    AND?: ConferenceDatesWhereInput | ConferenceDatesWhereInput[]
    OR?: ConferenceDatesWhereInput[]
    NOT?: ConferenceDatesWhereInput | ConferenceDatesWhereInput[]
    id?: StringFilter<"ConferenceDates"> | string
    organizedId?: StringFilter<"ConferenceDates"> | string
    fromDate?: DateTimeFilter<"ConferenceDates"> | Date | string
    toDate?: DateTimeFilter<"ConferenceDates"> | Date | string
    type?: StringFilter<"ConferenceDates"> | string
    name?: StringFilter<"ConferenceDates"> | string
    createdAt?: DateTimeFilter<"ConferenceDates"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceDates"> | Date | string
    isAvailable?: BoolFilter<"ConferenceDates"> | boolean
    ConferenceOrganizations?: XOR<ConferenceOrganizationsScalarRelationFilter, ConferenceOrganizationsWhereInput>
  }

  export type ConferenceDatesOrderByWithRelationInput = {
    id?: SortOrder
    organizedId?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    type?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAvailable?: SortOrder
    ConferenceOrganizations?: ConferenceOrganizationsOrderByWithRelationInput
  }

  export type ConferenceDatesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConferenceDatesWhereInput | ConferenceDatesWhereInput[]
    OR?: ConferenceDatesWhereInput[]
    NOT?: ConferenceDatesWhereInput | ConferenceDatesWhereInput[]
    organizedId?: StringFilter<"ConferenceDates"> | string
    fromDate?: DateTimeFilter<"ConferenceDates"> | Date | string
    toDate?: DateTimeFilter<"ConferenceDates"> | Date | string
    type?: StringFilter<"ConferenceDates"> | string
    name?: StringFilter<"ConferenceDates"> | string
    createdAt?: DateTimeFilter<"ConferenceDates"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceDates"> | Date | string
    isAvailable?: BoolFilter<"ConferenceDates"> | boolean
    ConferenceOrganizations?: XOR<ConferenceOrganizationsScalarRelationFilter, ConferenceOrganizationsWhereInput>
  }, "id">

  export type ConferenceDatesOrderByWithAggregationInput = {
    id?: SortOrder
    organizedId?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    type?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAvailable?: SortOrder
    _count?: ConferenceDatesCountOrderByAggregateInput
    _max?: ConferenceDatesMaxOrderByAggregateInput
    _min?: ConferenceDatesMinOrderByAggregateInput
  }

  export type ConferenceDatesScalarWhereWithAggregatesInput = {
    AND?: ConferenceDatesScalarWhereWithAggregatesInput | ConferenceDatesScalarWhereWithAggregatesInput[]
    OR?: ConferenceDatesScalarWhereWithAggregatesInput[]
    NOT?: ConferenceDatesScalarWhereWithAggregatesInput | ConferenceDatesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConferenceDates"> | string
    organizedId?: StringWithAggregatesFilter<"ConferenceDates"> | string
    fromDate?: DateTimeWithAggregatesFilter<"ConferenceDates"> | Date | string
    toDate?: DateTimeWithAggregatesFilter<"ConferenceDates"> | Date | string
    type?: StringWithAggregatesFilter<"ConferenceDates"> | string
    name?: StringWithAggregatesFilter<"ConferenceDates"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConferenceDates"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConferenceDates"> | Date | string
    isAvailable?: BoolWithAggregatesFilter<"ConferenceDates"> | boolean
  }

  export type ConferenceFeedbacksWhereInput = {
    AND?: ConferenceFeedbacksWhereInput | ConferenceFeedbacksWhereInput[]
    OR?: ConferenceFeedbacksWhereInput[]
    NOT?: ConferenceFeedbacksWhereInput | ConferenceFeedbacksWhereInput[]
    id?: StringFilter<"ConferenceFeedbacks"> | string
    conferenceId?: StringFilter<"ConferenceFeedbacks"> | string
    creatorId?: StringFilter<"ConferenceFeedbacks"> | string
    description?: StringFilter<"ConferenceFeedbacks"> | string
    star?: IntFilter<"ConferenceFeedbacks"> | number
    createdAt?: DateTimeFilter<"ConferenceFeedbacks"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceFeedbacks"> | Date | string
    Conferences?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type ConferenceFeedbacksOrderByWithRelationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    creatorId?: SortOrder
    description?: SortOrder
    star?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Conferences?: ConferencesOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type ConferenceFeedbacksWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConferenceFeedbacksWhereInput | ConferenceFeedbacksWhereInput[]
    OR?: ConferenceFeedbacksWhereInput[]
    NOT?: ConferenceFeedbacksWhereInput | ConferenceFeedbacksWhereInput[]
    conferenceId?: StringFilter<"ConferenceFeedbacks"> | string
    creatorId?: StringFilter<"ConferenceFeedbacks"> | string
    description?: StringFilter<"ConferenceFeedbacks"> | string
    star?: IntFilter<"ConferenceFeedbacks"> | number
    createdAt?: DateTimeFilter<"ConferenceFeedbacks"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceFeedbacks"> | Date | string
    Conferences?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id">

  export type ConferenceFeedbacksOrderByWithAggregationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    creatorId?: SortOrder
    description?: SortOrder
    star?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConferenceFeedbacksCountOrderByAggregateInput
    _avg?: ConferenceFeedbacksAvgOrderByAggregateInput
    _max?: ConferenceFeedbacksMaxOrderByAggregateInput
    _min?: ConferenceFeedbacksMinOrderByAggregateInput
    _sum?: ConferenceFeedbacksSumOrderByAggregateInput
  }

  export type ConferenceFeedbacksScalarWhereWithAggregatesInput = {
    AND?: ConferenceFeedbacksScalarWhereWithAggregatesInput | ConferenceFeedbacksScalarWhereWithAggregatesInput[]
    OR?: ConferenceFeedbacksScalarWhereWithAggregatesInput[]
    NOT?: ConferenceFeedbacksScalarWhereWithAggregatesInput | ConferenceFeedbacksScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConferenceFeedbacks"> | string
    conferenceId?: StringWithAggregatesFilter<"ConferenceFeedbacks"> | string
    creatorId?: StringWithAggregatesFilter<"ConferenceFeedbacks"> | string
    description?: StringWithAggregatesFilter<"ConferenceFeedbacks"> | string
    star?: IntWithAggregatesFilter<"ConferenceFeedbacks"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ConferenceFeedbacks"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConferenceFeedbacks"> | Date | string
  }

  export type ConferenceFollowsWhereInput = {
    AND?: ConferenceFollowsWhereInput | ConferenceFollowsWhereInput[]
    OR?: ConferenceFollowsWhereInput[]
    NOT?: ConferenceFollowsWhereInput | ConferenceFollowsWhereInput[]
    id?: StringFilter<"ConferenceFollows"> | string
    conferenceId?: StringFilter<"ConferenceFollows"> | string
    userId?: StringFilter<"ConferenceFollows"> | string
    createdAt?: DateTimeFilter<"ConferenceFollows"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceFollows"> | Date | string
    Conferences?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type ConferenceFollowsOrderByWithRelationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Conferences?: ConferencesOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type ConferenceFollowsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conferenceId_userId?: ConferenceFollowsConferenceIdUserIdCompoundUniqueInput
    AND?: ConferenceFollowsWhereInput | ConferenceFollowsWhereInput[]
    OR?: ConferenceFollowsWhereInput[]
    NOT?: ConferenceFollowsWhereInput | ConferenceFollowsWhereInput[]
    conferenceId?: StringFilter<"ConferenceFollows"> | string
    userId?: StringFilter<"ConferenceFollows"> | string
    createdAt?: DateTimeFilter<"ConferenceFollows"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceFollows"> | Date | string
    Conferences?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id" | "conferenceId_userId">

  export type ConferenceFollowsOrderByWithAggregationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConferenceFollowsCountOrderByAggregateInput
    _max?: ConferenceFollowsMaxOrderByAggregateInput
    _min?: ConferenceFollowsMinOrderByAggregateInput
  }

  export type ConferenceFollowsScalarWhereWithAggregatesInput = {
    AND?: ConferenceFollowsScalarWhereWithAggregatesInput | ConferenceFollowsScalarWhereWithAggregatesInput[]
    OR?: ConferenceFollowsScalarWhereWithAggregatesInput[]
    NOT?: ConferenceFollowsScalarWhereWithAggregatesInput | ConferenceFollowsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConferenceFollows"> | string
    conferenceId?: StringWithAggregatesFilter<"ConferenceFollows"> | string
    userId?: StringWithAggregatesFilter<"ConferenceFollows"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConferenceFollows"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConferenceFollows"> | Date | string
  }

  export type ConferenceLikesWhereInput = {
    AND?: ConferenceLikesWhereInput | ConferenceLikesWhereInput[]
    OR?: ConferenceLikesWhereInput[]
    NOT?: ConferenceLikesWhereInput | ConferenceLikesWhereInput[]
    id?: StringFilter<"ConferenceLikes"> | string
    conferenceId?: StringFilter<"ConferenceLikes"> | string
    userId?: StringFilter<"ConferenceLikes"> | string
    createdAt?: DateTimeFilter<"ConferenceLikes"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceLikes"> | Date | string
    Conferences?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type ConferenceLikesOrderByWithRelationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Conferences?: ConferencesOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type ConferenceLikesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conferenceId_userId?: ConferenceLikesConferenceIdUserIdCompoundUniqueInput
    AND?: ConferenceLikesWhereInput | ConferenceLikesWhereInput[]
    OR?: ConferenceLikesWhereInput[]
    NOT?: ConferenceLikesWhereInput | ConferenceLikesWhereInput[]
    conferenceId?: StringFilter<"ConferenceLikes"> | string
    userId?: StringFilter<"ConferenceLikes"> | string
    createdAt?: DateTimeFilter<"ConferenceLikes"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceLikes"> | Date | string
    Conferences?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id" | "conferenceId_userId">

  export type ConferenceLikesOrderByWithAggregationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConferenceLikesCountOrderByAggregateInput
    _max?: ConferenceLikesMaxOrderByAggregateInput
    _min?: ConferenceLikesMinOrderByAggregateInput
  }

  export type ConferenceLikesScalarWhereWithAggregatesInput = {
    AND?: ConferenceLikesScalarWhereWithAggregatesInput | ConferenceLikesScalarWhereWithAggregatesInput[]
    OR?: ConferenceLikesScalarWhereWithAggregatesInput[]
    NOT?: ConferenceLikesScalarWhereWithAggregatesInput | ConferenceLikesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConferenceLikes"> | string
    conferenceId?: StringWithAggregatesFilter<"ConferenceLikes"> | string
    userId?: StringWithAggregatesFilter<"ConferenceLikes"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConferenceLikes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConferenceLikes"> | Date | string
  }

  export type ConferenceOrganizationsWhereInput = {
    AND?: ConferenceOrganizationsWhereInput | ConferenceOrganizationsWhereInput[]
    OR?: ConferenceOrganizationsWhereInput[]
    NOT?: ConferenceOrganizationsWhereInput | ConferenceOrganizationsWhereInput[]
    id?: StringFilter<"ConferenceOrganizations"> | string
    year?: IntNullableFilter<"ConferenceOrganizations"> | number | null
    accessType?: StringFilter<"ConferenceOrganizations"> | string
    isAvailable?: BoolFilter<"ConferenceOrganizations"> | boolean
    conferenceId?: StringFilter<"ConferenceOrganizations"> | string
    publisher?: StringFilter<"ConferenceOrganizations"> | string
    summerize?: StringFilter<"ConferenceOrganizations"> | string
    callForPaper?: StringFilter<"ConferenceOrganizations"> | string
    link?: StringFilter<"ConferenceOrganizations"> | string
    cfpLink?: StringFilter<"ConferenceOrganizations"> | string
    impLink?: StringFilter<"ConferenceOrganizations"> | string
    createdAt?: DateTimeFilter<"ConferenceOrganizations"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceOrganizations"> | Date | string
    ConferenceDates?: ConferenceDatesListRelationFilter
    Conferences?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
    ConferenceTopics?: ConferenceTopicsListRelationFilter
    Locations?: LocationsListRelationFilter
  }

  export type ConferenceOrganizationsOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrderInput | SortOrder
    accessType?: SortOrder
    isAvailable?: SortOrder
    conferenceId?: SortOrder
    publisher?: SortOrder
    summerize?: SortOrder
    callForPaper?: SortOrder
    link?: SortOrder
    cfpLink?: SortOrder
    impLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ConferenceDates?: ConferenceDatesOrderByRelationAggregateInput
    Conferences?: ConferencesOrderByWithRelationInput
    ConferenceTopics?: ConferenceTopicsOrderByRelationAggregateInput
    Locations?: LocationsOrderByRelationAggregateInput
  }

  export type ConferenceOrganizationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConferenceOrganizationsWhereInput | ConferenceOrganizationsWhereInput[]
    OR?: ConferenceOrganizationsWhereInput[]
    NOT?: ConferenceOrganizationsWhereInput | ConferenceOrganizationsWhereInput[]
    year?: IntNullableFilter<"ConferenceOrganizations"> | number | null
    accessType?: StringFilter<"ConferenceOrganizations"> | string
    isAvailable?: BoolFilter<"ConferenceOrganizations"> | boolean
    conferenceId?: StringFilter<"ConferenceOrganizations"> | string
    publisher?: StringFilter<"ConferenceOrganizations"> | string
    summerize?: StringFilter<"ConferenceOrganizations"> | string
    callForPaper?: StringFilter<"ConferenceOrganizations"> | string
    link?: StringFilter<"ConferenceOrganizations"> | string
    cfpLink?: StringFilter<"ConferenceOrganizations"> | string
    impLink?: StringFilter<"ConferenceOrganizations"> | string
    createdAt?: DateTimeFilter<"ConferenceOrganizations"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceOrganizations"> | Date | string
    ConferenceDates?: ConferenceDatesListRelationFilter
    Conferences?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
    ConferenceTopics?: ConferenceTopicsListRelationFilter
    Locations?: LocationsListRelationFilter
  }, "id">

  export type ConferenceOrganizationsOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrderInput | SortOrder
    accessType?: SortOrder
    isAvailable?: SortOrder
    conferenceId?: SortOrder
    publisher?: SortOrder
    summerize?: SortOrder
    callForPaper?: SortOrder
    link?: SortOrder
    cfpLink?: SortOrder
    impLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConferenceOrganizationsCountOrderByAggregateInput
    _avg?: ConferenceOrganizationsAvgOrderByAggregateInput
    _max?: ConferenceOrganizationsMaxOrderByAggregateInput
    _min?: ConferenceOrganizationsMinOrderByAggregateInput
    _sum?: ConferenceOrganizationsSumOrderByAggregateInput
  }

  export type ConferenceOrganizationsScalarWhereWithAggregatesInput = {
    AND?: ConferenceOrganizationsScalarWhereWithAggregatesInput | ConferenceOrganizationsScalarWhereWithAggregatesInput[]
    OR?: ConferenceOrganizationsScalarWhereWithAggregatesInput[]
    NOT?: ConferenceOrganizationsScalarWhereWithAggregatesInput | ConferenceOrganizationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConferenceOrganizations"> | string
    year?: IntNullableWithAggregatesFilter<"ConferenceOrganizations"> | number | null
    accessType?: StringWithAggregatesFilter<"ConferenceOrganizations"> | string
    isAvailable?: BoolWithAggregatesFilter<"ConferenceOrganizations"> | boolean
    conferenceId?: StringWithAggregatesFilter<"ConferenceOrganizations"> | string
    publisher?: StringWithAggregatesFilter<"ConferenceOrganizations"> | string
    summerize?: StringWithAggregatesFilter<"ConferenceOrganizations"> | string
    callForPaper?: StringWithAggregatesFilter<"ConferenceOrganizations"> | string
    link?: StringWithAggregatesFilter<"ConferenceOrganizations"> | string
    cfpLink?: StringWithAggregatesFilter<"ConferenceOrganizations"> | string
    impLink?: StringWithAggregatesFilter<"ConferenceOrganizations"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConferenceOrganizations"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConferenceOrganizations"> | Date | string
  }

  export type ConferenceRanksWhereInput = {
    AND?: ConferenceRanksWhereInput | ConferenceRanksWhereInput[]
    OR?: ConferenceRanksWhereInput[]
    NOT?: ConferenceRanksWhereInput | ConferenceRanksWhereInput[]
    id?: StringFilter<"ConferenceRanks"> | string
    year?: IntFilter<"ConferenceRanks"> | number
    conferenceId?: StringFilter<"ConferenceRanks"> | string
    fieldOfResearchId?: StringFilter<"ConferenceRanks"> | string
    rankId?: StringFilter<"ConferenceRanks"> | string
    Conferences?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
    FieldOfResearchs?: XOR<FieldOfResearchsScalarRelationFilter, FieldOfResearchsWhereInput>
    Ranks?: XOR<RanksScalarRelationFilter, RanksWhereInput>
  }

  export type ConferenceRanksOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrder
    conferenceId?: SortOrder
    fieldOfResearchId?: SortOrder
    rankId?: SortOrder
    Conferences?: ConferencesOrderByWithRelationInput
    FieldOfResearchs?: FieldOfResearchsOrderByWithRelationInput
    Ranks?: RanksOrderByWithRelationInput
  }

  export type ConferenceRanksWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConferenceRanksWhereInput | ConferenceRanksWhereInput[]
    OR?: ConferenceRanksWhereInput[]
    NOT?: ConferenceRanksWhereInput | ConferenceRanksWhereInput[]
    year?: IntFilter<"ConferenceRanks"> | number
    conferenceId?: StringFilter<"ConferenceRanks"> | string
    fieldOfResearchId?: StringFilter<"ConferenceRanks"> | string
    rankId?: StringFilter<"ConferenceRanks"> | string
    Conferences?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
    FieldOfResearchs?: XOR<FieldOfResearchsScalarRelationFilter, FieldOfResearchsWhereInput>
    Ranks?: XOR<RanksScalarRelationFilter, RanksWhereInput>
  }, "id">

  export type ConferenceRanksOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrder
    conferenceId?: SortOrder
    fieldOfResearchId?: SortOrder
    rankId?: SortOrder
    _count?: ConferenceRanksCountOrderByAggregateInput
    _avg?: ConferenceRanksAvgOrderByAggregateInput
    _max?: ConferenceRanksMaxOrderByAggregateInput
    _min?: ConferenceRanksMinOrderByAggregateInput
    _sum?: ConferenceRanksSumOrderByAggregateInput
  }

  export type ConferenceRanksScalarWhereWithAggregatesInput = {
    AND?: ConferenceRanksScalarWhereWithAggregatesInput | ConferenceRanksScalarWhereWithAggregatesInput[]
    OR?: ConferenceRanksScalarWhereWithAggregatesInput[]
    NOT?: ConferenceRanksScalarWhereWithAggregatesInput | ConferenceRanksScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConferenceRanks"> | string
    year?: IntWithAggregatesFilter<"ConferenceRanks"> | number
    conferenceId?: StringWithAggregatesFilter<"ConferenceRanks"> | string
    fieldOfResearchId?: StringWithAggregatesFilter<"ConferenceRanks"> | string
    rankId?: StringWithAggregatesFilter<"ConferenceRanks"> | string
  }

  export type ConferenceTopicsWhereInput = {
    AND?: ConferenceTopicsWhereInput | ConferenceTopicsWhereInput[]
    OR?: ConferenceTopicsWhereInput[]
    NOT?: ConferenceTopicsWhereInput | ConferenceTopicsWhereInput[]
    id?: StringFilter<"ConferenceTopics"> | string
    organizeId?: StringFilter<"ConferenceTopics"> | string
    topicId?: StringFilter<"ConferenceTopics"> | string
    createdAt?: DateTimeFilter<"ConferenceTopics"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceTopics"> | Date | string
    ConferenceOrganizations?: XOR<ConferenceOrganizationsScalarRelationFilter, ConferenceOrganizationsWhereInput>
    Topics?: XOR<TopicsScalarRelationFilter, TopicsWhereInput>
  }

  export type ConferenceTopicsOrderByWithRelationInput = {
    id?: SortOrder
    organizeId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ConferenceOrganizations?: ConferenceOrganizationsOrderByWithRelationInput
    Topics?: TopicsOrderByWithRelationInput
  }

  export type ConferenceTopicsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConferenceTopicsWhereInput | ConferenceTopicsWhereInput[]
    OR?: ConferenceTopicsWhereInput[]
    NOT?: ConferenceTopicsWhereInput | ConferenceTopicsWhereInput[]
    organizeId?: StringFilter<"ConferenceTopics"> | string
    topicId?: StringFilter<"ConferenceTopics"> | string
    createdAt?: DateTimeFilter<"ConferenceTopics"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceTopics"> | Date | string
    ConferenceOrganizations?: XOR<ConferenceOrganizationsScalarRelationFilter, ConferenceOrganizationsWhereInput>
    Topics?: XOR<TopicsScalarRelationFilter, TopicsWhereInput>
  }, "id">

  export type ConferenceTopicsOrderByWithAggregationInput = {
    id?: SortOrder
    organizeId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConferenceTopicsCountOrderByAggregateInput
    _max?: ConferenceTopicsMaxOrderByAggregateInput
    _min?: ConferenceTopicsMinOrderByAggregateInput
  }

  export type ConferenceTopicsScalarWhereWithAggregatesInput = {
    AND?: ConferenceTopicsScalarWhereWithAggregatesInput | ConferenceTopicsScalarWhereWithAggregatesInput[]
    OR?: ConferenceTopicsScalarWhereWithAggregatesInput[]
    NOT?: ConferenceTopicsScalarWhereWithAggregatesInput | ConferenceTopicsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConferenceTopics"> | string
    organizeId?: StringWithAggregatesFilter<"ConferenceTopics"> | string
    topicId?: StringWithAggregatesFilter<"ConferenceTopics"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConferenceTopics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConferenceTopics"> | Date | string
  }

  export type ConferencesWhereInput = {
    AND?: ConferencesWhereInput | ConferencesWhereInput[]
    OR?: ConferencesWhereInput[]
    NOT?: ConferencesWhereInput | ConferencesWhereInput[]
    id?: StringFilter<"Conferences"> | string
    title?: StringFilter<"Conferences"> | string
    acronym?: StringFilter<"Conferences"> | string
    creatorId?: StringNullableFilter<"Conferences"> | string | null
    createdAt?: DateTimeFilter<"Conferences"> | Date | string
    updatedAt?: DateTimeFilter<"Conferences"> | Date | string
    status?: StringFilter<"Conferences"> | string
    adminId?: StringNullableFilter<"Conferences"> | string | null
    ConferenceBlacklists?: ConferenceBlacklistsListRelationFilter
    ConferenceCalendars?: ConferenceCalendarsListRelationFilter
    ConferenceCrawlJobs?: ConferenceCrawlJobsListRelationFilter
    ConferenceFeedbacks?: ConferenceFeedbacksListRelationFilter
    ConferenceFollows?: ConferenceFollowsListRelationFilter
    ConferenceLikes?: ConferenceLikesListRelationFilter
    ConferenceOrganizations?: ConferenceOrganizationsListRelationFilter
    ConferenceRanks?: ConferenceRanksListRelationFilter
    Admins?: XOR<AdminsNullableScalarRelationFilter, AdminsWhereInput> | null
    Users?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
  }

  export type ConferencesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    acronym?: SortOrder
    creatorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    adminId?: SortOrderInput | SortOrder
    ConferenceBlacklists?: ConferenceBlacklistsOrderByRelationAggregateInput
    ConferenceCalendars?: ConferenceCalendarsOrderByRelationAggregateInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsOrderByRelationAggregateInput
    ConferenceFeedbacks?: ConferenceFeedbacksOrderByRelationAggregateInput
    ConferenceFollows?: ConferenceFollowsOrderByRelationAggregateInput
    ConferenceLikes?: ConferenceLikesOrderByRelationAggregateInput
    ConferenceOrganizations?: ConferenceOrganizationsOrderByRelationAggregateInput
    ConferenceRanks?: ConferenceRanksOrderByRelationAggregateInput
    Admins?: AdminsOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type ConferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    title_acronym?: ConferencesTitleAcronymCompoundUniqueInput
    AND?: ConferencesWhereInput | ConferencesWhereInput[]
    OR?: ConferencesWhereInput[]
    NOT?: ConferencesWhereInput | ConferencesWhereInput[]
    title?: StringFilter<"Conferences"> | string
    acronym?: StringFilter<"Conferences"> | string
    creatorId?: StringNullableFilter<"Conferences"> | string | null
    createdAt?: DateTimeFilter<"Conferences"> | Date | string
    updatedAt?: DateTimeFilter<"Conferences"> | Date | string
    status?: StringFilter<"Conferences"> | string
    adminId?: StringNullableFilter<"Conferences"> | string | null
    ConferenceBlacklists?: ConferenceBlacklistsListRelationFilter
    ConferenceCalendars?: ConferenceCalendarsListRelationFilter
    ConferenceCrawlJobs?: ConferenceCrawlJobsListRelationFilter
    ConferenceFeedbacks?: ConferenceFeedbacksListRelationFilter
    ConferenceFollows?: ConferenceFollowsListRelationFilter
    ConferenceLikes?: ConferenceLikesListRelationFilter
    ConferenceOrganizations?: ConferenceOrganizationsListRelationFilter
    ConferenceRanks?: ConferenceRanksListRelationFilter
    Admins?: XOR<AdminsNullableScalarRelationFilter, AdminsWhereInput> | null
    Users?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
  }, "id" | "title_acronym">

  export type ConferencesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    acronym?: SortOrder
    creatorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    adminId?: SortOrderInput | SortOrder
    _count?: ConferencesCountOrderByAggregateInput
    _max?: ConferencesMaxOrderByAggregateInput
    _min?: ConferencesMinOrderByAggregateInput
  }

  export type ConferencesScalarWhereWithAggregatesInput = {
    AND?: ConferencesScalarWhereWithAggregatesInput | ConferencesScalarWhereWithAggregatesInput[]
    OR?: ConferencesScalarWhereWithAggregatesInput[]
    NOT?: ConferencesScalarWhereWithAggregatesInput | ConferencesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conferences"> | string
    title?: StringWithAggregatesFilter<"Conferences"> | string
    acronym?: StringWithAggregatesFilter<"Conferences"> | string
    creatorId?: StringNullableWithAggregatesFilter<"Conferences"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Conferences"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conferences"> | Date | string
    status?: StringWithAggregatesFilter<"Conferences"> | string
    adminId?: StringNullableWithAggregatesFilter<"Conferences"> | string | null
  }

  export type FieldOfResearchsWhereInput = {
    AND?: FieldOfResearchsWhereInput | FieldOfResearchsWhereInput[]
    OR?: FieldOfResearchsWhereInput[]
    NOT?: FieldOfResearchsWhereInput | FieldOfResearchsWhereInput[]
    id?: StringFilter<"FieldOfResearchs"> | string
    name?: StringFilter<"FieldOfResearchs"> | string
    code?: StringFilter<"FieldOfResearchs"> | string
    ConferenceRanks?: ConferenceRanksListRelationFilter
    JournalRanks?: JournalRanksListRelationFilter
  }

  export type FieldOfResearchsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    ConferenceRanks?: ConferenceRanksOrderByRelationAggregateInput
    JournalRanks?: JournalRanksOrderByRelationAggregateInput
  }

  export type FieldOfResearchsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FieldOfResearchsWhereInput | FieldOfResearchsWhereInput[]
    OR?: FieldOfResearchsWhereInput[]
    NOT?: FieldOfResearchsWhereInput | FieldOfResearchsWhereInput[]
    name?: StringFilter<"FieldOfResearchs"> | string
    code?: StringFilter<"FieldOfResearchs"> | string
    ConferenceRanks?: ConferenceRanksListRelationFilter
    JournalRanks?: JournalRanksListRelationFilter
  }, "id">

  export type FieldOfResearchsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    _count?: FieldOfResearchsCountOrderByAggregateInput
    _max?: FieldOfResearchsMaxOrderByAggregateInput
    _min?: FieldOfResearchsMinOrderByAggregateInput
  }

  export type FieldOfResearchsScalarWhereWithAggregatesInput = {
    AND?: FieldOfResearchsScalarWhereWithAggregatesInput | FieldOfResearchsScalarWhereWithAggregatesInput[]
    OR?: FieldOfResearchsScalarWhereWithAggregatesInput[]
    NOT?: FieldOfResearchsScalarWhereWithAggregatesInput | FieldOfResearchsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FieldOfResearchs"> | string
    name?: StringWithAggregatesFilter<"FieldOfResearchs"> | string
    code?: StringWithAggregatesFilter<"FieldOfResearchs"> | string
  }

  export type JournalCrawlJobsWhereInput = {
    AND?: JournalCrawlJobsWhereInput | JournalCrawlJobsWhereInput[]
    OR?: JournalCrawlJobsWhereInput[]
    NOT?: JournalCrawlJobsWhereInput | JournalCrawlJobsWhereInput[]
    id?: StringFilter<"JournalCrawlJobs"> | string
    journalId?: StringFilter<"JournalCrawlJobs"> | string
    status?: StringFilter<"JournalCrawlJobs"> | string
    progress?: IntFilter<"JournalCrawlJobs"> | number
    message?: StringFilter<"JournalCrawlJobs"> | string
    createdAt?: DateTimeFilter<"JournalCrawlJobs"> | Date | string
    updatedAt?: DateTimeFilter<"JournalCrawlJobs"> | Date | string
    Journals?: XOR<JournalsScalarRelationFilter, JournalsWhereInput>
  }

  export type JournalCrawlJobsOrderByWithRelationInput = {
    id?: SortOrder
    journalId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Journals?: JournalsOrderByWithRelationInput
  }

  export type JournalCrawlJobsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalCrawlJobsWhereInput | JournalCrawlJobsWhereInput[]
    OR?: JournalCrawlJobsWhereInput[]
    NOT?: JournalCrawlJobsWhereInput | JournalCrawlJobsWhereInput[]
    journalId?: StringFilter<"JournalCrawlJobs"> | string
    status?: StringFilter<"JournalCrawlJobs"> | string
    progress?: IntFilter<"JournalCrawlJobs"> | number
    message?: StringFilter<"JournalCrawlJobs"> | string
    createdAt?: DateTimeFilter<"JournalCrawlJobs"> | Date | string
    updatedAt?: DateTimeFilter<"JournalCrawlJobs"> | Date | string
    Journals?: XOR<JournalsScalarRelationFilter, JournalsWhereInput>
  }, "id">

  export type JournalCrawlJobsOrderByWithAggregationInput = {
    id?: SortOrder
    journalId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JournalCrawlJobsCountOrderByAggregateInput
    _avg?: JournalCrawlJobsAvgOrderByAggregateInput
    _max?: JournalCrawlJobsMaxOrderByAggregateInput
    _min?: JournalCrawlJobsMinOrderByAggregateInput
    _sum?: JournalCrawlJobsSumOrderByAggregateInput
  }

  export type JournalCrawlJobsScalarWhereWithAggregatesInput = {
    AND?: JournalCrawlJobsScalarWhereWithAggregatesInput | JournalCrawlJobsScalarWhereWithAggregatesInput[]
    OR?: JournalCrawlJobsScalarWhereWithAggregatesInput[]
    NOT?: JournalCrawlJobsScalarWhereWithAggregatesInput | JournalCrawlJobsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JournalCrawlJobs"> | string
    journalId?: StringWithAggregatesFilter<"JournalCrawlJobs"> | string
    status?: StringWithAggregatesFilter<"JournalCrawlJobs"> | string
    progress?: IntWithAggregatesFilter<"JournalCrawlJobs"> | number
    message?: StringWithAggregatesFilter<"JournalCrawlJobs"> | string
    createdAt?: DateTimeWithAggregatesFilter<"JournalCrawlJobs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JournalCrawlJobs"> | Date | string
  }

  export type JournalFollowsWhereInput = {
    AND?: JournalFollowsWhereInput | JournalFollowsWhereInput[]
    OR?: JournalFollowsWhereInput[]
    NOT?: JournalFollowsWhereInput | JournalFollowsWhereInput[]
    id?: StringFilter<"JournalFollows"> | string
    journalId?: StringFilter<"JournalFollows"> | string
    userId?: StringFilter<"JournalFollows"> | string
    createdAt?: DateTimeFilter<"JournalFollows"> | Date | string
    updatedAt?: DateTimeFilter<"JournalFollows"> | Date | string
    Journals?: XOR<JournalsScalarRelationFilter, JournalsWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type JournalFollowsOrderByWithRelationInput = {
    id?: SortOrder
    journalId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Journals?: JournalsOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type JournalFollowsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalFollowsWhereInput | JournalFollowsWhereInput[]
    OR?: JournalFollowsWhereInput[]
    NOT?: JournalFollowsWhereInput | JournalFollowsWhereInput[]
    journalId?: StringFilter<"JournalFollows"> | string
    userId?: StringFilter<"JournalFollows"> | string
    createdAt?: DateTimeFilter<"JournalFollows"> | Date | string
    updatedAt?: DateTimeFilter<"JournalFollows"> | Date | string
    Journals?: XOR<JournalsScalarRelationFilter, JournalsWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id">

  export type JournalFollowsOrderByWithAggregationInput = {
    id?: SortOrder
    journalId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JournalFollowsCountOrderByAggregateInput
    _max?: JournalFollowsMaxOrderByAggregateInput
    _min?: JournalFollowsMinOrderByAggregateInput
  }

  export type JournalFollowsScalarWhereWithAggregatesInput = {
    AND?: JournalFollowsScalarWhereWithAggregatesInput | JournalFollowsScalarWhereWithAggregatesInput[]
    OR?: JournalFollowsScalarWhereWithAggregatesInput[]
    NOT?: JournalFollowsScalarWhereWithAggregatesInput | JournalFollowsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JournalFollows"> | string
    journalId?: StringWithAggregatesFilter<"JournalFollows"> | string
    userId?: StringWithAggregatesFilter<"JournalFollows"> | string
    createdAt?: DateTimeWithAggregatesFilter<"JournalFollows"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JournalFollows"> | Date | string
  }

  export type JournalLikesWhereInput = {
    AND?: JournalLikesWhereInput | JournalLikesWhereInput[]
    OR?: JournalLikesWhereInput[]
    NOT?: JournalLikesWhereInput | JournalLikesWhereInput[]
    id?: StringFilter<"JournalLikes"> | string
    journalId?: StringFilter<"JournalLikes"> | string
    userId?: StringFilter<"JournalLikes"> | string
    createdAt?: DateTimeFilter<"JournalLikes"> | Date | string
    updatedAt?: DateTimeFilter<"JournalLikes"> | Date | string
    Journals?: XOR<JournalsScalarRelationFilter, JournalsWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type JournalLikesOrderByWithRelationInput = {
    id?: SortOrder
    journalId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Journals?: JournalsOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type JournalLikesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalLikesWhereInput | JournalLikesWhereInput[]
    OR?: JournalLikesWhereInput[]
    NOT?: JournalLikesWhereInput | JournalLikesWhereInput[]
    journalId?: StringFilter<"JournalLikes"> | string
    userId?: StringFilter<"JournalLikes"> | string
    createdAt?: DateTimeFilter<"JournalLikes"> | Date | string
    updatedAt?: DateTimeFilter<"JournalLikes"> | Date | string
    Journals?: XOR<JournalsScalarRelationFilter, JournalsWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id">

  export type JournalLikesOrderByWithAggregationInput = {
    id?: SortOrder
    journalId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JournalLikesCountOrderByAggregateInput
    _max?: JournalLikesMaxOrderByAggregateInput
    _min?: JournalLikesMinOrderByAggregateInput
  }

  export type JournalLikesScalarWhereWithAggregatesInput = {
    AND?: JournalLikesScalarWhereWithAggregatesInput | JournalLikesScalarWhereWithAggregatesInput[]
    OR?: JournalLikesScalarWhereWithAggregatesInput[]
    NOT?: JournalLikesScalarWhereWithAggregatesInput | JournalLikesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JournalLikes"> | string
    journalId?: StringWithAggregatesFilter<"JournalLikes"> | string
    userId?: StringWithAggregatesFilter<"JournalLikes"> | string
    createdAt?: DateTimeWithAggregatesFilter<"JournalLikes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JournalLikes"> | Date | string
  }

  export type JournalRanksWhereInput = {
    AND?: JournalRanksWhereInput | JournalRanksWhereInput[]
    OR?: JournalRanksWhereInput[]
    NOT?: JournalRanksWhereInput | JournalRanksWhereInput[]
    id?: StringFilter<"JournalRanks"> | string
    year?: IntFilter<"JournalRanks"> | number
    journalId?: StringFilter<"JournalRanks"> | string
    fieldOfResearchId?: StringFilter<"JournalRanks"> | string
    rankId?: StringFilter<"JournalRanks"> | string
    FieldOfResearchs?: XOR<FieldOfResearchsScalarRelationFilter, FieldOfResearchsWhereInput>
    Journals?: XOR<JournalsScalarRelationFilter, JournalsWhereInput>
    Ranks?: XOR<RanksScalarRelationFilter, RanksWhereInput>
  }

  export type JournalRanksOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrder
    journalId?: SortOrder
    fieldOfResearchId?: SortOrder
    rankId?: SortOrder
    FieldOfResearchs?: FieldOfResearchsOrderByWithRelationInput
    Journals?: JournalsOrderByWithRelationInput
    Ranks?: RanksOrderByWithRelationInput
  }

  export type JournalRanksWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalRanksWhereInput | JournalRanksWhereInput[]
    OR?: JournalRanksWhereInput[]
    NOT?: JournalRanksWhereInput | JournalRanksWhereInput[]
    year?: IntFilter<"JournalRanks"> | number
    journalId?: StringFilter<"JournalRanks"> | string
    fieldOfResearchId?: StringFilter<"JournalRanks"> | string
    rankId?: StringFilter<"JournalRanks"> | string
    FieldOfResearchs?: XOR<FieldOfResearchsScalarRelationFilter, FieldOfResearchsWhereInput>
    Journals?: XOR<JournalsScalarRelationFilter, JournalsWhereInput>
    Ranks?: XOR<RanksScalarRelationFilter, RanksWhereInput>
  }, "id">

  export type JournalRanksOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrder
    journalId?: SortOrder
    fieldOfResearchId?: SortOrder
    rankId?: SortOrder
    _count?: JournalRanksCountOrderByAggregateInput
    _avg?: JournalRanksAvgOrderByAggregateInput
    _max?: JournalRanksMaxOrderByAggregateInput
    _min?: JournalRanksMinOrderByAggregateInput
    _sum?: JournalRanksSumOrderByAggregateInput
  }

  export type JournalRanksScalarWhereWithAggregatesInput = {
    AND?: JournalRanksScalarWhereWithAggregatesInput | JournalRanksScalarWhereWithAggregatesInput[]
    OR?: JournalRanksScalarWhereWithAggregatesInput[]
    NOT?: JournalRanksScalarWhereWithAggregatesInput | JournalRanksScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JournalRanks"> | string
    year?: IntWithAggregatesFilter<"JournalRanks"> | number
    journalId?: StringWithAggregatesFilter<"JournalRanks"> | string
    fieldOfResearchId?: StringWithAggregatesFilter<"JournalRanks"> | string
    rankId?: StringWithAggregatesFilter<"JournalRanks"> | string
  }

  export type JournalTopicsWhereInput = {
    AND?: JournalTopicsWhereInput | JournalTopicsWhereInput[]
    OR?: JournalTopicsWhereInput[]
    NOT?: JournalTopicsWhereInput | JournalTopicsWhereInput[]
    id?: StringFilter<"JournalTopics"> | string
    journalId?: StringFilter<"JournalTopics"> | string
    topicId?: StringFilter<"JournalTopics"> | string
    Journals?: XOR<JournalsScalarRelationFilter, JournalsWhereInput>
    Topics?: XOR<TopicsScalarRelationFilter, TopicsWhereInput>
  }

  export type JournalTopicsOrderByWithRelationInput = {
    id?: SortOrder
    journalId?: SortOrder
    topicId?: SortOrder
    Journals?: JournalsOrderByWithRelationInput
    Topics?: TopicsOrderByWithRelationInput
  }

  export type JournalTopicsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalTopicsWhereInput | JournalTopicsWhereInput[]
    OR?: JournalTopicsWhereInput[]
    NOT?: JournalTopicsWhereInput | JournalTopicsWhereInput[]
    journalId?: StringFilter<"JournalTopics"> | string
    topicId?: StringFilter<"JournalTopics"> | string
    Journals?: XOR<JournalsScalarRelationFilter, JournalsWhereInput>
    Topics?: XOR<TopicsScalarRelationFilter, TopicsWhereInput>
  }, "id">

  export type JournalTopicsOrderByWithAggregationInput = {
    id?: SortOrder
    journalId?: SortOrder
    topicId?: SortOrder
    _count?: JournalTopicsCountOrderByAggregateInput
    _max?: JournalTopicsMaxOrderByAggregateInput
    _min?: JournalTopicsMinOrderByAggregateInput
  }

  export type JournalTopicsScalarWhereWithAggregatesInput = {
    AND?: JournalTopicsScalarWhereWithAggregatesInput | JournalTopicsScalarWhereWithAggregatesInput[]
    OR?: JournalTopicsScalarWhereWithAggregatesInput[]
    NOT?: JournalTopicsScalarWhereWithAggregatesInput | JournalTopicsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JournalTopics"> | string
    journalId?: StringWithAggregatesFilter<"JournalTopics"> | string
    topicId?: StringWithAggregatesFilter<"JournalTopics"> | string
  }

  export type JournalsWhereInput = {
    AND?: JournalsWhereInput | JournalsWhereInput[]
    OR?: JournalsWhereInput[]
    NOT?: JournalsWhereInput | JournalsWhereInput[]
    id?: StringFilter<"Journals"> | string
    name?: StringFilter<"Journals"> | string
    issn?: StringFilter<"Journals"> | string
    hIndex?: IntFilter<"Journals"> | number
    publisher?: StringFilter<"Journals"> | string
    nation?: StringFilter<"Journals"> | string
    scope?: StringFilter<"Journals"> | string
    emailSubmission?: StringFilter<"Journals"> | string
    creator?: StringFilter<"Journals"> | string
    JournalCrawlJobs?: JournalCrawlJobsListRelationFilter
    JournalFollows?: JournalFollowsListRelationFilter
    JournalLikes?: JournalLikesListRelationFilter
    JournalRanks?: JournalRanksListRelationFilter
    JournalTopics?: JournalTopicsListRelationFilter
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type JournalsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    issn?: SortOrder
    hIndex?: SortOrder
    publisher?: SortOrder
    nation?: SortOrder
    scope?: SortOrder
    emailSubmission?: SortOrder
    creator?: SortOrder
    JournalCrawlJobs?: JournalCrawlJobsOrderByRelationAggregateInput
    JournalFollows?: JournalFollowsOrderByRelationAggregateInput
    JournalLikes?: JournalLikesOrderByRelationAggregateInput
    JournalRanks?: JournalRanksOrderByRelationAggregateInput
    JournalTopics?: JournalTopicsOrderByRelationAggregateInput
    Users?: UsersOrderByWithRelationInput
  }

  export type JournalsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalsWhereInput | JournalsWhereInput[]
    OR?: JournalsWhereInput[]
    NOT?: JournalsWhereInput | JournalsWhereInput[]
    name?: StringFilter<"Journals"> | string
    issn?: StringFilter<"Journals"> | string
    hIndex?: IntFilter<"Journals"> | number
    publisher?: StringFilter<"Journals"> | string
    nation?: StringFilter<"Journals"> | string
    scope?: StringFilter<"Journals"> | string
    emailSubmission?: StringFilter<"Journals"> | string
    creator?: StringFilter<"Journals"> | string
    JournalCrawlJobs?: JournalCrawlJobsListRelationFilter
    JournalFollows?: JournalFollowsListRelationFilter
    JournalLikes?: JournalLikesListRelationFilter
    JournalRanks?: JournalRanksListRelationFilter
    JournalTopics?: JournalTopicsListRelationFilter
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id">

  export type JournalsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    issn?: SortOrder
    hIndex?: SortOrder
    publisher?: SortOrder
    nation?: SortOrder
    scope?: SortOrder
    emailSubmission?: SortOrder
    creator?: SortOrder
    _count?: JournalsCountOrderByAggregateInput
    _avg?: JournalsAvgOrderByAggregateInput
    _max?: JournalsMaxOrderByAggregateInput
    _min?: JournalsMinOrderByAggregateInput
    _sum?: JournalsSumOrderByAggregateInput
  }

  export type JournalsScalarWhereWithAggregatesInput = {
    AND?: JournalsScalarWhereWithAggregatesInput | JournalsScalarWhereWithAggregatesInput[]
    OR?: JournalsScalarWhereWithAggregatesInput[]
    NOT?: JournalsScalarWhereWithAggregatesInput | JournalsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Journals"> | string
    name?: StringWithAggregatesFilter<"Journals"> | string
    issn?: StringWithAggregatesFilter<"Journals"> | string
    hIndex?: IntWithAggregatesFilter<"Journals"> | number
    publisher?: StringWithAggregatesFilter<"Journals"> | string
    nation?: StringWithAggregatesFilter<"Journals"> | string
    scope?: StringWithAggregatesFilter<"Journals"> | string
    emailSubmission?: StringWithAggregatesFilter<"Journals"> | string
    creator?: StringWithAggregatesFilter<"Journals"> | string
  }

  export type LocationsWhereInput = {
    AND?: LocationsWhereInput | LocationsWhereInput[]
    OR?: LocationsWhereInput[]
    NOT?: LocationsWhereInput | LocationsWhereInput[]
    id?: StringFilter<"Locations"> | string
    address?: StringNullableFilter<"Locations"> | string | null
    cityStateProvince?: StringNullableFilter<"Locations"> | string | null
    country?: StringNullableFilter<"Locations"> | string | null
    continent?: StringNullableFilter<"Locations"> | string | null
    createdAt?: DateTimeFilter<"Locations"> | Date | string
    updatedAt?: DateTimeFilter<"Locations"> | Date | string
    isAvailable?: BoolFilter<"Locations"> | boolean
    organizeId?: StringFilter<"Locations"> | string
    ConferenceOrganizations?: XOR<ConferenceOrganizationsScalarRelationFilter, ConferenceOrganizationsWhereInput>
  }

  export type LocationsOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrderInput | SortOrder
    cityStateProvince?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    continent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAvailable?: SortOrder
    organizeId?: SortOrder
    ConferenceOrganizations?: ConferenceOrganizationsOrderByWithRelationInput
  }

  export type LocationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationsWhereInput | LocationsWhereInput[]
    OR?: LocationsWhereInput[]
    NOT?: LocationsWhereInput | LocationsWhereInput[]
    address?: StringNullableFilter<"Locations"> | string | null
    cityStateProvince?: StringNullableFilter<"Locations"> | string | null
    country?: StringNullableFilter<"Locations"> | string | null
    continent?: StringNullableFilter<"Locations"> | string | null
    createdAt?: DateTimeFilter<"Locations"> | Date | string
    updatedAt?: DateTimeFilter<"Locations"> | Date | string
    isAvailable?: BoolFilter<"Locations"> | boolean
    organizeId?: StringFilter<"Locations"> | string
    ConferenceOrganizations?: XOR<ConferenceOrganizationsScalarRelationFilter, ConferenceOrganizationsWhereInput>
  }, "id">

  export type LocationsOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrderInput | SortOrder
    cityStateProvince?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    continent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAvailable?: SortOrder
    organizeId?: SortOrder
    _count?: LocationsCountOrderByAggregateInput
    _max?: LocationsMaxOrderByAggregateInput
    _min?: LocationsMinOrderByAggregateInput
  }

  export type LocationsScalarWhereWithAggregatesInput = {
    AND?: LocationsScalarWhereWithAggregatesInput | LocationsScalarWhereWithAggregatesInput[]
    OR?: LocationsScalarWhereWithAggregatesInput[]
    NOT?: LocationsScalarWhereWithAggregatesInput | LocationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Locations"> | string
    address?: StringNullableWithAggregatesFilter<"Locations"> | string | null
    cityStateProvince?: StringNullableWithAggregatesFilter<"Locations"> | string | null
    country?: StringNullableWithAggregatesFilter<"Locations"> | string | null
    continent?: StringNullableWithAggregatesFilter<"Locations"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Locations"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Locations"> | Date | string
    isAvailable?: BoolWithAggregatesFilter<"Locations"> | boolean
    organizeId?: StringWithAggregatesFilter<"Locations"> | string
  }

  export type NotificationSettingsWhereInput = {
    AND?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    OR?: NotificationSettingsWhereInput[]
    NOT?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    id?: StringFilter<"NotificationSettings"> | string
    userId?: StringFilter<"NotificationSettings"> | string
    notificationId?: StringFilter<"NotificationSettings"> | string
    isEnabled?: BoolFilter<"NotificationSettings"> | boolean
    createdAt?: DateTimeFilter<"NotificationSettings"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationSettings"> | Date | string
    NotificationsTypes?: XOR<NotificationsTypesScalarRelationFilter, NotificationsTypesWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type NotificationSettingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationId?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    NotificationsTypes?: NotificationsTypesOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type NotificationSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    OR?: NotificationSettingsWhereInput[]
    NOT?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    userId?: StringFilter<"NotificationSettings"> | string
    notificationId?: StringFilter<"NotificationSettings"> | string
    isEnabled?: BoolFilter<"NotificationSettings"> | boolean
    createdAt?: DateTimeFilter<"NotificationSettings"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationSettings"> | Date | string
    NotificationsTypes?: XOR<NotificationsTypesScalarRelationFilter, NotificationsTypesWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id">

  export type NotificationSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationId?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationSettingsCountOrderByAggregateInput
    _max?: NotificationSettingsMaxOrderByAggregateInput
    _min?: NotificationSettingsMinOrderByAggregateInput
  }

  export type NotificationSettingsScalarWhereWithAggregatesInput = {
    AND?: NotificationSettingsScalarWhereWithAggregatesInput | NotificationSettingsScalarWhereWithAggregatesInput[]
    OR?: NotificationSettingsScalarWhereWithAggregatesInput[]
    NOT?: NotificationSettingsScalarWhereWithAggregatesInput | NotificationSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationSettings"> | string
    userId?: StringWithAggregatesFilter<"NotificationSettings"> | string
    notificationId?: StringWithAggregatesFilter<"NotificationSettings"> | string
    isEnabled?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NotificationSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationSettings"> | Date | string
  }

  export type NotificationsWhereInput = {
    AND?: NotificationsWhereInput | NotificationsWhereInput[]
    OR?: NotificationsWhereInput[]
    NOT?: NotificationsWhereInput | NotificationsWhereInput[]
    id?: StringFilter<"Notifications"> | string
    notificationId?: StringFilter<"Notifications"> | string
    userId?: StringFilter<"Notifications"> | string
    message?: StringFilter<"Notifications"> | string
    isRead?: BoolFilter<"Notifications"> | boolean
    createdAt?: DateTimeFilter<"Notifications"> | Date | string
    updatedAt?: DateTimeFilter<"Notifications"> | Date | string
    NotificationsTypes?: XOR<NotificationsTypesScalarRelationFilter, NotificationsTypesWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type NotificationsOrderByWithRelationInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    NotificationsTypes?: NotificationsTypesOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type NotificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_notificationId?: NotificationsUserIdNotificationIdCompoundUniqueInput
    AND?: NotificationsWhereInput | NotificationsWhereInput[]
    OR?: NotificationsWhereInput[]
    NOT?: NotificationsWhereInput | NotificationsWhereInput[]
    notificationId?: StringFilter<"Notifications"> | string
    userId?: StringFilter<"Notifications"> | string
    message?: StringFilter<"Notifications"> | string
    isRead?: BoolFilter<"Notifications"> | boolean
    createdAt?: DateTimeFilter<"Notifications"> | Date | string
    updatedAt?: DateTimeFilter<"Notifications"> | Date | string
    NotificationsTypes?: XOR<NotificationsTypesScalarRelationFilter, NotificationsTypesWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id" | "userId_notificationId">

  export type NotificationsOrderByWithAggregationInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationsCountOrderByAggregateInput
    _max?: NotificationsMaxOrderByAggregateInput
    _min?: NotificationsMinOrderByAggregateInput
  }

  export type NotificationsScalarWhereWithAggregatesInput = {
    AND?: NotificationsScalarWhereWithAggregatesInput | NotificationsScalarWhereWithAggregatesInput[]
    OR?: NotificationsScalarWhereWithAggregatesInput[]
    NOT?: NotificationsScalarWhereWithAggregatesInput | NotificationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notifications"> | string
    notificationId?: StringWithAggregatesFilter<"Notifications"> | string
    userId?: StringWithAggregatesFilter<"Notifications"> | string
    message?: StringWithAggregatesFilter<"Notifications"> | string
    isRead?: BoolWithAggregatesFilter<"Notifications"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notifications"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notifications"> | Date | string
  }

  export type NotificationsTypesWhereInput = {
    AND?: NotificationsTypesWhereInput | NotificationsTypesWhereInput[]
    OR?: NotificationsTypesWhereInput[]
    NOT?: NotificationsTypesWhereInput | NotificationsTypesWhereInput[]
    id?: StringFilter<"NotificationsTypes"> | string
    name?: StringFilter<"NotificationsTypes"> | string
    createdAt?: DateTimeFilter<"NotificationsTypes"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationsTypes"> | Date | string
    NotificationSettings?: NotificationSettingsListRelationFilter
    Notifications?: NotificationsListRelationFilter
  }

  export type NotificationsTypesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    NotificationSettings?: NotificationSettingsOrderByRelationAggregateInput
    Notifications?: NotificationsOrderByRelationAggregateInput
  }

  export type NotificationsTypesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: NotificationsTypesWhereInput | NotificationsTypesWhereInput[]
    OR?: NotificationsTypesWhereInput[]
    NOT?: NotificationsTypesWhereInput | NotificationsTypesWhereInput[]
    createdAt?: DateTimeFilter<"NotificationsTypes"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationsTypes"> | Date | string
    NotificationSettings?: NotificationSettingsListRelationFilter
    Notifications?: NotificationsListRelationFilter
  }, "id" | "name">

  export type NotificationsTypesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationsTypesCountOrderByAggregateInput
    _max?: NotificationsTypesMaxOrderByAggregateInput
    _min?: NotificationsTypesMinOrderByAggregateInput
  }

  export type NotificationsTypesScalarWhereWithAggregatesInput = {
    AND?: NotificationsTypesScalarWhereWithAggregatesInput | NotificationsTypesScalarWhereWithAggregatesInput[]
    OR?: NotificationsTypesScalarWhereWithAggregatesInput[]
    NOT?: NotificationsTypesScalarWhereWithAggregatesInput | NotificationsTypesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationsTypes"> | string
    name?: StringWithAggregatesFilter<"NotificationsTypes"> | string
    createdAt?: DateTimeWithAggregatesFilter<"NotificationsTypes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationsTypes"> | Date | string
  }

  export type PassengerWhereInput = {
    AND?: PassengerWhereInput | PassengerWhereInput[]
    OR?: PassengerWhereInput[]
    NOT?: PassengerWhereInput | PassengerWhereInput[]
    id?: StringFilter<"Passenger"> | string
    firstName?: StringFilter<"Passenger"> | string
    lastName?: StringFilter<"Passenger"> | string
  }

  export type PassengerOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
  }

  export type PassengerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    firstName?: string
    AND?: PassengerWhereInput | PassengerWhereInput[]
    OR?: PassengerWhereInput[]
    NOT?: PassengerWhereInput | PassengerWhereInput[]
    lastName?: StringFilter<"Passenger"> | string
  }, "id" | "firstName">

  export type PassengerOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    _count?: PassengerCountOrderByAggregateInput
    _max?: PassengerMaxOrderByAggregateInput
    _min?: PassengerMinOrderByAggregateInput
  }

  export type PassengerScalarWhereWithAggregatesInput = {
    AND?: PassengerScalarWhereWithAggregatesInput | PassengerScalarWhereWithAggregatesInput[]
    OR?: PassengerScalarWhereWithAggregatesInput[]
    NOT?: PassengerScalarWhereWithAggregatesInput | PassengerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Passenger"> | string
    firstName?: StringWithAggregatesFilter<"Passenger"> | string
    lastName?: StringWithAggregatesFilter<"Passenger"> | string
  }

  export type RanksWhereInput = {
    AND?: RanksWhereInput | RanksWhereInput[]
    OR?: RanksWhereInput[]
    NOT?: RanksWhereInput | RanksWhereInput[]
    id?: StringFilter<"Ranks"> | string
    name?: StringFilter<"Ranks"> | string
    value?: IntFilter<"Ranks"> | number
    sourceId?: StringFilter<"Ranks"> | string
    ConferenceRanks?: ConferenceRanksListRelationFilter
    JournalRanks?: JournalRanksListRelationFilter
    Sources?: XOR<SourcesScalarRelationFilter, SourcesWhereInput>
  }

  export type RanksOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    sourceId?: SortOrder
    ConferenceRanks?: ConferenceRanksOrderByRelationAggregateInput
    JournalRanks?: JournalRanksOrderByRelationAggregateInput
    Sources?: SourcesOrderByWithRelationInput
  }

  export type RanksWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RanksWhereInput | RanksWhereInput[]
    OR?: RanksWhereInput[]
    NOT?: RanksWhereInput | RanksWhereInput[]
    name?: StringFilter<"Ranks"> | string
    value?: IntFilter<"Ranks"> | number
    sourceId?: StringFilter<"Ranks"> | string
    ConferenceRanks?: ConferenceRanksListRelationFilter
    JournalRanks?: JournalRanksListRelationFilter
    Sources?: XOR<SourcesScalarRelationFilter, SourcesWhereInput>
  }, "id">

  export type RanksOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    sourceId?: SortOrder
    _count?: RanksCountOrderByAggregateInput
    _avg?: RanksAvgOrderByAggregateInput
    _max?: RanksMaxOrderByAggregateInput
    _min?: RanksMinOrderByAggregateInput
    _sum?: RanksSumOrderByAggregateInput
  }

  export type RanksScalarWhereWithAggregatesInput = {
    AND?: RanksScalarWhereWithAggregatesInput | RanksScalarWhereWithAggregatesInput[]
    OR?: RanksScalarWhereWithAggregatesInput[]
    NOT?: RanksScalarWhereWithAggregatesInput | RanksScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ranks"> | string
    name?: StringWithAggregatesFilter<"Ranks"> | string
    value?: IntWithAggregatesFilter<"Ranks"> | number
    sourceId?: StringWithAggregatesFilter<"Ranks"> | string
  }

  export type SourcesWhereInput = {
    AND?: SourcesWhereInput | SourcesWhereInput[]
    OR?: SourcesWhereInput[]
    NOT?: SourcesWhereInput | SourcesWhereInput[]
    id?: StringFilter<"Sources"> | string
    name?: StringFilter<"Sources"> | string
    link?: StringNullableFilter<"Sources"> | string | null
    Ranks?: RanksListRelationFilter
  }

  export type SourcesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrderInput | SortOrder
    Ranks?: RanksOrderByRelationAggregateInput
  }

  export type SourcesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SourcesWhereInput | SourcesWhereInput[]
    OR?: SourcesWhereInput[]
    NOT?: SourcesWhereInput | SourcesWhereInput[]
    link?: StringNullableFilter<"Sources"> | string | null
    Ranks?: RanksListRelationFilter
  }, "id" | "name">

  export type SourcesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrderInput | SortOrder
    _count?: SourcesCountOrderByAggregateInput
    _max?: SourcesMaxOrderByAggregateInput
    _min?: SourcesMinOrderByAggregateInput
  }

  export type SourcesScalarWhereWithAggregatesInput = {
    AND?: SourcesScalarWhereWithAggregatesInput | SourcesScalarWhereWithAggregatesInput[]
    OR?: SourcesScalarWhereWithAggregatesInput[]
    NOT?: SourcesScalarWhereWithAggregatesInput | SourcesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sources"> | string
    name?: StringWithAggregatesFilter<"Sources"> | string
    link?: StringNullableWithAggregatesFilter<"Sources"> | string | null
  }

  export type TopicUserInterestedsWhereInput = {
    AND?: TopicUserInterestedsWhereInput | TopicUserInterestedsWhereInput[]
    OR?: TopicUserInterestedsWhereInput[]
    NOT?: TopicUserInterestedsWhereInput | TopicUserInterestedsWhereInput[]
    userId?: StringFilter<"TopicUserInteresteds"> | string
    topicId?: StringFilter<"TopicUserInteresteds"> | string
    createdAt?: DateTimeFilter<"TopicUserInteresteds"> | Date | string
    updatedAt?: DateTimeFilter<"TopicUserInteresteds"> | Date | string
    Topics?: XOR<TopicsScalarRelationFilter, TopicsWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type TopicUserInterestedsOrderByWithRelationInput = {
    userId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Topics?: TopicsOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type TopicUserInterestedsWhereUniqueInput = Prisma.AtLeast<{
    userId_topicId?: TopicUserInterestedsUserIdTopicIdCompoundUniqueInput
    AND?: TopicUserInterestedsWhereInput | TopicUserInterestedsWhereInput[]
    OR?: TopicUserInterestedsWhereInput[]
    NOT?: TopicUserInterestedsWhereInput | TopicUserInterestedsWhereInput[]
    userId?: StringFilter<"TopicUserInteresteds"> | string
    topicId?: StringFilter<"TopicUserInteresteds"> | string
    createdAt?: DateTimeFilter<"TopicUserInteresteds"> | Date | string
    updatedAt?: DateTimeFilter<"TopicUserInteresteds"> | Date | string
    Topics?: XOR<TopicsScalarRelationFilter, TopicsWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "userId_topicId">

  export type TopicUserInterestedsOrderByWithAggregationInput = {
    userId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TopicUserInterestedsCountOrderByAggregateInput
    _max?: TopicUserInterestedsMaxOrderByAggregateInput
    _min?: TopicUserInterestedsMinOrderByAggregateInput
  }

  export type TopicUserInterestedsScalarWhereWithAggregatesInput = {
    AND?: TopicUserInterestedsScalarWhereWithAggregatesInput | TopicUserInterestedsScalarWhereWithAggregatesInput[]
    OR?: TopicUserInterestedsScalarWhereWithAggregatesInput[]
    NOT?: TopicUserInterestedsScalarWhereWithAggregatesInput | TopicUserInterestedsScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"TopicUserInteresteds"> | string
    topicId?: StringWithAggregatesFilter<"TopicUserInteresteds"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TopicUserInteresteds"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TopicUserInteresteds"> | Date | string
  }

  export type TopicsWhereInput = {
    AND?: TopicsWhereInput | TopicsWhereInput[]
    OR?: TopicsWhereInput[]
    NOT?: TopicsWhereInput | TopicsWhereInput[]
    id?: StringFilter<"Topics"> | string
    name?: StringFilter<"Topics"> | string
    createdAt?: DateTimeFilter<"Topics"> | Date | string
    updatedAt?: DateTimeFilter<"Topics"> | Date | string
    ConferenceTopics?: ConferenceTopicsListRelationFilter
    JournalTopics?: JournalTopicsListRelationFilter
    TopicUserInteresteds?: TopicUserInterestedsListRelationFilter
  }

  export type TopicsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ConferenceTopics?: ConferenceTopicsOrderByRelationAggregateInput
    JournalTopics?: JournalTopicsOrderByRelationAggregateInput
    TopicUserInteresteds?: TopicUserInterestedsOrderByRelationAggregateInput
  }

  export type TopicsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TopicsWhereInput | TopicsWhereInput[]
    OR?: TopicsWhereInput[]
    NOT?: TopicsWhereInput | TopicsWhereInput[]
    createdAt?: DateTimeFilter<"Topics"> | Date | string
    updatedAt?: DateTimeFilter<"Topics"> | Date | string
    ConferenceTopics?: ConferenceTopicsListRelationFilter
    JournalTopics?: JournalTopicsListRelationFilter
    TopicUserInteresteds?: TopicUserInterestedsListRelationFilter
  }, "id" | "name">

  export type TopicsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TopicsCountOrderByAggregateInput
    _max?: TopicsMaxOrderByAggregateInput
    _min?: TopicsMinOrderByAggregateInput
  }

  export type TopicsScalarWhereWithAggregatesInput = {
    AND?: TopicsScalarWhereWithAggregatesInput | TopicsScalarWhereWithAggregatesInput[]
    OR?: TopicsScalarWhereWithAggregatesInput[]
    NOT?: TopicsScalarWhereWithAggregatesInput | TopicsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Topics"> | string
    name?: StringWithAggregatesFilter<"Topics"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Topics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Topics"> | Date | string
  }

  export type UserVerificationWhereInput = {
    AND?: UserVerificationWhereInput | UserVerificationWhereInput[]
    OR?: UserVerificationWhereInput[]
    NOT?: UserVerificationWhereInput | UserVerificationWhereInput[]
    id?: StringFilter<"UserVerification"> | string
    userId?: StringFilter<"UserVerification"> | string
    verificationCode?: StringFilter<"UserVerification"> | string
    verificationCodeExpires?: DateTimeFilter<"UserVerification"> | Date | string
    isVerified?: BoolFilter<"UserVerification"> | boolean
    createdAt?: DateTimeFilter<"UserVerification"> | Date | string
    updatedAt?: DateTimeFilter<"UserVerification"> | Date | string
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type UserVerificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    verificationCode?: SortOrder
    verificationCodeExpires?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Users?: UsersOrderByWithRelationInput
  }

  export type UserVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_verificationCode_verificationCodeExpires?: UserVerificationUserIdVerificationCodeVerificationCodeExpiresCompoundUniqueInput
    AND?: UserVerificationWhereInput | UserVerificationWhereInput[]
    OR?: UserVerificationWhereInput[]
    NOT?: UserVerificationWhereInput | UserVerificationWhereInput[]
    userId?: StringFilter<"UserVerification"> | string
    verificationCode?: StringFilter<"UserVerification"> | string
    verificationCodeExpires?: DateTimeFilter<"UserVerification"> | Date | string
    isVerified?: BoolFilter<"UserVerification"> | boolean
    createdAt?: DateTimeFilter<"UserVerification"> | Date | string
    updatedAt?: DateTimeFilter<"UserVerification"> | Date | string
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id" | "userId_verificationCode_verificationCodeExpires">

  export type UserVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    verificationCode?: SortOrder
    verificationCodeExpires?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserVerificationCountOrderByAggregateInput
    _max?: UserVerificationMaxOrderByAggregateInput
    _min?: UserVerificationMinOrderByAggregateInput
  }

  export type UserVerificationScalarWhereWithAggregatesInput = {
    AND?: UserVerificationScalarWhereWithAggregatesInput | UserVerificationScalarWhereWithAggregatesInput[]
    OR?: UserVerificationScalarWhereWithAggregatesInput[]
    NOT?: UserVerificationScalarWhereWithAggregatesInput | UserVerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserVerification"> | string
    userId?: StringWithAggregatesFilter<"UserVerification"> | string
    verificationCode?: StringWithAggregatesFilter<"UserVerification"> | string
    verificationCodeExpires?: DateTimeWithAggregatesFilter<"UserVerification"> | Date | string
    isVerified?: BoolWithAggregatesFilter<"UserVerification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserVerification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserVerification"> | Date | string
  }

  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    id?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    password?: StringFilter<"Users"> | string
    firstName?: StringFilter<"Users"> | string
    lastName?: StringFilter<"Users"> | string
    dob?: DateTimeFilter<"Users"> | Date | string
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    aboutMe?: StringFilter<"Users"> | string
    avatar?: StringFilter<"Users"> | string
    background?: StringFilter<"Users"> | string
    ConferenceBlacklists?: ConferenceBlacklistsListRelationFilter
    ConferenceCalendars?: ConferenceCalendarsListRelationFilter
    ConferenceFeedbacks?: ConferenceFeedbacksListRelationFilter
    ConferenceFollows?: ConferenceFollowsListRelationFilter
    ConferenceLikes?: ConferenceLikesListRelationFilter
    Conferences?: ConferencesListRelationFilter
    JournalFollows?: JournalFollowsListRelationFilter
    JournalLikes?: JournalLikesListRelationFilter
    Journals?: JournalsListRelationFilter
    NotificationSettings?: NotificationSettingsListRelationFilter
    Notifications?: NotificationsListRelationFilter
    TopicUserInteresteds?: TopicUserInterestedsListRelationFilter
    UserVerification?: UserVerificationListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aboutMe?: SortOrder
    avatar?: SortOrder
    background?: SortOrder
    ConferenceBlacklists?: ConferenceBlacklistsOrderByRelationAggregateInput
    ConferenceCalendars?: ConferenceCalendarsOrderByRelationAggregateInput
    ConferenceFeedbacks?: ConferenceFeedbacksOrderByRelationAggregateInput
    ConferenceFollows?: ConferenceFollowsOrderByRelationAggregateInput
    ConferenceLikes?: ConferenceLikesOrderByRelationAggregateInput
    Conferences?: ConferencesOrderByRelationAggregateInput
    JournalFollows?: JournalFollowsOrderByRelationAggregateInput
    JournalLikes?: JournalLikesOrderByRelationAggregateInput
    Journals?: JournalsOrderByRelationAggregateInput
    NotificationSettings?: NotificationSettingsOrderByRelationAggregateInput
    Notifications?: NotificationsOrderByRelationAggregateInput
    TopicUserInteresteds?: TopicUserInterestedsOrderByRelationAggregateInput
    UserVerification?: UserVerificationOrderByRelationAggregateInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    password?: StringFilter<"Users"> | string
    firstName?: StringFilter<"Users"> | string
    lastName?: StringFilter<"Users"> | string
    dob?: DateTimeFilter<"Users"> | Date | string
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    aboutMe?: StringFilter<"Users"> | string
    avatar?: StringFilter<"Users"> | string
    background?: StringFilter<"Users"> | string
    ConferenceBlacklists?: ConferenceBlacklistsListRelationFilter
    ConferenceCalendars?: ConferenceCalendarsListRelationFilter
    ConferenceFeedbacks?: ConferenceFeedbacksListRelationFilter
    ConferenceFollows?: ConferenceFollowsListRelationFilter
    ConferenceLikes?: ConferenceLikesListRelationFilter
    Conferences?: ConferencesListRelationFilter
    JournalFollows?: JournalFollowsListRelationFilter
    JournalLikes?: JournalLikesListRelationFilter
    Journals?: JournalsListRelationFilter
    NotificationSettings?: NotificationSettingsListRelationFilter
    Notifications?: NotificationsListRelationFilter
    TopicUserInteresteds?: TopicUserInterestedsListRelationFilter
    UserVerification?: UserVerificationListRelationFilter
  }, "id" | "email">

  export type UsersOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aboutMe?: SortOrder
    avatar?: SortOrder
    background?: SortOrder
    _count?: UsersCountOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Users"> | string
    email?: StringWithAggregatesFilter<"Users"> | string
    password?: StringWithAggregatesFilter<"Users"> | string
    firstName?: StringWithAggregatesFilter<"Users"> | string
    lastName?: StringWithAggregatesFilter<"Users"> | string
    dob?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    aboutMe?: StringWithAggregatesFilter<"Users"> | string
    avatar?: StringWithAggregatesFilter<"Users"> | string
    background?: StringWithAggregatesFilter<"Users"> | string
  }

  export type AdminsCreateInput = {
    id: string
    email: string
    password: string
    fullName: string
    createdAt?: Date | string
    updatedAt: Date | string
    Conferences?: ConferencesCreateNestedManyWithoutAdminsInput
  }

  export type AdminsUncheckedCreateInput = {
    id: string
    email: string
    password: string
    fullName: string
    createdAt?: Date | string
    updatedAt: Date | string
    Conferences?: ConferencesUncheckedCreateNestedManyWithoutAdminsInput
  }

  export type AdminsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Conferences?: ConferencesUpdateManyWithoutAdminsNestedInput
  }

  export type AdminsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Conferences?: ConferencesUncheckedUpdateManyWithoutAdminsNestedInput
  }

  export type AdminsCreateManyInput = {
    id: string
    email: string
    password: string
    fullName: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type AdminsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceBlacklistsCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    Conferences: ConferencesCreateNestedOneWithoutConferenceBlacklistsInput
    Users: UsersCreateNestedOneWithoutConferenceBlacklistsInput
  }

  export type ConferenceBlacklistsUncheckedCreateInput = {
    id: string
    conferenceId: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceBlacklistsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Conferences?: ConferencesUpdateOneRequiredWithoutConferenceBlacklistsNestedInput
    Users?: UsersUpdateOneRequiredWithoutConferenceBlacklistsNestedInput
  }

  export type ConferenceBlacklistsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceBlacklistsCreateManyInput = {
    id: string
    conferenceId: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceBlacklistsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceBlacklistsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCalendarsCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    Conferences: ConferencesCreateNestedOneWithoutConferenceCalendarsInput
    Users: UsersCreateNestedOneWithoutConferenceCalendarsInput
  }

  export type ConferenceCalendarsUncheckedCreateInput = {
    id: string
    conferenceId: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceCalendarsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Conferences?: ConferencesUpdateOneRequiredWithoutConferenceCalendarsNestedInput
    Users?: UsersUpdateOneRequiredWithoutConferenceCalendarsNestedInput
  }

  export type ConferenceCalendarsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCalendarsCreateManyInput = {
    id: string
    conferenceId: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceCalendarsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCalendarsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCrawlJobsCreateInput = {
    id: string
    status: string
    progress: number
    message: string
    createdAt?: Date | string
    updatedAt: Date | string
    Conferences: ConferencesCreateNestedOneWithoutConferenceCrawlJobsInput
  }

  export type ConferenceCrawlJobsUncheckedCreateInput = {
    id: string
    conferenceId: string
    status: string
    progress: number
    message: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceCrawlJobsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Conferences?: ConferencesUpdateOneRequiredWithoutConferenceCrawlJobsNestedInput
  }

  export type ConferenceCrawlJobsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCrawlJobsCreateManyInput = {
    id: string
    conferenceId: string
    status: string
    progress: number
    message: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceCrawlJobsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCrawlJobsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceDatesCreateInput = {
    id: string
    fromDate: Date | string
    toDate: Date | string
    type: string
    name: string
    createdAt?: Date | string
    updatedAt: Date | string
    isAvailable: boolean
    ConferenceOrganizations: ConferenceOrganizationsCreateNestedOneWithoutConferenceDatesInput
  }

  export type ConferenceDatesUncheckedCreateInput = {
    id: string
    organizedId: string
    fromDate: Date | string
    toDate: Date | string
    type: string
    name: string
    createdAt?: Date | string
    updatedAt: Date | string
    isAvailable: boolean
  }

  export type ConferenceDatesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    ConferenceOrganizations?: ConferenceOrganizationsUpdateOneRequiredWithoutConferenceDatesNestedInput
  }

  export type ConferenceDatesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizedId?: StringFieldUpdateOperationsInput | string
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConferenceDatesCreateManyInput = {
    id: string
    organizedId: string
    fromDate: Date | string
    toDate: Date | string
    type: string
    name: string
    createdAt?: Date | string
    updatedAt: Date | string
    isAvailable: boolean
  }

  export type ConferenceDatesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConferenceDatesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizedId?: StringFieldUpdateOperationsInput | string
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConferenceFeedbacksCreateInput = {
    id: string
    description: string
    star: number
    createdAt?: Date | string
    updatedAt: Date | string
    Conferences: ConferencesCreateNestedOneWithoutConferenceFeedbacksInput
    Users: UsersCreateNestedOneWithoutConferenceFeedbacksInput
  }

  export type ConferenceFeedbacksUncheckedCreateInput = {
    id: string
    conferenceId: string
    creatorId: string
    description: string
    star: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceFeedbacksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    star?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Conferences?: ConferencesUpdateOneRequiredWithoutConferenceFeedbacksNestedInput
    Users?: UsersUpdateOneRequiredWithoutConferenceFeedbacksNestedInput
  }

  export type ConferenceFeedbacksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    star?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFeedbacksCreateManyInput = {
    id: string
    conferenceId: string
    creatorId: string
    description: string
    star: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceFeedbacksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    star?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFeedbacksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    star?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFollowsCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    Conferences: ConferencesCreateNestedOneWithoutConferenceFollowsInput
    Users: UsersCreateNestedOneWithoutConferenceFollowsInput
  }

  export type ConferenceFollowsUncheckedCreateInput = {
    id: string
    conferenceId: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceFollowsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Conferences?: ConferencesUpdateOneRequiredWithoutConferenceFollowsNestedInput
    Users?: UsersUpdateOneRequiredWithoutConferenceFollowsNestedInput
  }

  export type ConferenceFollowsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFollowsCreateManyInput = {
    id: string
    conferenceId: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceFollowsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFollowsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceLikesCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    Conferences: ConferencesCreateNestedOneWithoutConferenceLikesInput
    Users: UsersCreateNestedOneWithoutConferenceLikesInput
  }

  export type ConferenceLikesUncheckedCreateInput = {
    id: string
    conferenceId: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceLikesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Conferences?: ConferencesUpdateOneRequiredWithoutConferenceLikesNestedInput
    Users?: UsersUpdateOneRequiredWithoutConferenceLikesNestedInput
  }

  export type ConferenceLikesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceLikesCreateManyInput = {
    id: string
    conferenceId: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceLikesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceLikesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceOrganizationsCreateInput = {
    id: string
    year?: number | null
    accessType: string
    isAvailable: boolean
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt?: Date | string
    updatedAt: Date | string
    ConferenceDates?: ConferenceDatesCreateNestedManyWithoutConferenceOrganizationsInput
    Conferences: ConferencesCreateNestedOneWithoutConferenceOrganizationsInput
    ConferenceTopics?: ConferenceTopicsCreateNestedManyWithoutConferenceOrganizationsInput
    Locations?: LocationsCreateNestedManyWithoutConferenceOrganizationsInput
  }

  export type ConferenceOrganizationsUncheckedCreateInput = {
    id: string
    year?: number | null
    accessType: string
    isAvailable: boolean
    conferenceId: string
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt?: Date | string
    updatedAt: Date | string
    ConferenceDates?: ConferenceDatesUncheckedCreateNestedManyWithoutConferenceOrganizationsInput
    ConferenceTopics?: ConferenceTopicsUncheckedCreateNestedManyWithoutConferenceOrganizationsInput
    Locations?: LocationsUncheckedCreateNestedManyWithoutConferenceOrganizationsInput
  }

  export type ConferenceOrganizationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ConferenceDates?: ConferenceDatesUpdateManyWithoutConferenceOrganizationsNestedInput
    Conferences?: ConferencesUpdateOneRequiredWithoutConferenceOrganizationsNestedInput
    ConferenceTopics?: ConferenceTopicsUpdateManyWithoutConferenceOrganizationsNestedInput
    Locations?: LocationsUpdateManyWithoutConferenceOrganizationsNestedInput
  }

  export type ConferenceOrganizationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    conferenceId?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ConferenceDates?: ConferenceDatesUncheckedUpdateManyWithoutConferenceOrganizationsNestedInput
    ConferenceTopics?: ConferenceTopicsUncheckedUpdateManyWithoutConferenceOrganizationsNestedInput
    Locations?: LocationsUncheckedUpdateManyWithoutConferenceOrganizationsNestedInput
  }

  export type ConferenceOrganizationsCreateManyInput = {
    id: string
    year?: number | null
    accessType: string
    isAvailable: boolean
    conferenceId: string
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceOrganizationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceOrganizationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    conferenceId?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceRanksCreateInput = {
    id: string
    year: number
    Conferences: ConferencesCreateNestedOneWithoutConferenceRanksInput
    FieldOfResearchs: FieldOfResearchsCreateNestedOneWithoutConferenceRanksInput
    Ranks: RanksCreateNestedOneWithoutConferenceRanksInput
  }

  export type ConferenceRanksUncheckedCreateInput = {
    id: string
    year: number
    conferenceId: string
    fieldOfResearchId: string
    rankId: string
  }

  export type ConferenceRanksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    Conferences?: ConferencesUpdateOneRequiredWithoutConferenceRanksNestedInput
    FieldOfResearchs?: FieldOfResearchsUpdateOneRequiredWithoutConferenceRanksNestedInput
    Ranks?: RanksUpdateOneRequiredWithoutConferenceRanksNestedInput
  }

  export type ConferenceRanksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    conferenceId?: StringFieldUpdateOperationsInput | string
    fieldOfResearchId?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
  }

  export type ConferenceRanksCreateManyInput = {
    id: string
    year: number
    conferenceId: string
    fieldOfResearchId: string
    rankId: string
  }

  export type ConferenceRanksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
  }

  export type ConferenceRanksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    conferenceId?: StringFieldUpdateOperationsInput | string
    fieldOfResearchId?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
  }

  export type ConferenceTopicsCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    ConferenceOrganizations: ConferenceOrganizationsCreateNestedOneWithoutConferenceTopicsInput
    Topics: TopicsCreateNestedOneWithoutConferenceTopicsInput
  }

  export type ConferenceTopicsUncheckedCreateInput = {
    id: string
    organizeId: string
    topicId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceTopicsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ConferenceOrganizations?: ConferenceOrganizationsUpdateOneRequiredWithoutConferenceTopicsNestedInput
    Topics?: TopicsUpdateOneRequiredWithoutConferenceTopicsNestedInput
  }

  export type ConferenceTopicsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizeId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceTopicsCreateManyInput = {
    id: string
    organizeId: string
    topicId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceTopicsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceTopicsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizeId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferencesCreateInput = {
    id: string
    title: string
    acronym: string
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
    ConferenceBlacklists?: ConferenceBlacklistsCreateNestedManyWithoutConferencesInput
    ConferenceCalendars?: ConferenceCalendarsCreateNestedManyWithoutConferencesInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsCreateNestedManyWithoutConferencesInput
    ConferenceFeedbacks?: ConferenceFeedbacksCreateNestedManyWithoutConferencesInput
    ConferenceFollows?: ConferenceFollowsCreateNestedManyWithoutConferencesInput
    ConferenceLikes?: ConferenceLikesCreateNestedManyWithoutConferencesInput
    ConferenceOrganizations?: ConferenceOrganizationsCreateNestedManyWithoutConferencesInput
    ConferenceRanks?: ConferenceRanksCreateNestedManyWithoutConferencesInput
    Admins?: AdminsCreateNestedOneWithoutConferencesInput
    Users?: UsersCreateNestedOneWithoutConferencesInput
  }

  export type ConferencesUncheckedCreateInput = {
    id: string
    title: string
    acronym: string
    creatorId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
    adminId?: string | null
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceFollows?: ConferenceFollowsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceLikes?: ConferenceLikesUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceOrganizations?: ConferenceOrganizationsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceRanks?: ConferenceRanksUncheckedCreateNestedManyWithoutConferencesInput
  }

  export type ConferencesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUpdateManyWithoutConferencesNestedInput
    ConferenceCalendars?: ConferenceCalendarsUpdateManyWithoutConferencesNestedInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUpdateManyWithoutConferencesNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUpdateManyWithoutConferencesNestedInput
    ConferenceFollows?: ConferenceFollowsUpdateManyWithoutConferencesNestedInput
    ConferenceLikes?: ConferenceLikesUpdateManyWithoutConferencesNestedInput
    ConferenceOrganizations?: ConferenceOrganizationsUpdateManyWithoutConferencesNestedInput
    ConferenceRanks?: ConferenceRanksUpdateManyWithoutConferencesNestedInput
    Admins?: AdminsUpdateOneWithoutConferencesNestedInput
    Users?: UsersUpdateOneWithoutConferencesNestedInput
  }

  export type ConferencesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceFollows?: ConferenceFollowsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceLikes?: ConferenceLikesUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceOrganizations?: ConferenceOrganizationsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceRanks?: ConferenceRanksUncheckedUpdateManyWithoutConferencesNestedInput
  }

  export type ConferencesCreateManyInput = {
    id: string
    title: string
    acronym: string
    creatorId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
    adminId?: string | null
  }

  export type ConferencesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ConferencesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FieldOfResearchsCreateInput = {
    id: string
    name: string
    code: string
    ConferenceRanks?: ConferenceRanksCreateNestedManyWithoutFieldOfResearchsInput
    JournalRanks?: JournalRanksCreateNestedManyWithoutFieldOfResearchsInput
  }

  export type FieldOfResearchsUncheckedCreateInput = {
    id: string
    name: string
    code: string
    ConferenceRanks?: ConferenceRanksUncheckedCreateNestedManyWithoutFieldOfResearchsInput
    JournalRanks?: JournalRanksUncheckedCreateNestedManyWithoutFieldOfResearchsInput
  }

  export type FieldOfResearchsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    ConferenceRanks?: ConferenceRanksUpdateManyWithoutFieldOfResearchsNestedInput
    JournalRanks?: JournalRanksUpdateManyWithoutFieldOfResearchsNestedInput
  }

  export type FieldOfResearchsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    ConferenceRanks?: ConferenceRanksUncheckedUpdateManyWithoutFieldOfResearchsNestedInput
    JournalRanks?: JournalRanksUncheckedUpdateManyWithoutFieldOfResearchsNestedInput
  }

  export type FieldOfResearchsCreateManyInput = {
    id: string
    name: string
    code: string
  }

  export type FieldOfResearchsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type FieldOfResearchsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type JournalCrawlJobsCreateInput = {
    id: string
    status: string
    progress: number
    message: string
    createdAt?: Date | string
    updatedAt: Date | string
    Journals: JournalsCreateNestedOneWithoutJournalCrawlJobsInput
  }

  export type JournalCrawlJobsUncheckedCreateInput = {
    id: string
    journalId: string
    status: string
    progress: number
    message: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type JournalCrawlJobsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Journals?: JournalsUpdateOneRequiredWithoutJournalCrawlJobsNestedInput
  }

  export type JournalCrawlJobsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalCrawlJobsCreateManyInput = {
    id: string
    journalId: string
    status: string
    progress: number
    message: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type JournalCrawlJobsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalCrawlJobsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalFollowsCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    Journals: JournalsCreateNestedOneWithoutJournalFollowsInput
    Users: UsersCreateNestedOneWithoutJournalFollowsInput
  }

  export type JournalFollowsUncheckedCreateInput = {
    id: string
    journalId: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type JournalFollowsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Journals?: JournalsUpdateOneRequiredWithoutJournalFollowsNestedInput
    Users?: UsersUpdateOneRequiredWithoutJournalFollowsNestedInput
  }

  export type JournalFollowsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalFollowsCreateManyInput = {
    id: string
    journalId: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type JournalFollowsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalFollowsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLikesCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    Journals: JournalsCreateNestedOneWithoutJournalLikesInput
    Users: UsersCreateNestedOneWithoutJournalLikesInput
  }

  export type JournalLikesUncheckedCreateInput = {
    id: string
    journalId: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type JournalLikesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Journals?: JournalsUpdateOneRequiredWithoutJournalLikesNestedInput
    Users?: UsersUpdateOneRequiredWithoutJournalLikesNestedInput
  }

  export type JournalLikesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLikesCreateManyInput = {
    id: string
    journalId: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type JournalLikesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLikesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalRanksCreateInput = {
    id: string
    year: number
    FieldOfResearchs: FieldOfResearchsCreateNestedOneWithoutJournalRanksInput
    Journals: JournalsCreateNestedOneWithoutJournalRanksInput
    Ranks: RanksCreateNestedOneWithoutJournalRanksInput
  }

  export type JournalRanksUncheckedCreateInput = {
    id: string
    year: number
    journalId: string
    fieldOfResearchId: string
    rankId: string
  }

  export type JournalRanksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    FieldOfResearchs?: FieldOfResearchsUpdateOneRequiredWithoutJournalRanksNestedInput
    Journals?: JournalsUpdateOneRequiredWithoutJournalRanksNestedInput
    Ranks?: RanksUpdateOneRequiredWithoutJournalRanksNestedInput
  }

  export type JournalRanksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    journalId?: StringFieldUpdateOperationsInput | string
    fieldOfResearchId?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalRanksCreateManyInput = {
    id: string
    year: number
    journalId: string
    fieldOfResearchId: string
    rankId: string
  }

  export type JournalRanksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
  }

  export type JournalRanksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    journalId?: StringFieldUpdateOperationsInput | string
    fieldOfResearchId?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalTopicsCreateInput = {
    id: string
    Journals: JournalsCreateNestedOneWithoutJournalTopicsInput
    Topics: TopicsCreateNestedOneWithoutJournalTopicsInput
  }

  export type JournalTopicsUncheckedCreateInput = {
    id: string
    journalId: string
    topicId: string
  }

  export type JournalTopicsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Journals?: JournalsUpdateOneRequiredWithoutJournalTopicsNestedInput
    Topics?: TopicsUpdateOneRequiredWithoutJournalTopicsNestedInput
  }

  export type JournalTopicsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalTopicsCreateManyInput = {
    id: string
    journalId: string
    topicId: string
  }

  export type JournalTopicsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type JournalTopicsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalsCreateInput = {
    id: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    JournalCrawlJobs?: JournalCrawlJobsCreateNestedManyWithoutJournalsInput
    JournalFollows?: JournalFollowsCreateNestedManyWithoutJournalsInput
    JournalLikes?: JournalLikesCreateNestedManyWithoutJournalsInput
    JournalRanks?: JournalRanksCreateNestedManyWithoutJournalsInput
    JournalTopics?: JournalTopicsCreateNestedManyWithoutJournalsInput
    Users: UsersCreateNestedOneWithoutJournalsInput
  }

  export type JournalsUncheckedCreateInput = {
    id: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    creator: string
    JournalCrawlJobs?: JournalCrawlJobsUncheckedCreateNestedManyWithoutJournalsInput
    JournalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutJournalsInput
    JournalLikes?: JournalLikesUncheckedCreateNestedManyWithoutJournalsInput
    JournalRanks?: JournalRanksUncheckedCreateNestedManyWithoutJournalsInput
    JournalTopics?: JournalTopicsUncheckedCreateNestedManyWithoutJournalsInput
  }

  export type JournalsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    JournalCrawlJobs?: JournalCrawlJobsUpdateManyWithoutJournalsNestedInput
    JournalFollows?: JournalFollowsUpdateManyWithoutJournalsNestedInput
    JournalLikes?: JournalLikesUpdateManyWithoutJournalsNestedInput
    JournalRanks?: JournalRanksUpdateManyWithoutJournalsNestedInput
    JournalTopics?: JournalTopicsUpdateManyWithoutJournalsNestedInput
    Users?: UsersUpdateOneRequiredWithoutJournalsNestedInput
  }

  export type JournalsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    JournalCrawlJobs?: JournalCrawlJobsUncheckedUpdateManyWithoutJournalsNestedInput
    JournalFollows?: JournalFollowsUncheckedUpdateManyWithoutJournalsNestedInput
    JournalLikes?: JournalLikesUncheckedUpdateManyWithoutJournalsNestedInput
    JournalRanks?: JournalRanksUncheckedUpdateManyWithoutJournalsNestedInput
    JournalTopics?: JournalTopicsUncheckedUpdateManyWithoutJournalsNestedInput
  }

  export type JournalsCreateManyInput = {
    id: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    creator: string
  }

  export type JournalsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
  }

  export type JournalsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
  }

  export type LocationsCreateInput = {
    id: string
    address?: string | null
    cityStateProvince?: string | null
    country?: string | null
    continent?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    isAvailable: boolean
    ConferenceOrganizations: ConferenceOrganizationsCreateNestedOneWithoutLocationsInput
  }

  export type LocationsUncheckedCreateInput = {
    id: string
    address?: string | null
    cityStateProvince?: string | null
    country?: string | null
    continent?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    isAvailable: boolean
    organizeId: string
  }

  export type LocationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityStateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    ConferenceOrganizations?: ConferenceOrganizationsUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type LocationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityStateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    organizeId?: StringFieldUpdateOperationsInput | string
  }

  export type LocationsCreateManyInput = {
    id: string
    address?: string | null
    cityStateProvince?: string | null
    country?: string | null
    continent?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    isAvailable: boolean
    organizeId: string
  }

  export type LocationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityStateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LocationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityStateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    organizeId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationSettingsCreateInput = {
    id: string
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    NotificationsTypes: NotificationsTypesCreateNestedOneWithoutNotificationSettingsInput
    Users: UsersCreateNestedOneWithoutNotificationSettingsInput
  }

  export type NotificationSettingsUncheckedCreateInput = {
    id: string
    userId: string
    notificationId: string
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NotificationSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NotificationsTypes?: NotificationsTypesUpdateOneRequiredWithoutNotificationSettingsNestedInput
    Users?: UsersUpdateOneRequiredWithoutNotificationSettingsNestedInput
  }

  export type NotificationSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsCreateManyInput = {
    id: string
    userId: string
    notificationId: string
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NotificationSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsCreateInput = {
    id: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    NotificationsTypes: NotificationsTypesCreateNestedOneWithoutNotificationsInput
    Users: UsersCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationsUncheckedCreateInput = {
    id: string
    notificationId: string
    userId: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NotificationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NotificationsTypes?: NotificationsTypesUpdateOneRequiredWithoutNotificationsNestedInput
    Users?: UsersUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsCreateManyInput = {
    id: string
    notificationId: string
    userId: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NotificationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsTypesCreateInput = {
    id: string
    name: string
    createdAt?: Date | string
    updatedAt: Date | string
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutNotificationsTypesInput
    Notifications?: NotificationsCreateNestedManyWithoutNotificationsTypesInput
  }

  export type NotificationsTypesUncheckedCreateInput = {
    id: string
    name: string
    createdAt?: Date | string
    updatedAt: Date | string
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutNotificationsTypesInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutNotificationsTypesInput
  }

  export type NotificationsTypesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NotificationSettings?: NotificationSettingsUpdateManyWithoutNotificationsTypesNestedInput
    Notifications?: NotificationsUpdateManyWithoutNotificationsTypesNestedInput
  }

  export type NotificationsTypesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutNotificationsTypesNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutNotificationsTypesNestedInput
  }

  export type NotificationsTypesCreateManyInput = {
    id: string
    name: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NotificationsTypesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsTypesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassengerCreateInput = {
    id: string
    firstName: string
    lastName: string
  }

  export type PassengerUncheckedCreateInput = {
    id: string
    firstName: string
    lastName: string
  }

  export type PassengerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
  }

  export type PassengerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
  }

  export type PassengerCreateManyInput = {
    id: string
    firstName: string
    lastName: string
  }

  export type PassengerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
  }

  export type PassengerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
  }

  export type RanksCreateInput = {
    id: string
    name: string
    value: number
    ConferenceRanks?: ConferenceRanksCreateNestedManyWithoutRanksInput
    JournalRanks?: JournalRanksCreateNestedManyWithoutRanksInput
    Sources: SourcesCreateNestedOneWithoutRanksInput
  }

  export type RanksUncheckedCreateInput = {
    id: string
    name: string
    value: number
    sourceId: string
    ConferenceRanks?: ConferenceRanksUncheckedCreateNestedManyWithoutRanksInput
    JournalRanks?: JournalRanksUncheckedCreateNestedManyWithoutRanksInput
  }

  export type RanksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    ConferenceRanks?: ConferenceRanksUpdateManyWithoutRanksNestedInput
    JournalRanks?: JournalRanksUpdateManyWithoutRanksNestedInput
    Sources?: SourcesUpdateOneRequiredWithoutRanksNestedInput
  }

  export type RanksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    sourceId?: StringFieldUpdateOperationsInput | string
    ConferenceRanks?: ConferenceRanksUncheckedUpdateManyWithoutRanksNestedInput
    JournalRanks?: JournalRanksUncheckedUpdateManyWithoutRanksNestedInput
  }

  export type RanksCreateManyInput = {
    id: string
    name: string
    value: number
    sourceId: string
  }

  export type RanksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type RanksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    sourceId?: StringFieldUpdateOperationsInput | string
  }

  export type SourcesCreateInput = {
    id: string
    name: string
    link?: string | null
    Ranks?: RanksCreateNestedManyWithoutSourcesInput
  }

  export type SourcesUncheckedCreateInput = {
    id: string
    name: string
    link?: string | null
    Ranks?: RanksUncheckedCreateNestedManyWithoutSourcesInput
  }

  export type SourcesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    Ranks?: RanksUpdateManyWithoutSourcesNestedInput
  }

  export type SourcesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    Ranks?: RanksUncheckedUpdateManyWithoutSourcesNestedInput
  }

  export type SourcesCreateManyInput = {
    id: string
    name: string
    link?: string | null
  }

  export type SourcesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SourcesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TopicUserInterestedsCreateInput = {
    createdAt?: Date | string
    updatedAt: Date | string
    Topics: TopicsCreateNestedOneWithoutTopicUserInterestedsInput
    Users: UsersCreateNestedOneWithoutTopicUserInterestedsInput
  }

  export type TopicUserInterestedsUncheckedCreateInput = {
    userId: string
    topicId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TopicUserInterestedsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Topics?: TopicsUpdateOneRequiredWithoutTopicUserInterestedsNestedInput
    Users?: UsersUpdateOneRequiredWithoutTopicUserInterestedsNestedInput
  }

  export type TopicUserInterestedsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicUserInterestedsCreateManyInput = {
    userId: string
    topicId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TopicUserInterestedsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicUserInterestedsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicsCreateInput = {
    id: string
    name: string
    createdAt?: Date | string
    updatedAt: Date | string
    ConferenceTopics?: ConferenceTopicsCreateNestedManyWithoutTopicsInput
    JournalTopics?: JournalTopicsCreateNestedManyWithoutTopicsInput
    TopicUserInteresteds?: TopicUserInterestedsCreateNestedManyWithoutTopicsInput
  }

  export type TopicsUncheckedCreateInput = {
    id: string
    name: string
    createdAt?: Date | string
    updatedAt: Date | string
    ConferenceTopics?: ConferenceTopicsUncheckedCreateNestedManyWithoutTopicsInput
    JournalTopics?: JournalTopicsUncheckedCreateNestedManyWithoutTopicsInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedCreateNestedManyWithoutTopicsInput
  }

  export type TopicsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ConferenceTopics?: ConferenceTopicsUpdateManyWithoutTopicsNestedInput
    JournalTopics?: JournalTopicsUpdateManyWithoutTopicsNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUpdateManyWithoutTopicsNestedInput
  }

  export type TopicsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ConferenceTopics?: ConferenceTopicsUncheckedUpdateManyWithoutTopicsNestedInput
    JournalTopics?: JournalTopicsUncheckedUpdateManyWithoutTopicsNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedUpdateManyWithoutTopicsNestedInput
  }

  export type TopicsCreateManyInput = {
    id: string
    name: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TopicsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserVerificationCreateInput = {
    id: string
    verificationCode: string
    verificationCodeExpires: Date | string
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    Users: UsersCreateNestedOneWithoutUserVerificationInput
  }

  export type UserVerificationUncheckedCreateInput = {
    id: string
    userId: string
    verificationCode: string
    verificationCodeExpires: Date | string
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type UserVerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    verificationCode?: StringFieldUpdateOperationsInput | string
    verificationCodeExpires?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUpdateOneRequiredWithoutUserVerificationNestedInput
  }

  export type UserVerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    verificationCode?: StringFieldUpdateOperationsInput | string
    verificationCodeExpires?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserVerificationCreateManyInput = {
    id: string
    userId: string
    verificationCode: string
    verificationCodeExpires: Date | string
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type UserVerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    verificationCode?: StringFieldUpdateOperationsInput | string
    verificationCodeExpires?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserVerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    verificationCode?: StringFieldUpdateOperationsInput | string
    verificationCodeExpires?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersCreateInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsCreateNestedManyWithoutUsersInput
    ConferenceCalendars?: ConferenceCalendarsCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesCreateNestedManyWithoutUsersInput
    Journals?: JournalsCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesUncheckedCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesUncheckedCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesUncheckedCreateNestedManyWithoutUsersInput
    Journals?: JournalsUncheckedCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUpdateManyWithoutUsersNestedInput
    ConferenceCalendars?: ConferenceCalendarsUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUncheckedUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUncheckedUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUncheckedUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUncheckedUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUncheckedUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersCreateManyInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
  }

  export type UsersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
  }

  export type UsersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ConferencesListRelationFilter = {
    every?: ConferencesWhereInput
    some?: ConferencesWhereInput
    none?: ConferencesWhereInput
  }

  export type ConferencesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminsCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminsMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminsMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ConferencesScalarRelationFilter = {
    is?: ConferencesWhereInput
    isNot?: ConferencesWhereInput
  }

  export type UsersScalarRelationFilter = {
    is?: UsersWhereInput
    isNot?: UsersWhereInput
  }

  export type ConferenceBlacklistsCountOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceBlacklistsMaxOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceBlacklistsMinOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceCalendarsConferenceIdUserIdCompoundUniqueInput = {
    conferenceId: string
    userId: string
  }

  export type ConferenceCalendarsCountOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceCalendarsMaxOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceCalendarsMinOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ConferenceCrawlJobsCountOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceCrawlJobsAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type ConferenceCrawlJobsMaxOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceCrawlJobsMinOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceCrawlJobsSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ConferenceOrganizationsScalarRelationFilter = {
    is?: ConferenceOrganizationsWhereInput
    isNot?: ConferenceOrganizationsWhereInput
  }

  export type ConferenceDatesCountOrderByAggregateInput = {
    id?: SortOrder
    organizedId?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    type?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAvailable?: SortOrder
  }

  export type ConferenceDatesMaxOrderByAggregateInput = {
    id?: SortOrder
    organizedId?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    type?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAvailable?: SortOrder
  }

  export type ConferenceDatesMinOrderByAggregateInput = {
    id?: SortOrder
    organizedId?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    type?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAvailable?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ConferenceFeedbacksCountOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    creatorId?: SortOrder
    description?: SortOrder
    star?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceFeedbacksAvgOrderByAggregateInput = {
    star?: SortOrder
  }

  export type ConferenceFeedbacksMaxOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    creatorId?: SortOrder
    description?: SortOrder
    star?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceFeedbacksMinOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    creatorId?: SortOrder
    description?: SortOrder
    star?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceFeedbacksSumOrderByAggregateInput = {
    star?: SortOrder
  }

  export type ConferenceFollowsConferenceIdUserIdCompoundUniqueInput = {
    conferenceId: string
    userId: string
  }

  export type ConferenceFollowsCountOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceFollowsMaxOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceFollowsMinOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceLikesConferenceIdUserIdCompoundUniqueInput = {
    conferenceId: string
    userId: string
  }

  export type ConferenceLikesCountOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceLikesMaxOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceLikesMinOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ConferenceDatesListRelationFilter = {
    every?: ConferenceDatesWhereInput
    some?: ConferenceDatesWhereInput
    none?: ConferenceDatesWhereInput
  }

  export type ConferenceTopicsListRelationFilter = {
    every?: ConferenceTopicsWhereInput
    some?: ConferenceTopicsWhereInput
    none?: ConferenceTopicsWhereInput
  }

  export type LocationsListRelationFilter = {
    every?: LocationsWhereInput
    some?: LocationsWhereInput
    none?: LocationsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ConferenceDatesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConferenceTopicsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConferenceOrganizationsCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    accessType?: SortOrder
    isAvailable?: SortOrder
    conferenceId?: SortOrder
    publisher?: SortOrder
    summerize?: SortOrder
    callForPaper?: SortOrder
    link?: SortOrder
    cfpLink?: SortOrder
    impLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceOrganizationsAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type ConferenceOrganizationsMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    accessType?: SortOrder
    isAvailable?: SortOrder
    conferenceId?: SortOrder
    publisher?: SortOrder
    summerize?: SortOrder
    callForPaper?: SortOrder
    link?: SortOrder
    cfpLink?: SortOrder
    impLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceOrganizationsMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    accessType?: SortOrder
    isAvailable?: SortOrder
    conferenceId?: SortOrder
    publisher?: SortOrder
    summerize?: SortOrder
    callForPaper?: SortOrder
    link?: SortOrder
    cfpLink?: SortOrder
    impLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceOrganizationsSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FieldOfResearchsScalarRelationFilter = {
    is?: FieldOfResearchsWhereInput
    isNot?: FieldOfResearchsWhereInput
  }

  export type RanksScalarRelationFilter = {
    is?: RanksWhereInput
    isNot?: RanksWhereInput
  }

  export type ConferenceRanksCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    conferenceId?: SortOrder
    fieldOfResearchId?: SortOrder
    rankId?: SortOrder
  }

  export type ConferenceRanksAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type ConferenceRanksMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    conferenceId?: SortOrder
    fieldOfResearchId?: SortOrder
    rankId?: SortOrder
  }

  export type ConferenceRanksMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    conferenceId?: SortOrder
    fieldOfResearchId?: SortOrder
    rankId?: SortOrder
  }

  export type ConferenceRanksSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type TopicsScalarRelationFilter = {
    is?: TopicsWhereInput
    isNot?: TopicsWhereInput
  }

  export type ConferenceTopicsCountOrderByAggregateInput = {
    id?: SortOrder
    organizeId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceTopicsMaxOrderByAggregateInput = {
    id?: SortOrder
    organizeId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceTopicsMinOrderByAggregateInput = {
    id?: SortOrder
    organizeId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ConferenceBlacklistsListRelationFilter = {
    every?: ConferenceBlacklistsWhereInput
    some?: ConferenceBlacklistsWhereInput
    none?: ConferenceBlacklistsWhereInput
  }

  export type ConferenceCalendarsListRelationFilter = {
    every?: ConferenceCalendarsWhereInput
    some?: ConferenceCalendarsWhereInput
    none?: ConferenceCalendarsWhereInput
  }

  export type ConferenceCrawlJobsListRelationFilter = {
    every?: ConferenceCrawlJobsWhereInput
    some?: ConferenceCrawlJobsWhereInput
    none?: ConferenceCrawlJobsWhereInput
  }

  export type ConferenceFeedbacksListRelationFilter = {
    every?: ConferenceFeedbacksWhereInput
    some?: ConferenceFeedbacksWhereInput
    none?: ConferenceFeedbacksWhereInput
  }

  export type ConferenceFollowsListRelationFilter = {
    every?: ConferenceFollowsWhereInput
    some?: ConferenceFollowsWhereInput
    none?: ConferenceFollowsWhereInput
  }

  export type ConferenceLikesListRelationFilter = {
    every?: ConferenceLikesWhereInput
    some?: ConferenceLikesWhereInput
    none?: ConferenceLikesWhereInput
  }

  export type ConferenceOrganizationsListRelationFilter = {
    every?: ConferenceOrganizationsWhereInput
    some?: ConferenceOrganizationsWhereInput
    none?: ConferenceOrganizationsWhereInput
  }

  export type ConferenceRanksListRelationFilter = {
    every?: ConferenceRanksWhereInput
    some?: ConferenceRanksWhereInput
    none?: ConferenceRanksWhereInput
  }

  export type AdminsNullableScalarRelationFilter = {
    is?: AdminsWhereInput | null
    isNot?: AdminsWhereInput | null
  }

  export type UsersNullableScalarRelationFilter = {
    is?: UsersWhereInput | null
    isNot?: UsersWhereInput | null
  }

  export type ConferenceBlacklistsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConferenceCalendarsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConferenceCrawlJobsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConferenceFeedbacksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConferenceFollowsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConferenceLikesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConferenceOrganizationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConferenceRanksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConferencesTitleAcronymCompoundUniqueInput = {
    title: string
    acronym: string
  }

  export type ConferencesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    acronym?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    adminId?: SortOrder
  }

  export type ConferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    acronym?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    adminId?: SortOrder
  }

  export type ConferencesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    acronym?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    adminId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type JournalRanksListRelationFilter = {
    every?: JournalRanksWhereInput
    some?: JournalRanksWhereInput
    none?: JournalRanksWhereInput
  }

  export type JournalRanksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FieldOfResearchsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type FieldOfResearchsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type FieldOfResearchsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type JournalsScalarRelationFilter = {
    is?: JournalsWhereInput
    isNot?: JournalsWhereInput
  }

  export type JournalCrawlJobsCountOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalCrawlJobsAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type JournalCrawlJobsMaxOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalCrawlJobsMinOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalCrawlJobsSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type JournalFollowsCountOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalFollowsMaxOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalFollowsMinOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalLikesCountOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalLikesMaxOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalLikesMinOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalRanksCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    journalId?: SortOrder
    fieldOfResearchId?: SortOrder
    rankId?: SortOrder
  }

  export type JournalRanksAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type JournalRanksMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    journalId?: SortOrder
    fieldOfResearchId?: SortOrder
    rankId?: SortOrder
  }

  export type JournalRanksMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    journalId?: SortOrder
    fieldOfResearchId?: SortOrder
    rankId?: SortOrder
  }

  export type JournalRanksSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type JournalTopicsCountOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    topicId?: SortOrder
  }

  export type JournalTopicsMaxOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    topicId?: SortOrder
  }

  export type JournalTopicsMinOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    topicId?: SortOrder
  }

  export type JournalCrawlJobsListRelationFilter = {
    every?: JournalCrawlJobsWhereInput
    some?: JournalCrawlJobsWhereInput
    none?: JournalCrawlJobsWhereInput
  }

  export type JournalFollowsListRelationFilter = {
    every?: JournalFollowsWhereInput
    some?: JournalFollowsWhereInput
    none?: JournalFollowsWhereInput
  }

  export type JournalLikesListRelationFilter = {
    every?: JournalLikesWhereInput
    some?: JournalLikesWhereInput
    none?: JournalLikesWhereInput
  }

  export type JournalTopicsListRelationFilter = {
    every?: JournalTopicsWhereInput
    some?: JournalTopicsWhereInput
    none?: JournalTopicsWhereInput
  }

  export type JournalCrawlJobsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalFollowsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalLikesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalTopicsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    issn?: SortOrder
    hIndex?: SortOrder
    publisher?: SortOrder
    nation?: SortOrder
    scope?: SortOrder
    emailSubmission?: SortOrder
    creator?: SortOrder
  }

  export type JournalsAvgOrderByAggregateInput = {
    hIndex?: SortOrder
  }

  export type JournalsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    issn?: SortOrder
    hIndex?: SortOrder
    publisher?: SortOrder
    nation?: SortOrder
    scope?: SortOrder
    emailSubmission?: SortOrder
    creator?: SortOrder
  }

  export type JournalsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    issn?: SortOrder
    hIndex?: SortOrder
    publisher?: SortOrder
    nation?: SortOrder
    scope?: SortOrder
    emailSubmission?: SortOrder
    creator?: SortOrder
  }

  export type JournalsSumOrderByAggregateInput = {
    hIndex?: SortOrder
  }

  export type LocationsCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    cityStateProvince?: SortOrder
    country?: SortOrder
    continent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAvailable?: SortOrder
    organizeId?: SortOrder
  }

  export type LocationsMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    cityStateProvince?: SortOrder
    country?: SortOrder
    continent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAvailable?: SortOrder
    organizeId?: SortOrder
  }

  export type LocationsMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    cityStateProvince?: SortOrder
    country?: SortOrder
    continent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAvailable?: SortOrder
    organizeId?: SortOrder
  }

  export type NotificationsTypesScalarRelationFilter = {
    is?: NotificationsTypesWhereInput
    isNot?: NotificationsTypesWhereInput
  }

  export type NotificationSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationId?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationId?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationId?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationsUserIdNotificationIdCompoundUniqueInput = {
    userId: string
    notificationId: string
  }

  export type NotificationsCountOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationsMinOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSettingsListRelationFilter = {
    every?: NotificationSettingsWhereInput
    some?: NotificationSettingsWhereInput
    none?: NotificationSettingsWhereInput
  }

  export type NotificationsListRelationFilter = {
    every?: NotificationsWhereInput
    some?: NotificationsWhereInput
    none?: NotificationsWhereInput
  }

  export type NotificationSettingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationsTypesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationsTypesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationsTypesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PassengerCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
  }

  export type PassengerMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
  }

  export type PassengerMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
  }

  export type SourcesScalarRelationFilter = {
    is?: SourcesWhereInput
    isNot?: SourcesWhereInput
  }

  export type RanksCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    sourceId?: SortOrder
  }

  export type RanksAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type RanksMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    sourceId?: SortOrder
  }

  export type RanksMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    sourceId?: SortOrder
  }

  export type RanksSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type RanksListRelationFilter = {
    every?: RanksWhereInput
    some?: RanksWhereInput
    none?: RanksWhereInput
  }

  export type RanksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SourcesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
  }

  export type SourcesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
  }

  export type SourcesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
  }

  export type TopicUserInterestedsUserIdTopicIdCompoundUniqueInput = {
    userId: string
    topicId: string
  }

  export type TopicUserInterestedsCountOrderByAggregateInput = {
    userId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopicUserInterestedsMaxOrderByAggregateInput = {
    userId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopicUserInterestedsMinOrderByAggregateInput = {
    userId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopicUserInterestedsListRelationFilter = {
    every?: TopicUserInterestedsWhereInput
    some?: TopicUserInterestedsWhereInput
    none?: TopicUserInterestedsWhereInput
  }

  export type TopicUserInterestedsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TopicsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopicsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopicsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserVerificationUserIdVerificationCodeVerificationCodeExpiresCompoundUniqueInput = {
    userId: string
    verificationCode: string
    verificationCodeExpires: Date | string
  }

  export type UserVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    verificationCode?: SortOrder
    verificationCodeExpires?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    verificationCode?: SortOrder
    verificationCodeExpires?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    verificationCode?: SortOrder
    verificationCodeExpires?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalsListRelationFilter = {
    every?: JournalsWhereInput
    some?: JournalsWhereInput
    none?: JournalsWhereInput
  }

  export type UserVerificationListRelationFilter = {
    every?: UserVerificationWhereInput
    some?: UserVerificationWhereInput
    none?: UserVerificationWhereInput
  }

  export type JournalsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserVerificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aboutMe?: SortOrder
    avatar?: SortOrder
    background?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aboutMe?: SortOrder
    avatar?: SortOrder
    background?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aboutMe?: SortOrder
    avatar?: SortOrder
    background?: SortOrder
  }

  export type ConferencesCreateNestedManyWithoutAdminsInput = {
    create?: XOR<ConferencesCreateWithoutAdminsInput, ConferencesUncheckedCreateWithoutAdminsInput> | ConferencesCreateWithoutAdminsInput[] | ConferencesUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: ConferencesCreateOrConnectWithoutAdminsInput | ConferencesCreateOrConnectWithoutAdminsInput[]
    createMany?: ConferencesCreateManyAdminsInputEnvelope
    connect?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
  }

  export type ConferencesUncheckedCreateNestedManyWithoutAdminsInput = {
    create?: XOR<ConferencesCreateWithoutAdminsInput, ConferencesUncheckedCreateWithoutAdminsInput> | ConferencesCreateWithoutAdminsInput[] | ConferencesUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: ConferencesCreateOrConnectWithoutAdminsInput | ConferencesCreateOrConnectWithoutAdminsInput[]
    createMany?: ConferencesCreateManyAdminsInputEnvelope
    connect?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ConferencesUpdateManyWithoutAdminsNestedInput = {
    create?: XOR<ConferencesCreateWithoutAdminsInput, ConferencesUncheckedCreateWithoutAdminsInput> | ConferencesCreateWithoutAdminsInput[] | ConferencesUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: ConferencesCreateOrConnectWithoutAdminsInput | ConferencesCreateOrConnectWithoutAdminsInput[]
    upsert?: ConferencesUpsertWithWhereUniqueWithoutAdminsInput | ConferencesUpsertWithWhereUniqueWithoutAdminsInput[]
    createMany?: ConferencesCreateManyAdminsInputEnvelope
    set?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
    disconnect?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
    delete?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
    connect?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
    update?: ConferencesUpdateWithWhereUniqueWithoutAdminsInput | ConferencesUpdateWithWhereUniqueWithoutAdminsInput[]
    updateMany?: ConferencesUpdateManyWithWhereWithoutAdminsInput | ConferencesUpdateManyWithWhereWithoutAdminsInput[]
    deleteMany?: ConferencesScalarWhereInput | ConferencesScalarWhereInput[]
  }

  export type ConferencesUncheckedUpdateManyWithoutAdminsNestedInput = {
    create?: XOR<ConferencesCreateWithoutAdminsInput, ConferencesUncheckedCreateWithoutAdminsInput> | ConferencesCreateWithoutAdminsInput[] | ConferencesUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: ConferencesCreateOrConnectWithoutAdminsInput | ConferencesCreateOrConnectWithoutAdminsInput[]
    upsert?: ConferencesUpsertWithWhereUniqueWithoutAdminsInput | ConferencesUpsertWithWhereUniqueWithoutAdminsInput[]
    createMany?: ConferencesCreateManyAdminsInputEnvelope
    set?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
    disconnect?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
    delete?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
    connect?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
    update?: ConferencesUpdateWithWhereUniqueWithoutAdminsInput | ConferencesUpdateWithWhereUniqueWithoutAdminsInput[]
    updateMany?: ConferencesUpdateManyWithWhereWithoutAdminsInput | ConferencesUpdateManyWithWhereWithoutAdminsInput[]
    deleteMany?: ConferencesScalarWhereInput | ConferencesScalarWhereInput[]
  }

  export type ConferencesCreateNestedOneWithoutConferenceBlacklistsInput = {
    create?: XOR<ConferencesCreateWithoutConferenceBlacklistsInput, ConferencesUncheckedCreateWithoutConferenceBlacklistsInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutConferenceBlacklistsInput
    connect?: ConferencesWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutConferenceBlacklistsInput = {
    create?: XOR<UsersCreateWithoutConferenceBlacklistsInput, UsersUncheckedCreateWithoutConferenceBlacklistsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutConferenceBlacklistsInput
    connect?: UsersWhereUniqueInput
  }

  export type ConferencesUpdateOneRequiredWithoutConferenceBlacklistsNestedInput = {
    create?: XOR<ConferencesCreateWithoutConferenceBlacklistsInput, ConferencesUncheckedCreateWithoutConferenceBlacklistsInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutConferenceBlacklistsInput
    upsert?: ConferencesUpsertWithoutConferenceBlacklistsInput
    connect?: ConferencesWhereUniqueInput
    update?: XOR<XOR<ConferencesUpdateToOneWithWhereWithoutConferenceBlacklistsInput, ConferencesUpdateWithoutConferenceBlacklistsInput>, ConferencesUncheckedUpdateWithoutConferenceBlacklistsInput>
  }

  export type UsersUpdateOneRequiredWithoutConferenceBlacklistsNestedInput = {
    create?: XOR<UsersCreateWithoutConferenceBlacklistsInput, UsersUncheckedCreateWithoutConferenceBlacklistsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutConferenceBlacklistsInput
    upsert?: UsersUpsertWithoutConferenceBlacklistsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutConferenceBlacklistsInput, UsersUpdateWithoutConferenceBlacklistsInput>, UsersUncheckedUpdateWithoutConferenceBlacklistsInput>
  }

  export type ConferencesCreateNestedOneWithoutConferenceCalendarsInput = {
    create?: XOR<ConferencesCreateWithoutConferenceCalendarsInput, ConferencesUncheckedCreateWithoutConferenceCalendarsInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutConferenceCalendarsInput
    connect?: ConferencesWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutConferenceCalendarsInput = {
    create?: XOR<UsersCreateWithoutConferenceCalendarsInput, UsersUncheckedCreateWithoutConferenceCalendarsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutConferenceCalendarsInput
    connect?: UsersWhereUniqueInput
  }

  export type ConferencesUpdateOneRequiredWithoutConferenceCalendarsNestedInput = {
    create?: XOR<ConferencesCreateWithoutConferenceCalendarsInput, ConferencesUncheckedCreateWithoutConferenceCalendarsInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutConferenceCalendarsInput
    upsert?: ConferencesUpsertWithoutConferenceCalendarsInput
    connect?: ConferencesWhereUniqueInput
    update?: XOR<XOR<ConferencesUpdateToOneWithWhereWithoutConferenceCalendarsInput, ConferencesUpdateWithoutConferenceCalendarsInput>, ConferencesUncheckedUpdateWithoutConferenceCalendarsInput>
  }

  export type UsersUpdateOneRequiredWithoutConferenceCalendarsNestedInput = {
    create?: XOR<UsersCreateWithoutConferenceCalendarsInput, UsersUncheckedCreateWithoutConferenceCalendarsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutConferenceCalendarsInput
    upsert?: UsersUpsertWithoutConferenceCalendarsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutConferenceCalendarsInput, UsersUpdateWithoutConferenceCalendarsInput>, UsersUncheckedUpdateWithoutConferenceCalendarsInput>
  }

  export type ConferencesCreateNestedOneWithoutConferenceCrawlJobsInput = {
    create?: XOR<ConferencesCreateWithoutConferenceCrawlJobsInput, ConferencesUncheckedCreateWithoutConferenceCrawlJobsInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutConferenceCrawlJobsInput
    connect?: ConferencesWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ConferencesUpdateOneRequiredWithoutConferenceCrawlJobsNestedInput = {
    create?: XOR<ConferencesCreateWithoutConferenceCrawlJobsInput, ConferencesUncheckedCreateWithoutConferenceCrawlJobsInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutConferenceCrawlJobsInput
    upsert?: ConferencesUpsertWithoutConferenceCrawlJobsInput
    connect?: ConferencesWhereUniqueInput
    update?: XOR<XOR<ConferencesUpdateToOneWithWhereWithoutConferenceCrawlJobsInput, ConferencesUpdateWithoutConferenceCrawlJobsInput>, ConferencesUncheckedUpdateWithoutConferenceCrawlJobsInput>
  }

  export type ConferenceOrganizationsCreateNestedOneWithoutConferenceDatesInput = {
    create?: XOR<ConferenceOrganizationsCreateWithoutConferenceDatesInput, ConferenceOrganizationsUncheckedCreateWithoutConferenceDatesInput>
    connectOrCreate?: ConferenceOrganizationsCreateOrConnectWithoutConferenceDatesInput
    connect?: ConferenceOrganizationsWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ConferenceOrganizationsUpdateOneRequiredWithoutConferenceDatesNestedInput = {
    create?: XOR<ConferenceOrganizationsCreateWithoutConferenceDatesInput, ConferenceOrganizationsUncheckedCreateWithoutConferenceDatesInput>
    connectOrCreate?: ConferenceOrganizationsCreateOrConnectWithoutConferenceDatesInput
    upsert?: ConferenceOrganizationsUpsertWithoutConferenceDatesInput
    connect?: ConferenceOrganizationsWhereUniqueInput
    update?: XOR<XOR<ConferenceOrganizationsUpdateToOneWithWhereWithoutConferenceDatesInput, ConferenceOrganizationsUpdateWithoutConferenceDatesInput>, ConferenceOrganizationsUncheckedUpdateWithoutConferenceDatesInput>
  }

  export type ConferencesCreateNestedOneWithoutConferenceFeedbacksInput = {
    create?: XOR<ConferencesCreateWithoutConferenceFeedbacksInput, ConferencesUncheckedCreateWithoutConferenceFeedbacksInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutConferenceFeedbacksInput
    connect?: ConferencesWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutConferenceFeedbacksInput = {
    create?: XOR<UsersCreateWithoutConferenceFeedbacksInput, UsersUncheckedCreateWithoutConferenceFeedbacksInput>
    connectOrCreate?: UsersCreateOrConnectWithoutConferenceFeedbacksInput
    connect?: UsersWhereUniqueInput
  }

  export type ConferencesUpdateOneRequiredWithoutConferenceFeedbacksNestedInput = {
    create?: XOR<ConferencesCreateWithoutConferenceFeedbacksInput, ConferencesUncheckedCreateWithoutConferenceFeedbacksInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutConferenceFeedbacksInput
    upsert?: ConferencesUpsertWithoutConferenceFeedbacksInput
    connect?: ConferencesWhereUniqueInput
    update?: XOR<XOR<ConferencesUpdateToOneWithWhereWithoutConferenceFeedbacksInput, ConferencesUpdateWithoutConferenceFeedbacksInput>, ConferencesUncheckedUpdateWithoutConferenceFeedbacksInput>
  }

  export type UsersUpdateOneRequiredWithoutConferenceFeedbacksNestedInput = {
    create?: XOR<UsersCreateWithoutConferenceFeedbacksInput, UsersUncheckedCreateWithoutConferenceFeedbacksInput>
    connectOrCreate?: UsersCreateOrConnectWithoutConferenceFeedbacksInput
    upsert?: UsersUpsertWithoutConferenceFeedbacksInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutConferenceFeedbacksInput, UsersUpdateWithoutConferenceFeedbacksInput>, UsersUncheckedUpdateWithoutConferenceFeedbacksInput>
  }

  export type ConferencesCreateNestedOneWithoutConferenceFollowsInput = {
    create?: XOR<ConferencesCreateWithoutConferenceFollowsInput, ConferencesUncheckedCreateWithoutConferenceFollowsInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutConferenceFollowsInput
    connect?: ConferencesWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutConferenceFollowsInput = {
    create?: XOR<UsersCreateWithoutConferenceFollowsInput, UsersUncheckedCreateWithoutConferenceFollowsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutConferenceFollowsInput
    connect?: UsersWhereUniqueInput
  }

  export type ConferencesUpdateOneRequiredWithoutConferenceFollowsNestedInput = {
    create?: XOR<ConferencesCreateWithoutConferenceFollowsInput, ConferencesUncheckedCreateWithoutConferenceFollowsInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutConferenceFollowsInput
    upsert?: ConferencesUpsertWithoutConferenceFollowsInput
    connect?: ConferencesWhereUniqueInput
    update?: XOR<XOR<ConferencesUpdateToOneWithWhereWithoutConferenceFollowsInput, ConferencesUpdateWithoutConferenceFollowsInput>, ConferencesUncheckedUpdateWithoutConferenceFollowsInput>
  }

  export type UsersUpdateOneRequiredWithoutConferenceFollowsNestedInput = {
    create?: XOR<UsersCreateWithoutConferenceFollowsInput, UsersUncheckedCreateWithoutConferenceFollowsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutConferenceFollowsInput
    upsert?: UsersUpsertWithoutConferenceFollowsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutConferenceFollowsInput, UsersUpdateWithoutConferenceFollowsInput>, UsersUncheckedUpdateWithoutConferenceFollowsInput>
  }

  export type ConferencesCreateNestedOneWithoutConferenceLikesInput = {
    create?: XOR<ConferencesCreateWithoutConferenceLikesInput, ConferencesUncheckedCreateWithoutConferenceLikesInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutConferenceLikesInput
    connect?: ConferencesWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutConferenceLikesInput = {
    create?: XOR<UsersCreateWithoutConferenceLikesInput, UsersUncheckedCreateWithoutConferenceLikesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutConferenceLikesInput
    connect?: UsersWhereUniqueInput
  }

  export type ConferencesUpdateOneRequiredWithoutConferenceLikesNestedInput = {
    create?: XOR<ConferencesCreateWithoutConferenceLikesInput, ConferencesUncheckedCreateWithoutConferenceLikesInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutConferenceLikesInput
    upsert?: ConferencesUpsertWithoutConferenceLikesInput
    connect?: ConferencesWhereUniqueInput
    update?: XOR<XOR<ConferencesUpdateToOneWithWhereWithoutConferenceLikesInput, ConferencesUpdateWithoutConferenceLikesInput>, ConferencesUncheckedUpdateWithoutConferenceLikesInput>
  }

  export type UsersUpdateOneRequiredWithoutConferenceLikesNestedInput = {
    create?: XOR<UsersCreateWithoutConferenceLikesInput, UsersUncheckedCreateWithoutConferenceLikesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutConferenceLikesInput
    upsert?: UsersUpsertWithoutConferenceLikesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutConferenceLikesInput, UsersUpdateWithoutConferenceLikesInput>, UsersUncheckedUpdateWithoutConferenceLikesInput>
  }

  export type ConferenceDatesCreateNestedManyWithoutConferenceOrganizationsInput = {
    create?: XOR<ConferenceDatesCreateWithoutConferenceOrganizationsInput, ConferenceDatesUncheckedCreateWithoutConferenceOrganizationsInput> | ConferenceDatesCreateWithoutConferenceOrganizationsInput[] | ConferenceDatesUncheckedCreateWithoutConferenceOrganizationsInput[]
    connectOrCreate?: ConferenceDatesCreateOrConnectWithoutConferenceOrganizationsInput | ConferenceDatesCreateOrConnectWithoutConferenceOrganizationsInput[]
    createMany?: ConferenceDatesCreateManyConferenceOrganizationsInputEnvelope
    connect?: ConferenceDatesWhereUniqueInput | ConferenceDatesWhereUniqueInput[]
  }

  export type ConferencesCreateNestedOneWithoutConferenceOrganizationsInput = {
    create?: XOR<ConferencesCreateWithoutConferenceOrganizationsInput, ConferencesUncheckedCreateWithoutConferenceOrganizationsInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutConferenceOrganizationsInput
    connect?: ConferencesWhereUniqueInput
  }

  export type ConferenceTopicsCreateNestedManyWithoutConferenceOrganizationsInput = {
    create?: XOR<ConferenceTopicsCreateWithoutConferenceOrganizationsInput, ConferenceTopicsUncheckedCreateWithoutConferenceOrganizationsInput> | ConferenceTopicsCreateWithoutConferenceOrganizationsInput[] | ConferenceTopicsUncheckedCreateWithoutConferenceOrganizationsInput[]
    connectOrCreate?: ConferenceTopicsCreateOrConnectWithoutConferenceOrganizationsInput | ConferenceTopicsCreateOrConnectWithoutConferenceOrganizationsInput[]
    createMany?: ConferenceTopicsCreateManyConferenceOrganizationsInputEnvelope
    connect?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
  }

  export type LocationsCreateNestedManyWithoutConferenceOrganizationsInput = {
    create?: XOR<LocationsCreateWithoutConferenceOrganizationsInput, LocationsUncheckedCreateWithoutConferenceOrganizationsInput> | LocationsCreateWithoutConferenceOrganizationsInput[] | LocationsUncheckedCreateWithoutConferenceOrganizationsInput[]
    connectOrCreate?: LocationsCreateOrConnectWithoutConferenceOrganizationsInput | LocationsCreateOrConnectWithoutConferenceOrganizationsInput[]
    createMany?: LocationsCreateManyConferenceOrganizationsInputEnvelope
    connect?: LocationsWhereUniqueInput | LocationsWhereUniqueInput[]
  }

  export type ConferenceDatesUncheckedCreateNestedManyWithoutConferenceOrganizationsInput = {
    create?: XOR<ConferenceDatesCreateWithoutConferenceOrganizationsInput, ConferenceDatesUncheckedCreateWithoutConferenceOrganizationsInput> | ConferenceDatesCreateWithoutConferenceOrganizationsInput[] | ConferenceDatesUncheckedCreateWithoutConferenceOrganizationsInput[]
    connectOrCreate?: ConferenceDatesCreateOrConnectWithoutConferenceOrganizationsInput | ConferenceDatesCreateOrConnectWithoutConferenceOrganizationsInput[]
    createMany?: ConferenceDatesCreateManyConferenceOrganizationsInputEnvelope
    connect?: ConferenceDatesWhereUniqueInput | ConferenceDatesWhereUniqueInput[]
  }

  export type ConferenceTopicsUncheckedCreateNestedManyWithoutConferenceOrganizationsInput = {
    create?: XOR<ConferenceTopicsCreateWithoutConferenceOrganizationsInput, ConferenceTopicsUncheckedCreateWithoutConferenceOrganizationsInput> | ConferenceTopicsCreateWithoutConferenceOrganizationsInput[] | ConferenceTopicsUncheckedCreateWithoutConferenceOrganizationsInput[]
    connectOrCreate?: ConferenceTopicsCreateOrConnectWithoutConferenceOrganizationsInput | ConferenceTopicsCreateOrConnectWithoutConferenceOrganizationsInput[]
    createMany?: ConferenceTopicsCreateManyConferenceOrganizationsInputEnvelope
    connect?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
  }

  export type LocationsUncheckedCreateNestedManyWithoutConferenceOrganizationsInput = {
    create?: XOR<LocationsCreateWithoutConferenceOrganizationsInput, LocationsUncheckedCreateWithoutConferenceOrganizationsInput> | LocationsCreateWithoutConferenceOrganizationsInput[] | LocationsUncheckedCreateWithoutConferenceOrganizationsInput[]
    connectOrCreate?: LocationsCreateOrConnectWithoutConferenceOrganizationsInput | LocationsCreateOrConnectWithoutConferenceOrganizationsInput[]
    createMany?: LocationsCreateManyConferenceOrganizationsInputEnvelope
    connect?: LocationsWhereUniqueInput | LocationsWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ConferenceDatesUpdateManyWithoutConferenceOrganizationsNestedInput = {
    create?: XOR<ConferenceDatesCreateWithoutConferenceOrganizationsInput, ConferenceDatesUncheckedCreateWithoutConferenceOrganizationsInput> | ConferenceDatesCreateWithoutConferenceOrganizationsInput[] | ConferenceDatesUncheckedCreateWithoutConferenceOrganizationsInput[]
    connectOrCreate?: ConferenceDatesCreateOrConnectWithoutConferenceOrganizationsInput | ConferenceDatesCreateOrConnectWithoutConferenceOrganizationsInput[]
    upsert?: ConferenceDatesUpsertWithWhereUniqueWithoutConferenceOrganizationsInput | ConferenceDatesUpsertWithWhereUniqueWithoutConferenceOrganizationsInput[]
    createMany?: ConferenceDatesCreateManyConferenceOrganizationsInputEnvelope
    set?: ConferenceDatesWhereUniqueInput | ConferenceDatesWhereUniqueInput[]
    disconnect?: ConferenceDatesWhereUniqueInput | ConferenceDatesWhereUniqueInput[]
    delete?: ConferenceDatesWhereUniqueInput | ConferenceDatesWhereUniqueInput[]
    connect?: ConferenceDatesWhereUniqueInput | ConferenceDatesWhereUniqueInput[]
    update?: ConferenceDatesUpdateWithWhereUniqueWithoutConferenceOrganizationsInput | ConferenceDatesUpdateWithWhereUniqueWithoutConferenceOrganizationsInput[]
    updateMany?: ConferenceDatesUpdateManyWithWhereWithoutConferenceOrganizationsInput | ConferenceDatesUpdateManyWithWhereWithoutConferenceOrganizationsInput[]
    deleteMany?: ConferenceDatesScalarWhereInput | ConferenceDatesScalarWhereInput[]
  }

  export type ConferencesUpdateOneRequiredWithoutConferenceOrganizationsNestedInput = {
    create?: XOR<ConferencesCreateWithoutConferenceOrganizationsInput, ConferencesUncheckedCreateWithoutConferenceOrganizationsInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutConferenceOrganizationsInput
    upsert?: ConferencesUpsertWithoutConferenceOrganizationsInput
    connect?: ConferencesWhereUniqueInput
    update?: XOR<XOR<ConferencesUpdateToOneWithWhereWithoutConferenceOrganizationsInput, ConferencesUpdateWithoutConferenceOrganizationsInput>, ConferencesUncheckedUpdateWithoutConferenceOrganizationsInput>
  }

  export type ConferenceTopicsUpdateManyWithoutConferenceOrganizationsNestedInput = {
    create?: XOR<ConferenceTopicsCreateWithoutConferenceOrganizationsInput, ConferenceTopicsUncheckedCreateWithoutConferenceOrganizationsInput> | ConferenceTopicsCreateWithoutConferenceOrganizationsInput[] | ConferenceTopicsUncheckedCreateWithoutConferenceOrganizationsInput[]
    connectOrCreate?: ConferenceTopicsCreateOrConnectWithoutConferenceOrganizationsInput | ConferenceTopicsCreateOrConnectWithoutConferenceOrganizationsInput[]
    upsert?: ConferenceTopicsUpsertWithWhereUniqueWithoutConferenceOrganizationsInput | ConferenceTopicsUpsertWithWhereUniqueWithoutConferenceOrganizationsInput[]
    createMany?: ConferenceTopicsCreateManyConferenceOrganizationsInputEnvelope
    set?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    disconnect?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    delete?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    connect?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    update?: ConferenceTopicsUpdateWithWhereUniqueWithoutConferenceOrganizationsInput | ConferenceTopicsUpdateWithWhereUniqueWithoutConferenceOrganizationsInput[]
    updateMany?: ConferenceTopicsUpdateManyWithWhereWithoutConferenceOrganizationsInput | ConferenceTopicsUpdateManyWithWhereWithoutConferenceOrganizationsInput[]
    deleteMany?: ConferenceTopicsScalarWhereInput | ConferenceTopicsScalarWhereInput[]
  }

  export type LocationsUpdateManyWithoutConferenceOrganizationsNestedInput = {
    create?: XOR<LocationsCreateWithoutConferenceOrganizationsInput, LocationsUncheckedCreateWithoutConferenceOrganizationsInput> | LocationsCreateWithoutConferenceOrganizationsInput[] | LocationsUncheckedCreateWithoutConferenceOrganizationsInput[]
    connectOrCreate?: LocationsCreateOrConnectWithoutConferenceOrganizationsInput | LocationsCreateOrConnectWithoutConferenceOrganizationsInput[]
    upsert?: LocationsUpsertWithWhereUniqueWithoutConferenceOrganizationsInput | LocationsUpsertWithWhereUniqueWithoutConferenceOrganizationsInput[]
    createMany?: LocationsCreateManyConferenceOrganizationsInputEnvelope
    set?: LocationsWhereUniqueInput | LocationsWhereUniqueInput[]
    disconnect?: LocationsWhereUniqueInput | LocationsWhereUniqueInput[]
    delete?: LocationsWhereUniqueInput | LocationsWhereUniqueInput[]
    connect?: LocationsWhereUniqueInput | LocationsWhereUniqueInput[]
    update?: LocationsUpdateWithWhereUniqueWithoutConferenceOrganizationsInput | LocationsUpdateWithWhereUniqueWithoutConferenceOrganizationsInput[]
    updateMany?: LocationsUpdateManyWithWhereWithoutConferenceOrganizationsInput | LocationsUpdateManyWithWhereWithoutConferenceOrganizationsInput[]
    deleteMany?: LocationsScalarWhereInput | LocationsScalarWhereInput[]
  }

  export type ConferenceDatesUncheckedUpdateManyWithoutConferenceOrganizationsNestedInput = {
    create?: XOR<ConferenceDatesCreateWithoutConferenceOrganizationsInput, ConferenceDatesUncheckedCreateWithoutConferenceOrganizationsInput> | ConferenceDatesCreateWithoutConferenceOrganizationsInput[] | ConferenceDatesUncheckedCreateWithoutConferenceOrganizationsInput[]
    connectOrCreate?: ConferenceDatesCreateOrConnectWithoutConferenceOrganizationsInput | ConferenceDatesCreateOrConnectWithoutConferenceOrganizationsInput[]
    upsert?: ConferenceDatesUpsertWithWhereUniqueWithoutConferenceOrganizationsInput | ConferenceDatesUpsertWithWhereUniqueWithoutConferenceOrganizationsInput[]
    createMany?: ConferenceDatesCreateManyConferenceOrganizationsInputEnvelope
    set?: ConferenceDatesWhereUniqueInput | ConferenceDatesWhereUniqueInput[]
    disconnect?: ConferenceDatesWhereUniqueInput | ConferenceDatesWhereUniqueInput[]
    delete?: ConferenceDatesWhereUniqueInput | ConferenceDatesWhereUniqueInput[]
    connect?: ConferenceDatesWhereUniqueInput | ConferenceDatesWhereUniqueInput[]
    update?: ConferenceDatesUpdateWithWhereUniqueWithoutConferenceOrganizationsInput | ConferenceDatesUpdateWithWhereUniqueWithoutConferenceOrganizationsInput[]
    updateMany?: ConferenceDatesUpdateManyWithWhereWithoutConferenceOrganizationsInput | ConferenceDatesUpdateManyWithWhereWithoutConferenceOrganizationsInput[]
    deleteMany?: ConferenceDatesScalarWhereInput | ConferenceDatesScalarWhereInput[]
  }

  export type ConferenceTopicsUncheckedUpdateManyWithoutConferenceOrganizationsNestedInput = {
    create?: XOR<ConferenceTopicsCreateWithoutConferenceOrganizationsInput, ConferenceTopicsUncheckedCreateWithoutConferenceOrganizationsInput> | ConferenceTopicsCreateWithoutConferenceOrganizationsInput[] | ConferenceTopicsUncheckedCreateWithoutConferenceOrganizationsInput[]
    connectOrCreate?: ConferenceTopicsCreateOrConnectWithoutConferenceOrganizationsInput | ConferenceTopicsCreateOrConnectWithoutConferenceOrganizationsInput[]
    upsert?: ConferenceTopicsUpsertWithWhereUniqueWithoutConferenceOrganizationsInput | ConferenceTopicsUpsertWithWhereUniqueWithoutConferenceOrganizationsInput[]
    createMany?: ConferenceTopicsCreateManyConferenceOrganizationsInputEnvelope
    set?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    disconnect?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    delete?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    connect?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    update?: ConferenceTopicsUpdateWithWhereUniqueWithoutConferenceOrganizationsInput | ConferenceTopicsUpdateWithWhereUniqueWithoutConferenceOrganizationsInput[]
    updateMany?: ConferenceTopicsUpdateManyWithWhereWithoutConferenceOrganizationsInput | ConferenceTopicsUpdateManyWithWhereWithoutConferenceOrganizationsInput[]
    deleteMany?: ConferenceTopicsScalarWhereInput | ConferenceTopicsScalarWhereInput[]
  }

  export type LocationsUncheckedUpdateManyWithoutConferenceOrganizationsNestedInput = {
    create?: XOR<LocationsCreateWithoutConferenceOrganizationsInput, LocationsUncheckedCreateWithoutConferenceOrganizationsInput> | LocationsCreateWithoutConferenceOrganizationsInput[] | LocationsUncheckedCreateWithoutConferenceOrganizationsInput[]
    connectOrCreate?: LocationsCreateOrConnectWithoutConferenceOrganizationsInput | LocationsCreateOrConnectWithoutConferenceOrganizationsInput[]
    upsert?: LocationsUpsertWithWhereUniqueWithoutConferenceOrganizationsInput | LocationsUpsertWithWhereUniqueWithoutConferenceOrganizationsInput[]
    createMany?: LocationsCreateManyConferenceOrganizationsInputEnvelope
    set?: LocationsWhereUniqueInput | LocationsWhereUniqueInput[]
    disconnect?: LocationsWhereUniqueInput | LocationsWhereUniqueInput[]
    delete?: LocationsWhereUniqueInput | LocationsWhereUniqueInput[]
    connect?: LocationsWhereUniqueInput | LocationsWhereUniqueInput[]
    update?: LocationsUpdateWithWhereUniqueWithoutConferenceOrganizationsInput | LocationsUpdateWithWhereUniqueWithoutConferenceOrganizationsInput[]
    updateMany?: LocationsUpdateManyWithWhereWithoutConferenceOrganizationsInput | LocationsUpdateManyWithWhereWithoutConferenceOrganizationsInput[]
    deleteMany?: LocationsScalarWhereInput | LocationsScalarWhereInput[]
  }

  export type ConferencesCreateNestedOneWithoutConferenceRanksInput = {
    create?: XOR<ConferencesCreateWithoutConferenceRanksInput, ConferencesUncheckedCreateWithoutConferenceRanksInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutConferenceRanksInput
    connect?: ConferencesWhereUniqueInput
  }

  export type FieldOfResearchsCreateNestedOneWithoutConferenceRanksInput = {
    create?: XOR<FieldOfResearchsCreateWithoutConferenceRanksInput, FieldOfResearchsUncheckedCreateWithoutConferenceRanksInput>
    connectOrCreate?: FieldOfResearchsCreateOrConnectWithoutConferenceRanksInput
    connect?: FieldOfResearchsWhereUniqueInput
  }

  export type RanksCreateNestedOneWithoutConferenceRanksInput = {
    create?: XOR<RanksCreateWithoutConferenceRanksInput, RanksUncheckedCreateWithoutConferenceRanksInput>
    connectOrCreate?: RanksCreateOrConnectWithoutConferenceRanksInput
    connect?: RanksWhereUniqueInput
  }

  export type ConferencesUpdateOneRequiredWithoutConferenceRanksNestedInput = {
    create?: XOR<ConferencesCreateWithoutConferenceRanksInput, ConferencesUncheckedCreateWithoutConferenceRanksInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutConferenceRanksInput
    upsert?: ConferencesUpsertWithoutConferenceRanksInput
    connect?: ConferencesWhereUniqueInput
    update?: XOR<XOR<ConferencesUpdateToOneWithWhereWithoutConferenceRanksInput, ConferencesUpdateWithoutConferenceRanksInput>, ConferencesUncheckedUpdateWithoutConferenceRanksInput>
  }

  export type FieldOfResearchsUpdateOneRequiredWithoutConferenceRanksNestedInput = {
    create?: XOR<FieldOfResearchsCreateWithoutConferenceRanksInput, FieldOfResearchsUncheckedCreateWithoutConferenceRanksInput>
    connectOrCreate?: FieldOfResearchsCreateOrConnectWithoutConferenceRanksInput
    upsert?: FieldOfResearchsUpsertWithoutConferenceRanksInput
    connect?: FieldOfResearchsWhereUniqueInput
    update?: XOR<XOR<FieldOfResearchsUpdateToOneWithWhereWithoutConferenceRanksInput, FieldOfResearchsUpdateWithoutConferenceRanksInput>, FieldOfResearchsUncheckedUpdateWithoutConferenceRanksInput>
  }

  export type RanksUpdateOneRequiredWithoutConferenceRanksNestedInput = {
    create?: XOR<RanksCreateWithoutConferenceRanksInput, RanksUncheckedCreateWithoutConferenceRanksInput>
    connectOrCreate?: RanksCreateOrConnectWithoutConferenceRanksInput
    upsert?: RanksUpsertWithoutConferenceRanksInput
    connect?: RanksWhereUniqueInput
    update?: XOR<XOR<RanksUpdateToOneWithWhereWithoutConferenceRanksInput, RanksUpdateWithoutConferenceRanksInput>, RanksUncheckedUpdateWithoutConferenceRanksInput>
  }

  export type ConferenceOrganizationsCreateNestedOneWithoutConferenceTopicsInput = {
    create?: XOR<ConferenceOrganizationsCreateWithoutConferenceTopicsInput, ConferenceOrganizationsUncheckedCreateWithoutConferenceTopicsInput>
    connectOrCreate?: ConferenceOrganizationsCreateOrConnectWithoutConferenceTopicsInput
    connect?: ConferenceOrganizationsWhereUniqueInput
  }

  export type TopicsCreateNestedOneWithoutConferenceTopicsInput = {
    create?: XOR<TopicsCreateWithoutConferenceTopicsInput, TopicsUncheckedCreateWithoutConferenceTopicsInput>
    connectOrCreate?: TopicsCreateOrConnectWithoutConferenceTopicsInput
    connect?: TopicsWhereUniqueInput
  }

  export type ConferenceOrganizationsUpdateOneRequiredWithoutConferenceTopicsNestedInput = {
    create?: XOR<ConferenceOrganizationsCreateWithoutConferenceTopicsInput, ConferenceOrganizationsUncheckedCreateWithoutConferenceTopicsInput>
    connectOrCreate?: ConferenceOrganizationsCreateOrConnectWithoutConferenceTopicsInput
    upsert?: ConferenceOrganizationsUpsertWithoutConferenceTopicsInput
    connect?: ConferenceOrganizationsWhereUniqueInput
    update?: XOR<XOR<ConferenceOrganizationsUpdateToOneWithWhereWithoutConferenceTopicsInput, ConferenceOrganizationsUpdateWithoutConferenceTopicsInput>, ConferenceOrganizationsUncheckedUpdateWithoutConferenceTopicsInput>
  }

  export type TopicsUpdateOneRequiredWithoutConferenceTopicsNestedInput = {
    create?: XOR<TopicsCreateWithoutConferenceTopicsInput, TopicsUncheckedCreateWithoutConferenceTopicsInput>
    connectOrCreate?: TopicsCreateOrConnectWithoutConferenceTopicsInput
    upsert?: TopicsUpsertWithoutConferenceTopicsInput
    connect?: TopicsWhereUniqueInput
    update?: XOR<XOR<TopicsUpdateToOneWithWhereWithoutConferenceTopicsInput, TopicsUpdateWithoutConferenceTopicsInput>, TopicsUncheckedUpdateWithoutConferenceTopicsInput>
  }

  export type ConferenceBlacklistsCreateNestedManyWithoutConferencesInput = {
    create?: XOR<ConferenceBlacklistsCreateWithoutConferencesInput, ConferenceBlacklistsUncheckedCreateWithoutConferencesInput> | ConferenceBlacklistsCreateWithoutConferencesInput[] | ConferenceBlacklistsUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceBlacklistsCreateOrConnectWithoutConferencesInput | ConferenceBlacklistsCreateOrConnectWithoutConferencesInput[]
    createMany?: ConferenceBlacklistsCreateManyConferencesInputEnvelope
    connect?: ConferenceBlacklistsWhereUniqueInput | ConferenceBlacklistsWhereUniqueInput[]
  }

  export type ConferenceCalendarsCreateNestedManyWithoutConferencesInput = {
    create?: XOR<ConferenceCalendarsCreateWithoutConferencesInput, ConferenceCalendarsUncheckedCreateWithoutConferencesInput> | ConferenceCalendarsCreateWithoutConferencesInput[] | ConferenceCalendarsUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceCalendarsCreateOrConnectWithoutConferencesInput | ConferenceCalendarsCreateOrConnectWithoutConferencesInput[]
    createMany?: ConferenceCalendarsCreateManyConferencesInputEnvelope
    connect?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
  }

  export type ConferenceCrawlJobsCreateNestedManyWithoutConferencesInput = {
    create?: XOR<ConferenceCrawlJobsCreateWithoutConferencesInput, ConferenceCrawlJobsUncheckedCreateWithoutConferencesInput> | ConferenceCrawlJobsCreateWithoutConferencesInput[] | ConferenceCrawlJobsUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceCrawlJobsCreateOrConnectWithoutConferencesInput | ConferenceCrawlJobsCreateOrConnectWithoutConferencesInput[]
    createMany?: ConferenceCrawlJobsCreateManyConferencesInputEnvelope
    connect?: ConferenceCrawlJobsWhereUniqueInput | ConferenceCrawlJobsWhereUniqueInput[]
  }

  export type ConferenceFeedbacksCreateNestedManyWithoutConferencesInput = {
    create?: XOR<ConferenceFeedbacksCreateWithoutConferencesInput, ConferenceFeedbacksUncheckedCreateWithoutConferencesInput> | ConferenceFeedbacksCreateWithoutConferencesInput[] | ConferenceFeedbacksUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceFeedbacksCreateOrConnectWithoutConferencesInput | ConferenceFeedbacksCreateOrConnectWithoutConferencesInput[]
    createMany?: ConferenceFeedbacksCreateManyConferencesInputEnvelope
    connect?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
  }

  export type ConferenceFollowsCreateNestedManyWithoutConferencesInput = {
    create?: XOR<ConferenceFollowsCreateWithoutConferencesInput, ConferenceFollowsUncheckedCreateWithoutConferencesInput> | ConferenceFollowsCreateWithoutConferencesInput[] | ConferenceFollowsUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceFollowsCreateOrConnectWithoutConferencesInput | ConferenceFollowsCreateOrConnectWithoutConferencesInput[]
    createMany?: ConferenceFollowsCreateManyConferencesInputEnvelope
    connect?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
  }

  export type ConferenceLikesCreateNestedManyWithoutConferencesInput = {
    create?: XOR<ConferenceLikesCreateWithoutConferencesInput, ConferenceLikesUncheckedCreateWithoutConferencesInput> | ConferenceLikesCreateWithoutConferencesInput[] | ConferenceLikesUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceLikesCreateOrConnectWithoutConferencesInput | ConferenceLikesCreateOrConnectWithoutConferencesInput[]
    createMany?: ConferenceLikesCreateManyConferencesInputEnvelope
    connect?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
  }

  export type ConferenceOrganizationsCreateNestedManyWithoutConferencesInput = {
    create?: XOR<ConferenceOrganizationsCreateWithoutConferencesInput, ConferenceOrganizationsUncheckedCreateWithoutConferencesInput> | ConferenceOrganizationsCreateWithoutConferencesInput[] | ConferenceOrganizationsUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceOrganizationsCreateOrConnectWithoutConferencesInput | ConferenceOrganizationsCreateOrConnectWithoutConferencesInput[]
    createMany?: ConferenceOrganizationsCreateManyConferencesInputEnvelope
    connect?: ConferenceOrganizationsWhereUniqueInput | ConferenceOrganizationsWhereUniqueInput[]
  }

  export type ConferenceRanksCreateNestedManyWithoutConferencesInput = {
    create?: XOR<ConferenceRanksCreateWithoutConferencesInput, ConferenceRanksUncheckedCreateWithoutConferencesInput> | ConferenceRanksCreateWithoutConferencesInput[] | ConferenceRanksUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceRanksCreateOrConnectWithoutConferencesInput | ConferenceRanksCreateOrConnectWithoutConferencesInput[]
    createMany?: ConferenceRanksCreateManyConferencesInputEnvelope
    connect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
  }

  export type AdminsCreateNestedOneWithoutConferencesInput = {
    create?: XOR<AdminsCreateWithoutConferencesInput, AdminsUncheckedCreateWithoutConferencesInput>
    connectOrCreate?: AdminsCreateOrConnectWithoutConferencesInput
    connect?: AdminsWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutConferencesInput = {
    create?: XOR<UsersCreateWithoutConferencesInput, UsersUncheckedCreateWithoutConferencesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutConferencesInput
    connect?: UsersWhereUniqueInput
  }

  export type ConferenceBlacklistsUncheckedCreateNestedManyWithoutConferencesInput = {
    create?: XOR<ConferenceBlacklistsCreateWithoutConferencesInput, ConferenceBlacklistsUncheckedCreateWithoutConferencesInput> | ConferenceBlacklistsCreateWithoutConferencesInput[] | ConferenceBlacklistsUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceBlacklistsCreateOrConnectWithoutConferencesInput | ConferenceBlacklistsCreateOrConnectWithoutConferencesInput[]
    createMany?: ConferenceBlacklistsCreateManyConferencesInputEnvelope
    connect?: ConferenceBlacklistsWhereUniqueInput | ConferenceBlacklistsWhereUniqueInput[]
  }

  export type ConferenceCalendarsUncheckedCreateNestedManyWithoutConferencesInput = {
    create?: XOR<ConferenceCalendarsCreateWithoutConferencesInput, ConferenceCalendarsUncheckedCreateWithoutConferencesInput> | ConferenceCalendarsCreateWithoutConferencesInput[] | ConferenceCalendarsUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceCalendarsCreateOrConnectWithoutConferencesInput | ConferenceCalendarsCreateOrConnectWithoutConferencesInput[]
    createMany?: ConferenceCalendarsCreateManyConferencesInputEnvelope
    connect?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
  }

  export type ConferenceCrawlJobsUncheckedCreateNestedManyWithoutConferencesInput = {
    create?: XOR<ConferenceCrawlJobsCreateWithoutConferencesInput, ConferenceCrawlJobsUncheckedCreateWithoutConferencesInput> | ConferenceCrawlJobsCreateWithoutConferencesInput[] | ConferenceCrawlJobsUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceCrawlJobsCreateOrConnectWithoutConferencesInput | ConferenceCrawlJobsCreateOrConnectWithoutConferencesInput[]
    createMany?: ConferenceCrawlJobsCreateManyConferencesInputEnvelope
    connect?: ConferenceCrawlJobsWhereUniqueInput | ConferenceCrawlJobsWhereUniqueInput[]
  }

  export type ConferenceFeedbacksUncheckedCreateNestedManyWithoutConferencesInput = {
    create?: XOR<ConferenceFeedbacksCreateWithoutConferencesInput, ConferenceFeedbacksUncheckedCreateWithoutConferencesInput> | ConferenceFeedbacksCreateWithoutConferencesInput[] | ConferenceFeedbacksUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceFeedbacksCreateOrConnectWithoutConferencesInput | ConferenceFeedbacksCreateOrConnectWithoutConferencesInput[]
    createMany?: ConferenceFeedbacksCreateManyConferencesInputEnvelope
    connect?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
  }

  export type ConferenceFollowsUncheckedCreateNestedManyWithoutConferencesInput = {
    create?: XOR<ConferenceFollowsCreateWithoutConferencesInput, ConferenceFollowsUncheckedCreateWithoutConferencesInput> | ConferenceFollowsCreateWithoutConferencesInput[] | ConferenceFollowsUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceFollowsCreateOrConnectWithoutConferencesInput | ConferenceFollowsCreateOrConnectWithoutConferencesInput[]
    createMany?: ConferenceFollowsCreateManyConferencesInputEnvelope
    connect?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
  }

  export type ConferenceLikesUncheckedCreateNestedManyWithoutConferencesInput = {
    create?: XOR<ConferenceLikesCreateWithoutConferencesInput, ConferenceLikesUncheckedCreateWithoutConferencesInput> | ConferenceLikesCreateWithoutConferencesInput[] | ConferenceLikesUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceLikesCreateOrConnectWithoutConferencesInput | ConferenceLikesCreateOrConnectWithoutConferencesInput[]
    createMany?: ConferenceLikesCreateManyConferencesInputEnvelope
    connect?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
  }

  export type ConferenceOrganizationsUncheckedCreateNestedManyWithoutConferencesInput = {
    create?: XOR<ConferenceOrganizationsCreateWithoutConferencesInput, ConferenceOrganizationsUncheckedCreateWithoutConferencesInput> | ConferenceOrganizationsCreateWithoutConferencesInput[] | ConferenceOrganizationsUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceOrganizationsCreateOrConnectWithoutConferencesInput | ConferenceOrganizationsCreateOrConnectWithoutConferencesInput[]
    createMany?: ConferenceOrganizationsCreateManyConferencesInputEnvelope
    connect?: ConferenceOrganizationsWhereUniqueInput | ConferenceOrganizationsWhereUniqueInput[]
  }

  export type ConferenceRanksUncheckedCreateNestedManyWithoutConferencesInput = {
    create?: XOR<ConferenceRanksCreateWithoutConferencesInput, ConferenceRanksUncheckedCreateWithoutConferencesInput> | ConferenceRanksCreateWithoutConferencesInput[] | ConferenceRanksUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceRanksCreateOrConnectWithoutConferencesInput | ConferenceRanksCreateOrConnectWithoutConferencesInput[]
    createMany?: ConferenceRanksCreateManyConferencesInputEnvelope
    connect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
  }

  export type ConferenceBlacklistsUpdateManyWithoutConferencesNestedInput = {
    create?: XOR<ConferenceBlacklistsCreateWithoutConferencesInput, ConferenceBlacklistsUncheckedCreateWithoutConferencesInput> | ConferenceBlacklistsCreateWithoutConferencesInput[] | ConferenceBlacklistsUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceBlacklistsCreateOrConnectWithoutConferencesInput | ConferenceBlacklistsCreateOrConnectWithoutConferencesInput[]
    upsert?: ConferenceBlacklistsUpsertWithWhereUniqueWithoutConferencesInput | ConferenceBlacklistsUpsertWithWhereUniqueWithoutConferencesInput[]
    createMany?: ConferenceBlacklistsCreateManyConferencesInputEnvelope
    set?: ConferenceBlacklistsWhereUniqueInput | ConferenceBlacklistsWhereUniqueInput[]
    disconnect?: ConferenceBlacklistsWhereUniqueInput | ConferenceBlacklistsWhereUniqueInput[]
    delete?: ConferenceBlacklistsWhereUniqueInput | ConferenceBlacklistsWhereUniqueInput[]
    connect?: ConferenceBlacklistsWhereUniqueInput | ConferenceBlacklistsWhereUniqueInput[]
    update?: ConferenceBlacklistsUpdateWithWhereUniqueWithoutConferencesInput | ConferenceBlacklistsUpdateWithWhereUniqueWithoutConferencesInput[]
    updateMany?: ConferenceBlacklistsUpdateManyWithWhereWithoutConferencesInput | ConferenceBlacklistsUpdateManyWithWhereWithoutConferencesInput[]
    deleteMany?: ConferenceBlacklistsScalarWhereInput | ConferenceBlacklistsScalarWhereInput[]
  }

  export type ConferenceCalendarsUpdateManyWithoutConferencesNestedInput = {
    create?: XOR<ConferenceCalendarsCreateWithoutConferencesInput, ConferenceCalendarsUncheckedCreateWithoutConferencesInput> | ConferenceCalendarsCreateWithoutConferencesInput[] | ConferenceCalendarsUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceCalendarsCreateOrConnectWithoutConferencesInput | ConferenceCalendarsCreateOrConnectWithoutConferencesInput[]
    upsert?: ConferenceCalendarsUpsertWithWhereUniqueWithoutConferencesInput | ConferenceCalendarsUpsertWithWhereUniqueWithoutConferencesInput[]
    createMany?: ConferenceCalendarsCreateManyConferencesInputEnvelope
    set?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    disconnect?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    delete?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    connect?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    update?: ConferenceCalendarsUpdateWithWhereUniqueWithoutConferencesInput | ConferenceCalendarsUpdateWithWhereUniqueWithoutConferencesInput[]
    updateMany?: ConferenceCalendarsUpdateManyWithWhereWithoutConferencesInput | ConferenceCalendarsUpdateManyWithWhereWithoutConferencesInput[]
    deleteMany?: ConferenceCalendarsScalarWhereInput | ConferenceCalendarsScalarWhereInput[]
  }

  export type ConferenceCrawlJobsUpdateManyWithoutConferencesNestedInput = {
    create?: XOR<ConferenceCrawlJobsCreateWithoutConferencesInput, ConferenceCrawlJobsUncheckedCreateWithoutConferencesInput> | ConferenceCrawlJobsCreateWithoutConferencesInput[] | ConferenceCrawlJobsUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceCrawlJobsCreateOrConnectWithoutConferencesInput | ConferenceCrawlJobsCreateOrConnectWithoutConferencesInput[]
    upsert?: ConferenceCrawlJobsUpsertWithWhereUniqueWithoutConferencesInput | ConferenceCrawlJobsUpsertWithWhereUniqueWithoutConferencesInput[]
    createMany?: ConferenceCrawlJobsCreateManyConferencesInputEnvelope
    set?: ConferenceCrawlJobsWhereUniqueInput | ConferenceCrawlJobsWhereUniqueInput[]
    disconnect?: ConferenceCrawlJobsWhereUniqueInput | ConferenceCrawlJobsWhereUniqueInput[]
    delete?: ConferenceCrawlJobsWhereUniqueInput | ConferenceCrawlJobsWhereUniqueInput[]
    connect?: ConferenceCrawlJobsWhereUniqueInput | ConferenceCrawlJobsWhereUniqueInput[]
    update?: ConferenceCrawlJobsUpdateWithWhereUniqueWithoutConferencesInput | ConferenceCrawlJobsUpdateWithWhereUniqueWithoutConferencesInput[]
    updateMany?: ConferenceCrawlJobsUpdateManyWithWhereWithoutConferencesInput | ConferenceCrawlJobsUpdateManyWithWhereWithoutConferencesInput[]
    deleteMany?: ConferenceCrawlJobsScalarWhereInput | ConferenceCrawlJobsScalarWhereInput[]
  }

  export type ConferenceFeedbacksUpdateManyWithoutConferencesNestedInput = {
    create?: XOR<ConferenceFeedbacksCreateWithoutConferencesInput, ConferenceFeedbacksUncheckedCreateWithoutConferencesInput> | ConferenceFeedbacksCreateWithoutConferencesInput[] | ConferenceFeedbacksUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceFeedbacksCreateOrConnectWithoutConferencesInput | ConferenceFeedbacksCreateOrConnectWithoutConferencesInput[]
    upsert?: ConferenceFeedbacksUpsertWithWhereUniqueWithoutConferencesInput | ConferenceFeedbacksUpsertWithWhereUniqueWithoutConferencesInput[]
    createMany?: ConferenceFeedbacksCreateManyConferencesInputEnvelope
    set?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    disconnect?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    delete?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    connect?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    update?: ConferenceFeedbacksUpdateWithWhereUniqueWithoutConferencesInput | ConferenceFeedbacksUpdateWithWhereUniqueWithoutConferencesInput[]
    updateMany?: ConferenceFeedbacksUpdateManyWithWhereWithoutConferencesInput | ConferenceFeedbacksUpdateManyWithWhereWithoutConferencesInput[]
    deleteMany?: ConferenceFeedbacksScalarWhereInput | ConferenceFeedbacksScalarWhereInput[]
  }

  export type ConferenceFollowsUpdateManyWithoutConferencesNestedInput = {
    create?: XOR<ConferenceFollowsCreateWithoutConferencesInput, ConferenceFollowsUncheckedCreateWithoutConferencesInput> | ConferenceFollowsCreateWithoutConferencesInput[] | ConferenceFollowsUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceFollowsCreateOrConnectWithoutConferencesInput | ConferenceFollowsCreateOrConnectWithoutConferencesInput[]
    upsert?: ConferenceFollowsUpsertWithWhereUniqueWithoutConferencesInput | ConferenceFollowsUpsertWithWhereUniqueWithoutConferencesInput[]
    createMany?: ConferenceFollowsCreateManyConferencesInputEnvelope
    set?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    disconnect?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    delete?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    connect?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    update?: ConferenceFollowsUpdateWithWhereUniqueWithoutConferencesInput | ConferenceFollowsUpdateWithWhereUniqueWithoutConferencesInput[]
    updateMany?: ConferenceFollowsUpdateManyWithWhereWithoutConferencesInput | ConferenceFollowsUpdateManyWithWhereWithoutConferencesInput[]
    deleteMany?: ConferenceFollowsScalarWhereInput | ConferenceFollowsScalarWhereInput[]
  }

  export type ConferenceLikesUpdateManyWithoutConferencesNestedInput = {
    create?: XOR<ConferenceLikesCreateWithoutConferencesInput, ConferenceLikesUncheckedCreateWithoutConferencesInput> | ConferenceLikesCreateWithoutConferencesInput[] | ConferenceLikesUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceLikesCreateOrConnectWithoutConferencesInput | ConferenceLikesCreateOrConnectWithoutConferencesInput[]
    upsert?: ConferenceLikesUpsertWithWhereUniqueWithoutConferencesInput | ConferenceLikesUpsertWithWhereUniqueWithoutConferencesInput[]
    createMany?: ConferenceLikesCreateManyConferencesInputEnvelope
    set?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    disconnect?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    delete?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    connect?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    update?: ConferenceLikesUpdateWithWhereUniqueWithoutConferencesInput | ConferenceLikesUpdateWithWhereUniqueWithoutConferencesInput[]
    updateMany?: ConferenceLikesUpdateManyWithWhereWithoutConferencesInput | ConferenceLikesUpdateManyWithWhereWithoutConferencesInput[]
    deleteMany?: ConferenceLikesScalarWhereInput | ConferenceLikesScalarWhereInput[]
  }

  export type ConferenceOrganizationsUpdateManyWithoutConferencesNestedInput = {
    create?: XOR<ConferenceOrganizationsCreateWithoutConferencesInput, ConferenceOrganizationsUncheckedCreateWithoutConferencesInput> | ConferenceOrganizationsCreateWithoutConferencesInput[] | ConferenceOrganizationsUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceOrganizationsCreateOrConnectWithoutConferencesInput | ConferenceOrganizationsCreateOrConnectWithoutConferencesInput[]
    upsert?: ConferenceOrganizationsUpsertWithWhereUniqueWithoutConferencesInput | ConferenceOrganizationsUpsertWithWhereUniqueWithoutConferencesInput[]
    createMany?: ConferenceOrganizationsCreateManyConferencesInputEnvelope
    set?: ConferenceOrganizationsWhereUniqueInput | ConferenceOrganizationsWhereUniqueInput[]
    disconnect?: ConferenceOrganizationsWhereUniqueInput | ConferenceOrganizationsWhereUniqueInput[]
    delete?: ConferenceOrganizationsWhereUniqueInput | ConferenceOrganizationsWhereUniqueInput[]
    connect?: ConferenceOrganizationsWhereUniqueInput | ConferenceOrganizationsWhereUniqueInput[]
    update?: ConferenceOrganizationsUpdateWithWhereUniqueWithoutConferencesInput | ConferenceOrganizationsUpdateWithWhereUniqueWithoutConferencesInput[]
    updateMany?: ConferenceOrganizationsUpdateManyWithWhereWithoutConferencesInput | ConferenceOrganizationsUpdateManyWithWhereWithoutConferencesInput[]
    deleteMany?: ConferenceOrganizationsScalarWhereInput | ConferenceOrganizationsScalarWhereInput[]
  }

  export type ConferenceRanksUpdateManyWithoutConferencesNestedInput = {
    create?: XOR<ConferenceRanksCreateWithoutConferencesInput, ConferenceRanksUncheckedCreateWithoutConferencesInput> | ConferenceRanksCreateWithoutConferencesInput[] | ConferenceRanksUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceRanksCreateOrConnectWithoutConferencesInput | ConferenceRanksCreateOrConnectWithoutConferencesInput[]
    upsert?: ConferenceRanksUpsertWithWhereUniqueWithoutConferencesInput | ConferenceRanksUpsertWithWhereUniqueWithoutConferencesInput[]
    createMany?: ConferenceRanksCreateManyConferencesInputEnvelope
    set?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    disconnect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    delete?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    connect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    update?: ConferenceRanksUpdateWithWhereUniqueWithoutConferencesInput | ConferenceRanksUpdateWithWhereUniqueWithoutConferencesInput[]
    updateMany?: ConferenceRanksUpdateManyWithWhereWithoutConferencesInput | ConferenceRanksUpdateManyWithWhereWithoutConferencesInput[]
    deleteMany?: ConferenceRanksScalarWhereInput | ConferenceRanksScalarWhereInput[]
  }

  export type AdminsUpdateOneWithoutConferencesNestedInput = {
    create?: XOR<AdminsCreateWithoutConferencesInput, AdminsUncheckedCreateWithoutConferencesInput>
    connectOrCreate?: AdminsCreateOrConnectWithoutConferencesInput
    upsert?: AdminsUpsertWithoutConferencesInput
    disconnect?: AdminsWhereInput | boolean
    delete?: AdminsWhereInput | boolean
    connect?: AdminsWhereUniqueInput
    update?: XOR<XOR<AdminsUpdateToOneWithWhereWithoutConferencesInput, AdminsUpdateWithoutConferencesInput>, AdminsUncheckedUpdateWithoutConferencesInput>
  }

  export type UsersUpdateOneWithoutConferencesNestedInput = {
    create?: XOR<UsersCreateWithoutConferencesInput, UsersUncheckedCreateWithoutConferencesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutConferencesInput
    upsert?: UsersUpsertWithoutConferencesInput
    disconnect?: UsersWhereInput | boolean
    delete?: UsersWhereInput | boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutConferencesInput, UsersUpdateWithoutConferencesInput>, UsersUncheckedUpdateWithoutConferencesInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ConferenceBlacklistsUncheckedUpdateManyWithoutConferencesNestedInput = {
    create?: XOR<ConferenceBlacklistsCreateWithoutConferencesInput, ConferenceBlacklistsUncheckedCreateWithoutConferencesInput> | ConferenceBlacklistsCreateWithoutConferencesInput[] | ConferenceBlacklistsUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceBlacklistsCreateOrConnectWithoutConferencesInput | ConferenceBlacklistsCreateOrConnectWithoutConferencesInput[]
    upsert?: ConferenceBlacklistsUpsertWithWhereUniqueWithoutConferencesInput | ConferenceBlacklistsUpsertWithWhereUniqueWithoutConferencesInput[]
    createMany?: ConferenceBlacklistsCreateManyConferencesInputEnvelope
    set?: ConferenceBlacklistsWhereUniqueInput | ConferenceBlacklistsWhereUniqueInput[]
    disconnect?: ConferenceBlacklistsWhereUniqueInput | ConferenceBlacklistsWhereUniqueInput[]
    delete?: ConferenceBlacklistsWhereUniqueInput | ConferenceBlacklistsWhereUniqueInput[]
    connect?: ConferenceBlacklistsWhereUniqueInput | ConferenceBlacklistsWhereUniqueInput[]
    update?: ConferenceBlacklistsUpdateWithWhereUniqueWithoutConferencesInput | ConferenceBlacklistsUpdateWithWhereUniqueWithoutConferencesInput[]
    updateMany?: ConferenceBlacklistsUpdateManyWithWhereWithoutConferencesInput | ConferenceBlacklistsUpdateManyWithWhereWithoutConferencesInput[]
    deleteMany?: ConferenceBlacklistsScalarWhereInput | ConferenceBlacklistsScalarWhereInput[]
  }

  export type ConferenceCalendarsUncheckedUpdateManyWithoutConferencesNestedInput = {
    create?: XOR<ConferenceCalendarsCreateWithoutConferencesInput, ConferenceCalendarsUncheckedCreateWithoutConferencesInput> | ConferenceCalendarsCreateWithoutConferencesInput[] | ConferenceCalendarsUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceCalendarsCreateOrConnectWithoutConferencesInput | ConferenceCalendarsCreateOrConnectWithoutConferencesInput[]
    upsert?: ConferenceCalendarsUpsertWithWhereUniqueWithoutConferencesInput | ConferenceCalendarsUpsertWithWhereUniqueWithoutConferencesInput[]
    createMany?: ConferenceCalendarsCreateManyConferencesInputEnvelope
    set?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    disconnect?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    delete?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    connect?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    update?: ConferenceCalendarsUpdateWithWhereUniqueWithoutConferencesInput | ConferenceCalendarsUpdateWithWhereUniqueWithoutConferencesInput[]
    updateMany?: ConferenceCalendarsUpdateManyWithWhereWithoutConferencesInput | ConferenceCalendarsUpdateManyWithWhereWithoutConferencesInput[]
    deleteMany?: ConferenceCalendarsScalarWhereInput | ConferenceCalendarsScalarWhereInput[]
  }

  export type ConferenceCrawlJobsUncheckedUpdateManyWithoutConferencesNestedInput = {
    create?: XOR<ConferenceCrawlJobsCreateWithoutConferencesInput, ConferenceCrawlJobsUncheckedCreateWithoutConferencesInput> | ConferenceCrawlJobsCreateWithoutConferencesInput[] | ConferenceCrawlJobsUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceCrawlJobsCreateOrConnectWithoutConferencesInput | ConferenceCrawlJobsCreateOrConnectWithoutConferencesInput[]
    upsert?: ConferenceCrawlJobsUpsertWithWhereUniqueWithoutConferencesInput | ConferenceCrawlJobsUpsertWithWhereUniqueWithoutConferencesInput[]
    createMany?: ConferenceCrawlJobsCreateManyConferencesInputEnvelope
    set?: ConferenceCrawlJobsWhereUniqueInput | ConferenceCrawlJobsWhereUniqueInput[]
    disconnect?: ConferenceCrawlJobsWhereUniqueInput | ConferenceCrawlJobsWhereUniqueInput[]
    delete?: ConferenceCrawlJobsWhereUniqueInput | ConferenceCrawlJobsWhereUniqueInput[]
    connect?: ConferenceCrawlJobsWhereUniqueInput | ConferenceCrawlJobsWhereUniqueInput[]
    update?: ConferenceCrawlJobsUpdateWithWhereUniqueWithoutConferencesInput | ConferenceCrawlJobsUpdateWithWhereUniqueWithoutConferencesInput[]
    updateMany?: ConferenceCrawlJobsUpdateManyWithWhereWithoutConferencesInput | ConferenceCrawlJobsUpdateManyWithWhereWithoutConferencesInput[]
    deleteMany?: ConferenceCrawlJobsScalarWhereInput | ConferenceCrawlJobsScalarWhereInput[]
  }

  export type ConferenceFeedbacksUncheckedUpdateManyWithoutConferencesNestedInput = {
    create?: XOR<ConferenceFeedbacksCreateWithoutConferencesInput, ConferenceFeedbacksUncheckedCreateWithoutConferencesInput> | ConferenceFeedbacksCreateWithoutConferencesInput[] | ConferenceFeedbacksUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceFeedbacksCreateOrConnectWithoutConferencesInput | ConferenceFeedbacksCreateOrConnectWithoutConferencesInput[]
    upsert?: ConferenceFeedbacksUpsertWithWhereUniqueWithoutConferencesInput | ConferenceFeedbacksUpsertWithWhereUniqueWithoutConferencesInput[]
    createMany?: ConferenceFeedbacksCreateManyConferencesInputEnvelope
    set?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    disconnect?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    delete?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    connect?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    update?: ConferenceFeedbacksUpdateWithWhereUniqueWithoutConferencesInput | ConferenceFeedbacksUpdateWithWhereUniqueWithoutConferencesInput[]
    updateMany?: ConferenceFeedbacksUpdateManyWithWhereWithoutConferencesInput | ConferenceFeedbacksUpdateManyWithWhereWithoutConferencesInput[]
    deleteMany?: ConferenceFeedbacksScalarWhereInput | ConferenceFeedbacksScalarWhereInput[]
  }

  export type ConferenceFollowsUncheckedUpdateManyWithoutConferencesNestedInput = {
    create?: XOR<ConferenceFollowsCreateWithoutConferencesInput, ConferenceFollowsUncheckedCreateWithoutConferencesInput> | ConferenceFollowsCreateWithoutConferencesInput[] | ConferenceFollowsUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceFollowsCreateOrConnectWithoutConferencesInput | ConferenceFollowsCreateOrConnectWithoutConferencesInput[]
    upsert?: ConferenceFollowsUpsertWithWhereUniqueWithoutConferencesInput | ConferenceFollowsUpsertWithWhereUniqueWithoutConferencesInput[]
    createMany?: ConferenceFollowsCreateManyConferencesInputEnvelope
    set?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    disconnect?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    delete?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    connect?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    update?: ConferenceFollowsUpdateWithWhereUniqueWithoutConferencesInput | ConferenceFollowsUpdateWithWhereUniqueWithoutConferencesInput[]
    updateMany?: ConferenceFollowsUpdateManyWithWhereWithoutConferencesInput | ConferenceFollowsUpdateManyWithWhereWithoutConferencesInput[]
    deleteMany?: ConferenceFollowsScalarWhereInput | ConferenceFollowsScalarWhereInput[]
  }

  export type ConferenceLikesUncheckedUpdateManyWithoutConferencesNestedInput = {
    create?: XOR<ConferenceLikesCreateWithoutConferencesInput, ConferenceLikesUncheckedCreateWithoutConferencesInput> | ConferenceLikesCreateWithoutConferencesInput[] | ConferenceLikesUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceLikesCreateOrConnectWithoutConferencesInput | ConferenceLikesCreateOrConnectWithoutConferencesInput[]
    upsert?: ConferenceLikesUpsertWithWhereUniqueWithoutConferencesInput | ConferenceLikesUpsertWithWhereUniqueWithoutConferencesInput[]
    createMany?: ConferenceLikesCreateManyConferencesInputEnvelope
    set?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    disconnect?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    delete?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    connect?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    update?: ConferenceLikesUpdateWithWhereUniqueWithoutConferencesInput | ConferenceLikesUpdateWithWhereUniqueWithoutConferencesInput[]
    updateMany?: ConferenceLikesUpdateManyWithWhereWithoutConferencesInput | ConferenceLikesUpdateManyWithWhereWithoutConferencesInput[]
    deleteMany?: ConferenceLikesScalarWhereInput | ConferenceLikesScalarWhereInput[]
  }

  export type ConferenceOrganizationsUncheckedUpdateManyWithoutConferencesNestedInput = {
    create?: XOR<ConferenceOrganizationsCreateWithoutConferencesInput, ConferenceOrganizationsUncheckedCreateWithoutConferencesInput> | ConferenceOrganizationsCreateWithoutConferencesInput[] | ConferenceOrganizationsUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceOrganizationsCreateOrConnectWithoutConferencesInput | ConferenceOrganizationsCreateOrConnectWithoutConferencesInput[]
    upsert?: ConferenceOrganizationsUpsertWithWhereUniqueWithoutConferencesInput | ConferenceOrganizationsUpsertWithWhereUniqueWithoutConferencesInput[]
    createMany?: ConferenceOrganizationsCreateManyConferencesInputEnvelope
    set?: ConferenceOrganizationsWhereUniqueInput | ConferenceOrganizationsWhereUniqueInput[]
    disconnect?: ConferenceOrganizationsWhereUniqueInput | ConferenceOrganizationsWhereUniqueInput[]
    delete?: ConferenceOrganizationsWhereUniqueInput | ConferenceOrganizationsWhereUniqueInput[]
    connect?: ConferenceOrganizationsWhereUniqueInput | ConferenceOrganizationsWhereUniqueInput[]
    update?: ConferenceOrganizationsUpdateWithWhereUniqueWithoutConferencesInput | ConferenceOrganizationsUpdateWithWhereUniqueWithoutConferencesInput[]
    updateMany?: ConferenceOrganizationsUpdateManyWithWhereWithoutConferencesInput | ConferenceOrganizationsUpdateManyWithWhereWithoutConferencesInput[]
    deleteMany?: ConferenceOrganizationsScalarWhereInput | ConferenceOrganizationsScalarWhereInput[]
  }

  export type ConferenceRanksUncheckedUpdateManyWithoutConferencesNestedInput = {
    create?: XOR<ConferenceRanksCreateWithoutConferencesInput, ConferenceRanksUncheckedCreateWithoutConferencesInput> | ConferenceRanksCreateWithoutConferencesInput[] | ConferenceRanksUncheckedCreateWithoutConferencesInput[]
    connectOrCreate?: ConferenceRanksCreateOrConnectWithoutConferencesInput | ConferenceRanksCreateOrConnectWithoutConferencesInput[]
    upsert?: ConferenceRanksUpsertWithWhereUniqueWithoutConferencesInput | ConferenceRanksUpsertWithWhereUniqueWithoutConferencesInput[]
    createMany?: ConferenceRanksCreateManyConferencesInputEnvelope
    set?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    disconnect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    delete?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    connect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    update?: ConferenceRanksUpdateWithWhereUniqueWithoutConferencesInput | ConferenceRanksUpdateWithWhereUniqueWithoutConferencesInput[]
    updateMany?: ConferenceRanksUpdateManyWithWhereWithoutConferencesInput | ConferenceRanksUpdateManyWithWhereWithoutConferencesInput[]
    deleteMany?: ConferenceRanksScalarWhereInput | ConferenceRanksScalarWhereInput[]
  }

  export type ConferenceRanksCreateNestedManyWithoutFieldOfResearchsInput = {
    create?: XOR<ConferenceRanksCreateWithoutFieldOfResearchsInput, ConferenceRanksUncheckedCreateWithoutFieldOfResearchsInput> | ConferenceRanksCreateWithoutFieldOfResearchsInput[] | ConferenceRanksUncheckedCreateWithoutFieldOfResearchsInput[]
    connectOrCreate?: ConferenceRanksCreateOrConnectWithoutFieldOfResearchsInput | ConferenceRanksCreateOrConnectWithoutFieldOfResearchsInput[]
    createMany?: ConferenceRanksCreateManyFieldOfResearchsInputEnvelope
    connect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
  }

  export type JournalRanksCreateNestedManyWithoutFieldOfResearchsInput = {
    create?: XOR<JournalRanksCreateWithoutFieldOfResearchsInput, JournalRanksUncheckedCreateWithoutFieldOfResearchsInput> | JournalRanksCreateWithoutFieldOfResearchsInput[] | JournalRanksUncheckedCreateWithoutFieldOfResearchsInput[]
    connectOrCreate?: JournalRanksCreateOrConnectWithoutFieldOfResearchsInput | JournalRanksCreateOrConnectWithoutFieldOfResearchsInput[]
    createMany?: JournalRanksCreateManyFieldOfResearchsInputEnvelope
    connect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
  }

  export type ConferenceRanksUncheckedCreateNestedManyWithoutFieldOfResearchsInput = {
    create?: XOR<ConferenceRanksCreateWithoutFieldOfResearchsInput, ConferenceRanksUncheckedCreateWithoutFieldOfResearchsInput> | ConferenceRanksCreateWithoutFieldOfResearchsInput[] | ConferenceRanksUncheckedCreateWithoutFieldOfResearchsInput[]
    connectOrCreate?: ConferenceRanksCreateOrConnectWithoutFieldOfResearchsInput | ConferenceRanksCreateOrConnectWithoutFieldOfResearchsInput[]
    createMany?: ConferenceRanksCreateManyFieldOfResearchsInputEnvelope
    connect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
  }

  export type JournalRanksUncheckedCreateNestedManyWithoutFieldOfResearchsInput = {
    create?: XOR<JournalRanksCreateWithoutFieldOfResearchsInput, JournalRanksUncheckedCreateWithoutFieldOfResearchsInput> | JournalRanksCreateWithoutFieldOfResearchsInput[] | JournalRanksUncheckedCreateWithoutFieldOfResearchsInput[]
    connectOrCreate?: JournalRanksCreateOrConnectWithoutFieldOfResearchsInput | JournalRanksCreateOrConnectWithoutFieldOfResearchsInput[]
    createMany?: JournalRanksCreateManyFieldOfResearchsInputEnvelope
    connect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
  }

  export type ConferenceRanksUpdateManyWithoutFieldOfResearchsNestedInput = {
    create?: XOR<ConferenceRanksCreateWithoutFieldOfResearchsInput, ConferenceRanksUncheckedCreateWithoutFieldOfResearchsInput> | ConferenceRanksCreateWithoutFieldOfResearchsInput[] | ConferenceRanksUncheckedCreateWithoutFieldOfResearchsInput[]
    connectOrCreate?: ConferenceRanksCreateOrConnectWithoutFieldOfResearchsInput | ConferenceRanksCreateOrConnectWithoutFieldOfResearchsInput[]
    upsert?: ConferenceRanksUpsertWithWhereUniqueWithoutFieldOfResearchsInput | ConferenceRanksUpsertWithWhereUniqueWithoutFieldOfResearchsInput[]
    createMany?: ConferenceRanksCreateManyFieldOfResearchsInputEnvelope
    set?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    disconnect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    delete?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    connect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    update?: ConferenceRanksUpdateWithWhereUniqueWithoutFieldOfResearchsInput | ConferenceRanksUpdateWithWhereUniqueWithoutFieldOfResearchsInput[]
    updateMany?: ConferenceRanksUpdateManyWithWhereWithoutFieldOfResearchsInput | ConferenceRanksUpdateManyWithWhereWithoutFieldOfResearchsInput[]
    deleteMany?: ConferenceRanksScalarWhereInput | ConferenceRanksScalarWhereInput[]
  }

  export type JournalRanksUpdateManyWithoutFieldOfResearchsNestedInput = {
    create?: XOR<JournalRanksCreateWithoutFieldOfResearchsInput, JournalRanksUncheckedCreateWithoutFieldOfResearchsInput> | JournalRanksCreateWithoutFieldOfResearchsInput[] | JournalRanksUncheckedCreateWithoutFieldOfResearchsInput[]
    connectOrCreate?: JournalRanksCreateOrConnectWithoutFieldOfResearchsInput | JournalRanksCreateOrConnectWithoutFieldOfResearchsInput[]
    upsert?: JournalRanksUpsertWithWhereUniqueWithoutFieldOfResearchsInput | JournalRanksUpsertWithWhereUniqueWithoutFieldOfResearchsInput[]
    createMany?: JournalRanksCreateManyFieldOfResearchsInputEnvelope
    set?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    disconnect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    delete?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    connect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    update?: JournalRanksUpdateWithWhereUniqueWithoutFieldOfResearchsInput | JournalRanksUpdateWithWhereUniqueWithoutFieldOfResearchsInput[]
    updateMany?: JournalRanksUpdateManyWithWhereWithoutFieldOfResearchsInput | JournalRanksUpdateManyWithWhereWithoutFieldOfResearchsInput[]
    deleteMany?: JournalRanksScalarWhereInput | JournalRanksScalarWhereInput[]
  }

  export type ConferenceRanksUncheckedUpdateManyWithoutFieldOfResearchsNestedInput = {
    create?: XOR<ConferenceRanksCreateWithoutFieldOfResearchsInput, ConferenceRanksUncheckedCreateWithoutFieldOfResearchsInput> | ConferenceRanksCreateWithoutFieldOfResearchsInput[] | ConferenceRanksUncheckedCreateWithoutFieldOfResearchsInput[]
    connectOrCreate?: ConferenceRanksCreateOrConnectWithoutFieldOfResearchsInput | ConferenceRanksCreateOrConnectWithoutFieldOfResearchsInput[]
    upsert?: ConferenceRanksUpsertWithWhereUniqueWithoutFieldOfResearchsInput | ConferenceRanksUpsertWithWhereUniqueWithoutFieldOfResearchsInput[]
    createMany?: ConferenceRanksCreateManyFieldOfResearchsInputEnvelope
    set?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    disconnect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    delete?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    connect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    update?: ConferenceRanksUpdateWithWhereUniqueWithoutFieldOfResearchsInput | ConferenceRanksUpdateWithWhereUniqueWithoutFieldOfResearchsInput[]
    updateMany?: ConferenceRanksUpdateManyWithWhereWithoutFieldOfResearchsInput | ConferenceRanksUpdateManyWithWhereWithoutFieldOfResearchsInput[]
    deleteMany?: ConferenceRanksScalarWhereInput | ConferenceRanksScalarWhereInput[]
  }

  export type JournalRanksUncheckedUpdateManyWithoutFieldOfResearchsNestedInput = {
    create?: XOR<JournalRanksCreateWithoutFieldOfResearchsInput, JournalRanksUncheckedCreateWithoutFieldOfResearchsInput> | JournalRanksCreateWithoutFieldOfResearchsInput[] | JournalRanksUncheckedCreateWithoutFieldOfResearchsInput[]
    connectOrCreate?: JournalRanksCreateOrConnectWithoutFieldOfResearchsInput | JournalRanksCreateOrConnectWithoutFieldOfResearchsInput[]
    upsert?: JournalRanksUpsertWithWhereUniqueWithoutFieldOfResearchsInput | JournalRanksUpsertWithWhereUniqueWithoutFieldOfResearchsInput[]
    createMany?: JournalRanksCreateManyFieldOfResearchsInputEnvelope
    set?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    disconnect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    delete?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    connect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    update?: JournalRanksUpdateWithWhereUniqueWithoutFieldOfResearchsInput | JournalRanksUpdateWithWhereUniqueWithoutFieldOfResearchsInput[]
    updateMany?: JournalRanksUpdateManyWithWhereWithoutFieldOfResearchsInput | JournalRanksUpdateManyWithWhereWithoutFieldOfResearchsInput[]
    deleteMany?: JournalRanksScalarWhereInput | JournalRanksScalarWhereInput[]
  }

  export type JournalsCreateNestedOneWithoutJournalCrawlJobsInput = {
    create?: XOR<JournalsCreateWithoutJournalCrawlJobsInput, JournalsUncheckedCreateWithoutJournalCrawlJobsInput>
    connectOrCreate?: JournalsCreateOrConnectWithoutJournalCrawlJobsInput
    connect?: JournalsWhereUniqueInput
  }

  export type JournalsUpdateOneRequiredWithoutJournalCrawlJobsNestedInput = {
    create?: XOR<JournalsCreateWithoutJournalCrawlJobsInput, JournalsUncheckedCreateWithoutJournalCrawlJobsInput>
    connectOrCreate?: JournalsCreateOrConnectWithoutJournalCrawlJobsInput
    upsert?: JournalsUpsertWithoutJournalCrawlJobsInput
    connect?: JournalsWhereUniqueInput
    update?: XOR<XOR<JournalsUpdateToOneWithWhereWithoutJournalCrawlJobsInput, JournalsUpdateWithoutJournalCrawlJobsInput>, JournalsUncheckedUpdateWithoutJournalCrawlJobsInput>
  }

  export type JournalsCreateNestedOneWithoutJournalFollowsInput = {
    create?: XOR<JournalsCreateWithoutJournalFollowsInput, JournalsUncheckedCreateWithoutJournalFollowsInput>
    connectOrCreate?: JournalsCreateOrConnectWithoutJournalFollowsInput
    connect?: JournalsWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutJournalFollowsInput = {
    create?: XOR<UsersCreateWithoutJournalFollowsInput, UsersUncheckedCreateWithoutJournalFollowsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutJournalFollowsInput
    connect?: UsersWhereUniqueInput
  }

  export type JournalsUpdateOneRequiredWithoutJournalFollowsNestedInput = {
    create?: XOR<JournalsCreateWithoutJournalFollowsInput, JournalsUncheckedCreateWithoutJournalFollowsInput>
    connectOrCreate?: JournalsCreateOrConnectWithoutJournalFollowsInput
    upsert?: JournalsUpsertWithoutJournalFollowsInput
    connect?: JournalsWhereUniqueInput
    update?: XOR<XOR<JournalsUpdateToOneWithWhereWithoutJournalFollowsInput, JournalsUpdateWithoutJournalFollowsInput>, JournalsUncheckedUpdateWithoutJournalFollowsInput>
  }

  export type UsersUpdateOneRequiredWithoutJournalFollowsNestedInput = {
    create?: XOR<UsersCreateWithoutJournalFollowsInput, UsersUncheckedCreateWithoutJournalFollowsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutJournalFollowsInput
    upsert?: UsersUpsertWithoutJournalFollowsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutJournalFollowsInput, UsersUpdateWithoutJournalFollowsInput>, UsersUncheckedUpdateWithoutJournalFollowsInput>
  }

  export type JournalsCreateNestedOneWithoutJournalLikesInput = {
    create?: XOR<JournalsCreateWithoutJournalLikesInput, JournalsUncheckedCreateWithoutJournalLikesInput>
    connectOrCreate?: JournalsCreateOrConnectWithoutJournalLikesInput
    connect?: JournalsWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutJournalLikesInput = {
    create?: XOR<UsersCreateWithoutJournalLikesInput, UsersUncheckedCreateWithoutJournalLikesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutJournalLikesInput
    connect?: UsersWhereUniqueInput
  }

  export type JournalsUpdateOneRequiredWithoutJournalLikesNestedInput = {
    create?: XOR<JournalsCreateWithoutJournalLikesInput, JournalsUncheckedCreateWithoutJournalLikesInput>
    connectOrCreate?: JournalsCreateOrConnectWithoutJournalLikesInput
    upsert?: JournalsUpsertWithoutJournalLikesInput
    connect?: JournalsWhereUniqueInput
    update?: XOR<XOR<JournalsUpdateToOneWithWhereWithoutJournalLikesInput, JournalsUpdateWithoutJournalLikesInput>, JournalsUncheckedUpdateWithoutJournalLikesInput>
  }

  export type UsersUpdateOneRequiredWithoutJournalLikesNestedInput = {
    create?: XOR<UsersCreateWithoutJournalLikesInput, UsersUncheckedCreateWithoutJournalLikesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutJournalLikesInput
    upsert?: UsersUpsertWithoutJournalLikesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutJournalLikesInput, UsersUpdateWithoutJournalLikesInput>, UsersUncheckedUpdateWithoutJournalLikesInput>
  }

  export type FieldOfResearchsCreateNestedOneWithoutJournalRanksInput = {
    create?: XOR<FieldOfResearchsCreateWithoutJournalRanksInput, FieldOfResearchsUncheckedCreateWithoutJournalRanksInput>
    connectOrCreate?: FieldOfResearchsCreateOrConnectWithoutJournalRanksInput
    connect?: FieldOfResearchsWhereUniqueInput
  }

  export type JournalsCreateNestedOneWithoutJournalRanksInput = {
    create?: XOR<JournalsCreateWithoutJournalRanksInput, JournalsUncheckedCreateWithoutJournalRanksInput>
    connectOrCreate?: JournalsCreateOrConnectWithoutJournalRanksInput
    connect?: JournalsWhereUniqueInput
  }

  export type RanksCreateNestedOneWithoutJournalRanksInput = {
    create?: XOR<RanksCreateWithoutJournalRanksInput, RanksUncheckedCreateWithoutJournalRanksInput>
    connectOrCreate?: RanksCreateOrConnectWithoutJournalRanksInput
    connect?: RanksWhereUniqueInput
  }

  export type FieldOfResearchsUpdateOneRequiredWithoutJournalRanksNestedInput = {
    create?: XOR<FieldOfResearchsCreateWithoutJournalRanksInput, FieldOfResearchsUncheckedCreateWithoutJournalRanksInput>
    connectOrCreate?: FieldOfResearchsCreateOrConnectWithoutJournalRanksInput
    upsert?: FieldOfResearchsUpsertWithoutJournalRanksInput
    connect?: FieldOfResearchsWhereUniqueInput
    update?: XOR<XOR<FieldOfResearchsUpdateToOneWithWhereWithoutJournalRanksInput, FieldOfResearchsUpdateWithoutJournalRanksInput>, FieldOfResearchsUncheckedUpdateWithoutJournalRanksInput>
  }

  export type JournalsUpdateOneRequiredWithoutJournalRanksNestedInput = {
    create?: XOR<JournalsCreateWithoutJournalRanksInput, JournalsUncheckedCreateWithoutJournalRanksInput>
    connectOrCreate?: JournalsCreateOrConnectWithoutJournalRanksInput
    upsert?: JournalsUpsertWithoutJournalRanksInput
    connect?: JournalsWhereUniqueInput
    update?: XOR<XOR<JournalsUpdateToOneWithWhereWithoutJournalRanksInput, JournalsUpdateWithoutJournalRanksInput>, JournalsUncheckedUpdateWithoutJournalRanksInput>
  }

  export type RanksUpdateOneRequiredWithoutJournalRanksNestedInput = {
    create?: XOR<RanksCreateWithoutJournalRanksInput, RanksUncheckedCreateWithoutJournalRanksInput>
    connectOrCreate?: RanksCreateOrConnectWithoutJournalRanksInput
    upsert?: RanksUpsertWithoutJournalRanksInput
    connect?: RanksWhereUniqueInput
    update?: XOR<XOR<RanksUpdateToOneWithWhereWithoutJournalRanksInput, RanksUpdateWithoutJournalRanksInput>, RanksUncheckedUpdateWithoutJournalRanksInput>
  }

  export type JournalsCreateNestedOneWithoutJournalTopicsInput = {
    create?: XOR<JournalsCreateWithoutJournalTopicsInput, JournalsUncheckedCreateWithoutJournalTopicsInput>
    connectOrCreate?: JournalsCreateOrConnectWithoutJournalTopicsInput
    connect?: JournalsWhereUniqueInput
  }

  export type TopicsCreateNestedOneWithoutJournalTopicsInput = {
    create?: XOR<TopicsCreateWithoutJournalTopicsInput, TopicsUncheckedCreateWithoutJournalTopicsInput>
    connectOrCreate?: TopicsCreateOrConnectWithoutJournalTopicsInput
    connect?: TopicsWhereUniqueInput
  }

  export type JournalsUpdateOneRequiredWithoutJournalTopicsNestedInput = {
    create?: XOR<JournalsCreateWithoutJournalTopicsInput, JournalsUncheckedCreateWithoutJournalTopicsInput>
    connectOrCreate?: JournalsCreateOrConnectWithoutJournalTopicsInput
    upsert?: JournalsUpsertWithoutJournalTopicsInput
    connect?: JournalsWhereUniqueInput
    update?: XOR<XOR<JournalsUpdateToOneWithWhereWithoutJournalTopicsInput, JournalsUpdateWithoutJournalTopicsInput>, JournalsUncheckedUpdateWithoutJournalTopicsInput>
  }

  export type TopicsUpdateOneRequiredWithoutJournalTopicsNestedInput = {
    create?: XOR<TopicsCreateWithoutJournalTopicsInput, TopicsUncheckedCreateWithoutJournalTopicsInput>
    connectOrCreate?: TopicsCreateOrConnectWithoutJournalTopicsInput
    upsert?: TopicsUpsertWithoutJournalTopicsInput
    connect?: TopicsWhereUniqueInput
    update?: XOR<XOR<TopicsUpdateToOneWithWhereWithoutJournalTopicsInput, TopicsUpdateWithoutJournalTopicsInput>, TopicsUncheckedUpdateWithoutJournalTopicsInput>
  }

  export type JournalCrawlJobsCreateNestedManyWithoutJournalsInput = {
    create?: XOR<JournalCrawlJobsCreateWithoutJournalsInput, JournalCrawlJobsUncheckedCreateWithoutJournalsInput> | JournalCrawlJobsCreateWithoutJournalsInput[] | JournalCrawlJobsUncheckedCreateWithoutJournalsInput[]
    connectOrCreate?: JournalCrawlJobsCreateOrConnectWithoutJournalsInput | JournalCrawlJobsCreateOrConnectWithoutJournalsInput[]
    createMany?: JournalCrawlJobsCreateManyJournalsInputEnvelope
    connect?: JournalCrawlJobsWhereUniqueInput | JournalCrawlJobsWhereUniqueInput[]
  }

  export type JournalFollowsCreateNestedManyWithoutJournalsInput = {
    create?: XOR<JournalFollowsCreateWithoutJournalsInput, JournalFollowsUncheckedCreateWithoutJournalsInput> | JournalFollowsCreateWithoutJournalsInput[] | JournalFollowsUncheckedCreateWithoutJournalsInput[]
    connectOrCreate?: JournalFollowsCreateOrConnectWithoutJournalsInput | JournalFollowsCreateOrConnectWithoutJournalsInput[]
    createMany?: JournalFollowsCreateManyJournalsInputEnvelope
    connect?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
  }

  export type JournalLikesCreateNestedManyWithoutJournalsInput = {
    create?: XOR<JournalLikesCreateWithoutJournalsInput, JournalLikesUncheckedCreateWithoutJournalsInput> | JournalLikesCreateWithoutJournalsInput[] | JournalLikesUncheckedCreateWithoutJournalsInput[]
    connectOrCreate?: JournalLikesCreateOrConnectWithoutJournalsInput | JournalLikesCreateOrConnectWithoutJournalsInput[]
    createMany?: JournalLikesCreateManyJournalsInputEnvelope
    connect?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
  }

  export type JournalRanksCreateNestedManyWithoutJournalsInput = {
    create?: XOR<JournalRanksCreateWithoutJournalsInput, JournalRanksUncheckedCreateWithoutJournalsInput> | JournalRanksCreateWithoutJournalsInput[] | JournalRanksUncheckedCreateWithoutJournalsInput[]
    connectOrCreate?: JournalRanksCreateOrConnectWithoutJournalsInput | JournalRanksCreateOrConnectWithoutJournalsInput[]
    createMany?: JournalRanksCreateManyJournalsInputEnvelope
    connect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
  }

  export type JournalTopicsCreateNestedManyWithoutJournalsInput = {
    create?: XOR<JournalTopicsCreateWithoutJournalsInput, JournalTopicsUncheckedCreateWithoutJournalsInput> | JournalTopicsCreateWithoutJournalsInput[] | JournalTopicsUncheckedCreateWithoutJournalsInput[]
    connectOrCreate?: JournalTopicsCreateOrConnectWithoutJournalsInput | JournalTopicsCreateOrConnectWithoutJournalsInput[]
    createMany?: JournalTopicsCreateManyJournalsInputEnvelope
    connect?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
  }

  export type UsersCreateNestedOneWithoutJournalsInput = {
    create?: XOR<UsersCreateWithoutJournalsInput, UsersUncheckedCreateWithoutJournalsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutJournalsInput
    connect?: UsersWhereUniqueInput
  }

  export type JournalCrawlJobsUncheckedCreateNestedManyWithoutJournalsInput = {
    create?: XOR<JournalCrawlJobsCreateWithoutJournalsInput, JournalCrawlJobsUncheckedCreateWithoutJournalsInput> | JournalCrawlJobsCreateWithoutJournalsInput[] | JournalCrawlJobsUncheckedCreateWithoutJournalsInput[]
    connectOrCreate?: JournalCrawlJobsCreateOrConnectWithoutJournalsInput | JournalCrawlJobsCreateOrConnectWithoutJournalsInput[]
    createMany?: JournalCrawlJobsCreateManyJournalsInputEnvelope
    connect?: JournalCrawlJobsWhereUniqueInput | JournalCrawlJobsWhereUniqueInput[]
  }

  export type JournalFollowsUncheckedCreateNestedManyWithoutJournalsInput = {
    create?: XOR<JournalFollowsCreateWithoutJournalsInput, JournalFollowsUncheckedCreateWithoutJournalsInput> | JournalFollowsCreateWithoutJournalsInput[] | JournalFollowsUncheckedCreateWithoutJournalsInput[]
    connectOrCreate?: JournalFollowsCreateOrConnectWithoutJournalsInput | JournalFollowsCreateOrConnectWithoutJournalsInput[]
    createMany?: JournalFollowsCreateManyJournalsInputEnvelope
    connect?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
  }

  export type JournalLikesUncheckedCreateNestedManyWithoutJournalsInput = {
    create?: XOR<JournalLikesCreateWithoutJournalsInput, JournalLikesUncheckedCreateWithoutJournalsInput> | JournalLikesCreateWithoutJournalsInput[] | JournalLikesUncheckedCreateWithoutJournalsInput[]
    connectOrCreate?: JournalLikesCreateOrConnectWithoutJournalsInput | JournalLikesCreateOrConnectWithoutJournalsInput[]
    createMany?: JournalLikesCreateManyJournalsInputEnvelope
    connect?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
  }

  export type JournalRanksUncheckedCreateNestedManyWithoutJournalsInput = {
    create?: XOR<JournalRanksCreateWithoutJournalsInput, JournalRanksUncheckedCreateWithoutJournalsInput> | JournalRanksCreateWithoutJournalsInput[] | JournalRanksUncheckedCreateWithoutJournalsInput[]
    connectOrCreate?: JournalRanksCreateOrConnectWithoutJournalsInput | JournalRanksCreateOrConnectWithoutJournalsInput[]
    createMany?: JournalRanksCreateManyJournalsInputEnvelope
    connect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
  }

  export type JournalTopicsUncheckedCreateNestedManyWithoutJournalsInput = {
    create?: XOR<JournalTopicsCreateWithoutJournalsInput, JournalTopicsUncheckedCreateWithoutJournalsInput> | JournalTopicsCreateWithoutJournalsInput[] | JournalTopicsUncheckedCreateWithoutJournalsInput[]
    connectOrCreate?: JournalTopicsCreateOrConnectWithoutJournalsInput | JournalTopicsCreateOrConnectWithoutJournalsInput[]
    createMany?: JournalTopicsCreateManyJournalsInputEnvelope
    connect?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
  }

  export type JournalCrawlJobsUpdateManyWithoutJournalsNestedInput = {
    create?: XOR<JournalCrawlJobsCreateWithoutJournalsInput, JournalCrawlJobsUncheckedCreateWithoutJournalsInput> | JournalCrawlJobsCreateWithoutJournalsInput[] | JournalCrawlJobsUncheckedCreateWithoutJournalsInput[]
    connectOrCreate?: JournalCrawlJobsCreateOrConnectWithoutJournalsInput | JournalCrawlJobsCreateOrConnectWithoutJournalsInput[]
    upsert?: JournalCrawlJobsUpsertWithWhereUniqueWithoutJournalsInput | JournalCrawlJobsUpsertWithWhereUniqueWithoutJournalsInput[]
    createMany?: JournalCrawlJobsCreateManyJournalsInputEnvelope
    set?: JournalCrawlJobsWhereUniqueInput | JournalCrawlJobsWhereUniqueInput[]
    disconnect?: JournalCrawlJobsWhereUniqueInput | JournalCrawlJobsWhereUniqueInput[]
    delete?: JournalCrawlJobsWhereUniqueInput | JournalCrawlJobsWhereUniqueInput[]
    connect?: JournalCrawlJobsWhereUniqueInput | JournalCrawlJobsWhereUniqueInput[]
    update?: JournalCrawlJobsUpdateWithWhereUniqueWithoutJournalsInput | JournalCrawlJobsUpdateWithWhereUniqueWithoutJournalsInput[]
    updateMany?: JournalCrawlJobsUpdateManyWithWhereWithoutJournalsInput | JournalCrawlJobsUpdateManyWithWhereWithoutJournalsInput[]
    deleteMany?: JournalCrawlJobsScalarWhereInput | JournalCrawlJobsScalarWhereInput[]
  }

  export type JournalFollowsUpdateManyWithoutJournalsNestedInput = {
    create?: XOR<JournalFollowsCreateWithoutJournalsInput, JournalFollowsUncheckedCreateWithoutJournalsInput> | JournalFollowsCreateWithoutJournalsInput[] | JournalFollowsUncheckedCreateWithoutJournalsInput[]
    connectOrCreate?: JournalFollowsCreateOrConnectWithoutJournalsInput | JournalFollowsCreateOrConnectWithoutJournalsInput[]
    upsert?: JournalFollowsUpsertWithWhereUniqueWithoutJournalsInput | JournalFollowsUpsertWithWhereUniqueWithoutJournalsInput[]
    createMany?: JournalFollowsCreateManyJournalsInputEnvelope
    set?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    disconnect?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    delete?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    connect?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    update?: JournalFollowsUpdateWithWhereUniqueWithoutJournalsInput | JournalFollowsUpdateWithWhereUniqueWithoutJournalsInput[]
    updateMany?: JournalFollowsUpdateManyWithWhereWithoutJournalsInput | JournalFollowsUpdateManyWithWhereWithoutJournalsInput[]
    deleteMany?: JournalFollowsScalarWhereInput | JournalFollowsScalarWhereInput[]
  }

  export type JournalLikesUpdateManyWithoutJournalsNestedInput = {
    create?: XOR<JournalLikesCreateWithoutJournalsInput, JournalLikesUncheckedCreateWithoutJournalsInput> | JournalLikesCreateWithoutJournalsInput[] | JournalLikesUncheckedCreateWithoutJournalsInput[]
    connectOrCreate?: JournalLikesCreateOrConnectWithoutJournalsInput | JournalLikesCreateOrConnectWithoutJournalsInput[]
    upsert?: JournalLikesUpsertWithWhereUniqueWithoutJournalsInput | JournalLikesUpsertWithWhereUniqueWithoutJournalsInput[]
    createMany?: JournalLikesCreateManyJournalsInputEnvelope
    set?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    disconnect?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    delete?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    connect?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    update?: JournalLikesUpdateWithWhereUniqueWithoutJournalsInput | JournalLikesUpdateWithWhereUniqueWithoutJournalsInput[]
    updateMany?: JournalLikesUpdateManyWithWhereWithoutJournalsInput | JournalLikesUpdateManyWithWhereWithoutJournalsInput[]
    deleteMany?: JournalLikesScalarWhereInput | JournalLikesScalarWhereInput[]
  }

  export type JournalRanksUpdateManyWithoutJournalsNestedInput = {
    create?: XOR<JournalRanksCreateWithoutJournalsInput, JournalRanksUncheckedCreateWithoutJournalsInput> | JournalRanksCreateWithoutJournalsInput[] | JournalRanksUncheckedCreateWithoutJournalsInput[]
    connectOrCreate?: JournalRanksCreateOrConnectWithoutJournalsInput | JournalRanksCreateOrConnectWithoutJournalsInput[]
    upsert?: JournalRanksUpsertWithWhereUniqueWithoutJournalsInput | JournalRanksUpsertWithWhereUniqueWithoutJournalsInput[]
    createMany?: JournalRanksCreateManyJournalsInputEnvelope
    set?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    disconnect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    delete?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    connect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    update?: JournalRanksUpdateWithWhereUniqueWithoutJournalsInput | JournalRanksUpdateWithWhereUniqueWithoutJournalsInput[]
    updateMany?: JournalRanksUpdateManyWithWhereWithoutJournalsInput | JournalRanksUpdateManyWithWhereWithoutJournalsInput[]
    deleteMany?: JournalRanksScalarWhereInput | JournalRanksScalarWhereInput[]
  }

  export type JournalTopicsUpdateManyWithoutJournalsNestedInput = {
    create?: XOR<JournalTopicsCreateWithoutJournalsInput, JournalTopicsUncheckedCreateWithoutJournalsInput> | JournalTopicsCreateWithoutJournalsInput[] | JournalTopicsUncheckedCreateWithoutJournalsInput[]
    connectOrCreate?: JournalTopicsCreateOrConnectWithoutJournalsInput | JournalTopicsCreateOrConnectWithoutJournalsInput[]
    upsert?: JournalTopicsUpsertWithWhereUniqueWithoutJournalsInput | JournalTopicsUpsertWithWhereUniqueWithoutJournalsInput[]
    createMany?: JournalTopicsCreateManyJournalsInputEnvelope
    set?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    disconnect?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    delete?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    connect?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    update?: JournalTopicsUpdateWithWhereUniqueWithoutJournalsInput | JournalTopicsUpdateWithWhereUniqueWithoutJournalsInput[]
    updateMany?: JournalTopicsUpdateManyWithWhereWithoutJournalsInput | JournalTopicsUpdateManyWithWhereWithoutJournalsInput[]
    deleteMany?: JournalTopicsScalarWhereInput | JournalTopicsScalarWhereInput[]
  }

  export type UsersUpdateOneRequiredWithoutJournalsNestedInput = {
    create?: XOR<UsersCreateWithoutJournalsInput, UsersUncheckedCreateWithoutJournalsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutJournalsInput
    upsert?: UsersUpsertWithoutJournalsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutJournalsInput, UsersUpdateWithoutJournalsInput>, UsersUncheckedUpdateWithoutJournalsInput>
  }

  export type JournalCrawlJobsUncheckedUpdateManyWithoutJournalsNestedInput = {
    create?: XOR<JournalCrawlJobsCreateWithoutJournalsInput, JournalCrawlJobsUncheckedCreateWithoutJournalsInput> | JournalCrawlJobsCreateWithoutJournalsInput[] | JournalCrawlJobsUncheckedCreateWithoutJournalsInput[]
    connectOrCreate?: JournalCrawlJobsCreateOrConnectWithoutJournalsInput | JournalCrawlJobsCreateOrConnectWithoutJournalsInput[]
    upsert?: JournalCrawlJobsUpsertWithWhereUniqueWithoutJournalsInput | JournalCrawlJobsUpsertWithWhereUniqueWithoutJournalsInput[]
    createMany?: JournalCrawlJobsCreateManyJournalsInputEnvelope
    set?: JournalCrawlJobsWhereUniqueInput | JournalCrawlJobsWhereUniqueInput[]
    disconnect?: JournalCrawlJobsWhereUniqueInput | JournalCrawlJobsWhereUniqueInput[]
    delete?: JournalCrawlJobsWhereUniqueInput | JournalCrawlJobsWhereUniqueInput[]
    connect?: JournalCrawlJobsWhereUniqueInput | JournalCrawlJobsWhereUniqueInput[]
    update?: JournalCrawlJobsUpdateWithWhereUniqueWithoutJournalsInput | JournalCrawlJobsUpdateWithWhereUniqueWithoutJournalsInput[]
    updateMany?: JournalCrawlJobsUpdateManyWithWhereWithoutJournalsInput | JournalCrawlJobsUpdateManyWithWhereWithoutJournalsInput[]
    deleteMany?: JournalCrawlJobsScalarWhereInput | JournalCrawlJobsScalarWhereInput[]
  }

  export type JournalFollowsUncheckedUpdateManyWithoutJournalsNestedInput = {
    create?: XOR<JournalFollowsCreateWithoutJournalsInput, JournalFollowsUncheckedCreateWithoutJournalsInput> | JournalFollowsCreateWithoutJournalsInput[] | JournalFollowsUncheckedCreateWithoutJournalsInput[]
    connectOrCreate?: JournalFollowsCreateOrConnectWithoutJournalsInput | JournalFollowsCreateOrConnectWithoutJournalsInput[]
    upsert?: JournalFollowsUpsertWithWhereUniqueWithoutJournalsInput | JournalFollowsUpsertWithWhereUniqueWithoutJournalsInput[]
    createMany?: JournalFollowsCreateManyJournalsInputEnvelope
    set?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    disconnect?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    delete?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    connect?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    update?: JournalFollowsUpdateWithWhereUniqueWithoutJournalsInput | JournalFollowsUpdateWithWhereUniqueWithoutJournalsInput[]
    updateMany?: JournalFollowsUpdateManyWithWhereWithoutJournalsInput | JournalFollowsUpdateManyWithWhereWithoutJournalsInput[]
    deleteMany?: JournalFollowsScalarWhereInput | JournalFollowsScalarWhereInput[]
  }

  export type JournalLikesUncheckedUpdateManyWithoutJournalsNestedInput = {
    create?: XOR<JournalLikesCreateWithoutJournalsInput, JournalLikesUncheckedCreateWithoutJournalsInput> | JournalLikesCreateWithoutJournalsInput[] | JournalLikesUncheckedCreateWithoutJournalsInput[]
    connectOrCreate?: JournalLikesCreateOrConnectWithoutJournalsInput | JournalLikesCreateOrConnectWithoutJournalsInput[]
    upsert?: JournalLikesUpsertWithWhereUniqueWithoutJournalsInput | JournalLikesUpsertWithWhereUniqueWithoutJournalsInput[]
    createMany?: JournalLikesCreateManyJournalsInputEnvelope
    set?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    disconnect?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    delete?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    connect?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    update?: JournalLikesUpdateWithWhereUniqueWithoutJournalsInput | JournalLikesUpdateWithWhereUniqueWithoutJournalsInput[]
    updateMany?: JournalLikesUpdateManyWithWhereWithoutJournalsInput | JournalLikesUpdateManyWithWhereWithoutJournalsInput[]
    deleteMany?: JournalLikesScalarWhereInput | JournalLikesScalarWhereInput[]
  }

  export type JournalRanksUncheckedUpdateManyWithoutJournalsNestedInput = {
    create?: XOR<JournalRanksCreateWithoutJournalsInput, JournalRanksUncheckedCreateWithoutJournalsInput> | JournalRanksCreateWithoutJournalsInput[] | JournalRanksUncheckedCreateWithoutJournalsInput[]
    connectOrCreate?: JournalRanksCreateOrConnectWithoutJournalsInput | JournalRanksCreateOrConnectWithoutJournalsInput[]
    upsert?: JournalRanksUpsertWithWhereUniqueWithoutJournalsInput | JournalRanksUpsertWithWhereUniqueWithoutJournalsInput[]
    createMany?: JournalRanksCreateManyJournalsInputEnvelope
    set?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    disconnect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    delete?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    connect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    update?: JournalRanksUpdateWithWhereUniqueWithoutJournalsInput | JournalRanksUpdateWithWhereUniqueWithoutJournalsInput[]
    updateMany?: JournalRanksUpdateManyWithWhereWithoutJournalsInput | JournalRanksUpdateManyWithWhereWithoutJournalsInput[]
    deleteMany?: JournalRanksScalarWhereInput | JournalRanksScalarWhereInput[]
  }

  export type JournalTopicsUncheckedUpdateManyWithoutJournalsNestedInput = {
    create?: XOR<JournalTopicsCreateWithoutJournalsInput, JournalTopicsUncheckedCreateWithoutJournalsInput> | JournalTopicsCreateWithoutJournalsInput[] | JournalTopicsUncheckedCreateWithoutJournalsInput[]
    connectOrCreate?: JournalTopicsCreateOrConnectWithoutJournalsInput | JournalTopicsCreateOrConnectWithoutJournalsInput[]
    upsert?: JournalTopicsUpsertWithWhereUniqueWithoutJournalsInput | JournalTopicsUpsertWithWhereUniqueWithoutJournalsInput[]
    createMany?: JournalTopicsCreateManyJournalsInputEnvelope
    set?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    disconnect?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    delete?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    connect?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    update?: JournalTopicsUpdateWithWhereUniqueWithoutJournalsInput | JournalTopicsUpdateWithWhereUniqueWithoutJournalsInput[]
    updateMany?: JournalTopicsUpdateManyWithWhereWithoutJournalsInput | JournalTopicsUpdateManyWithWhereWithoutJournalsInput[]
    deleteMany?: JournalTopicsScalarWhereInput | JournalTopicsScalarWhereInput[]
  }

  export type ConferenceOrganizationsCreateNestedOneWithoutLocationsInput = {
    create?: XOR<ConferenceOrganizationsCreateWithoutLocationsInput, ConferenceOrganizationsUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: ConferenceOrganizationsCreateOrConnectWithoutLocationsInput
    connect?: ConferenceOrganizationsWhereUniqueInput
  }

  export type ConferenceOrganizationsUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<ConferenceOrganizationsCreateWithoutLocationsInput, ConferenceOrganizationsUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: ConferenceOrganizationsCreateOrConnectWithoutLocationsInput
    upsert?: ConferenceOrganizationsUpsertWithoutLocationsInput
    connect?: ConferenceOrganizationsWhereUniqueInput
    update?: XOR<XOR<ConferenceOrganizationsUpdateToOneWithWhereWithoutLocationsInput, ConferenceOrganizationsUpdateWithoutLocationsInput>, ConferenceOrganizationsUncheckedUpdateWithoutLocationsInput>
  }

  export type NotificationsTypesCreateNestedOneWithoutNotificationSettingsInput = {
    create?: XOR<NotificationsTypesCreateWithoutNotificationSettingsInput, NotificationsTypesUncheckedCreateWithoutNotificationSettingsInput>
    connectOrCreate?: NotificationsTypesCreateOrConnectWithoutNotificationSettingsInput
    connect?: NotificationsTypesWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutNotificationSettingsInput = {
    create?: XOR<UsersCreateWithoutNotificationSettingsInput, UsersUncheckedCreateWithoutNotificationSettingsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutNotificationSettingsInput
    connect?: UsersWhereUniqueInput
  }

  export type NotificationsTypesUpdateOneRequiredWithoutNotificationSettingsNestedInput = {
    create?: XOR<NotificationsTypesCreateWithoutNotificationSettingsInput, NotificationsTypesUncheckedCreateWithoutNotificationSettingsInput>
    connectOrCreate?: NotificationsTypesCreateOrConnectWithoutNotificationSettingsInput
    upsert?: NotificationsTypesUpsertWithoutNotificationSettingsInput
    connect?: NotificationsTypesWhereUniqueInput
    update?: XOR<XOR<NotificationsTypesUpdateToOneWithWhereWithoutNotificationSettingsInput, NotificationsTypesUpdateWithoutNotificationSettingsInput>, NotificationsTypesUncheckedUpdateWithoutNotificationSettingsInput>
  }

  export type UsersUpdateOneRequiredWithoutNotificationSettingsNestedInput = {
    create?: XOR<UsersCreateWithoutNotificationSettingsInput, UsersUncheckedCreateWithoutNotificationSettingsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutNotificationSettingsInput
    upsert?: UsersUpsertWithoutNotificationSettingsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutNotificationSettingsInput, UsersUpdateWithoutNotificationSettingsInput>, UsersUncheckedUpdateWithoutNotificationSettingsInput>
  }

  export type NotificationsTypesCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<NotificationsTypesCreateWithoutNotificationsInput, NotificationsTypesUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: NotificationsTypesCreateOrConnectWithoutNotificationsInput
    connect?: NotificationsTypesWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UsersCreateWithoutNotificationsInput, UsersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutNotificationsInput
    connect?: UsersWhereUniqueInput
  }

  export type NotificationsTypesUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<NotificationsTypesCreateWithoutNotificationsInput, NotificationsTypesUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: NotificationsTypesCreateOrConnectWithoutNotificationsInput
    upsert?: NotificationsTypesUpsertWithoutNotificationsInput
    connect?: NotificationsTypesWhereUniqueInput
    update?: XOR<XOR<NotificationsTypesUpdateToOneWithWhereWithoutNotificationsInput, NotificationsTypesUpdateWithoutNotificationsInput>, NotificationsTypesUncheckedUpdateWithoutNotificationsInput>
  }

  export type UsersUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UsersCreateWithoutNotificationsInput, UsersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutNotificationsInput
    upsert?: UsersUpsertWithoutNotificationsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutNotificationsInput, UsersUpdateWithoutNotificationsInput>, UsersUncheckedUpdateWithoutNotificationsInput>
  }

  export type NotificationSettingsCreateNestedManyWithoutNotificationsTypesInput = {
    create?: XOR<NotificationSettingsCreateWithoutNotificationsTypesInput, NotificationSettingsUncheckedCreateWithoutNotificationsTypesInput> | NotificationSettingsCreateWithoutNotificationsTypesInput[] | NotificationSettingsUncheckedCreateWithoutNotificationsTypesInput[]
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutNotificationsTypesInput | NotificationSettingsCreateOrConnectWithoutNotificationsTypesInput[]
    createMany?: NotificationSettingsCreateManyNotificationsTypesInputEnvelope
    connect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
  }

  export type NotificationsCreateNestedManyWithoutNotificationsTypesInput = {
    create?: XOR<NotificationsCreateWithoutNotificationsTypesInput, NotificationsUncheckedCreateWithoutNotificationsTypesInput> | NotificationsCreateWithoutNotificationsTypesInput[] | NotificationsUncheckedCreateWithoutNotificationsTypesInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutNotificationsTypesInput | NotificationsCreateOrConnectWithoutNotificationsTypesInput[]
    createMany?: NotificationsCreateManyNotificationsTypesInputEnvelope
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
  }

  export type NotificationSettingsUncheckedCreateNestedManyWithoutNotificationsTypesInput = {
    create?: XOR<NotificationSettingsCreateWithoutNotificationsTypesInput, NotificationSettingsUncheckedCreateWithoutNotificationsTypesInput> | NotificationSettingsCreateWithoutNotificationsTypesInput[] | NotificationSettingsUncheckedCreateWithoutNotificationsTypesInput[]
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutNotificationsTypesInput | NotificationSettingsCreateOrConnectWithoutNotificationsTypesInput[]
    createMany?: NotificationSettingsCreateManyNotificationsTypesInputEnvelope
    connect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
  }

  export type NotificationsUncheckedCreateNestedManyWithoutNotificationsTypesInput = {
    create?: XOR<NotificationsCreateWithoutNotificationsTypesInput, NotificationsUncheckedCreateWithoutNotificationsTypesInput> | NotificationsCreateWithoutNotificationsTypesInput[] | NotificationsUncheckedCreateWithoutNotificationsTypesInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutNotificationsTypesInput | NotificationsCreateOrConnectWithoutNotificationsTypesInput[]
    createMany?: NotificationsCreateManyNotificationsTypesInputEnvelope
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
  }

  export type NotificationSettingsUpdateManyWithoutNotificationsTypesNestedInput = {
    create?: XOR<NotificationSettingsCreateWithoutNotificationsTypesInput, NotificationSettingsUncheckedCreateWithoutNotificationsTypesInput> | NotificationSettingsCreateWithoutNotificationsTypesInput[] | NotificationSettingsUncheckedCreateWithoutNotificationsTypesInput[]
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutNotificationsTypesInput | NotificationSettingsCreateOrConnectWithoutNotificationsTypesInput[]
    upsert?: NotificationSettingsUpsertWithWhereUniqueWithoutNotificationsTypesInput | NotificationSettingsUpsertWithWhereUniqueWithoutNotificationsTypesInput[]
    createMany?: NotificationSettingsCreateManyNotificationsTypesInputEnvelope
    set?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    disconnect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    delete?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    connect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    update?: NotificationSettingsUpdateWithWhereUniqueWithoutNotificationsTypesInput | NotificationSettingsUpdateWithWhereUniqueWithoutNotificationsTypesInput[]
    updateMany?: NotificationSettingsUpdateManyWithWhereWithoutNotificationsTypesInput | NotificationSettingsUpdateManyWithWhereWithoutNotificationsTypesInput[]
    deleteMany?: NotificationSettingsScalarWhereInput | NotificationSettingsScalarWhereInput[]
  }

  export type NotificationsUpdateManyWithoutNotificationsTypesNestedInput = {
    create?: XOR<NotificationsCreateWithoutNotificationsTypesInput, NotificationsUncheckedCreateWithoutNotificationsTypesInput> | NotificationsCreateWithoutNotificationsTypesInput[] | NotificationsUncheckedCreateWithoutNotificationsTypesInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutNotificationsTypesInput | NotificationsCreateOrConnectWithoutNotificationsTypesInput[]
    upsert?: NotificationsUpsertWithWhereUniqueWithoutNotificationsTypesInput | NotificationsUpsertWithWhereUniqueWithoutNotificationsTypesInput[]
    createMany?: NotificationsCreateManyNotificationsTypesInputEnvelope
    set?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    disconnect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    delete?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    update?: NotificationsUpdateWithWhereUniqueWithoutNotificationsTypesInput | NotificationsUpdateWithWhereUniqueWithoutNotificationsTypesInput[]
    updateMany?: NotificationsUpdateManyWithWhereWithoutNotificationsTypesInput | NotificationsUpdateManyWithWhereWithoutNotificationsTypesInput[]
    deleteMany?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
  }

  export type NotificationSettingsUncheckedUpdateManyWithoutNotificationsTypesNestedInput = {
    create?: XOR<NotificationSettingsCreateWithoutNotificationsTypesInput, NotificationSettingsUncheckedCreateWithoutNotificationsTypesInput> | NotificationSettingsCreateWithoutNotificationsTypesInput[] | NotificationSettingsUncheckedCreateWithoutNotificationsTypesInput[]
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutNotificationsTypesInput | NotificationSettingsCreateOrConnectWithoutNotificationsTypesInput[]
    upsert?: NotificationSettingsUpsertWithWhereUniqueWithoutNotificationsTypesInput | NotificationSettingsUpsertWithWhereUniqueWithoutNotificationsTypesInput[]
    createMany?: NotificationSettingsCreateManyNotificationsTypesInputEnvelope
    set?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    disconnect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    delete?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    connect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    update?: NotificationSettingsUpdateWithWhereUniqueWithoutNotificationsTypesInput | NotificationSettingsUpdateWithWhereUniqueWithoutNotificationsTypesInput[]
    updateMany?: NotificationSettingsUpdateManyWithWhereWithoutNotificationsTypesInput | NotificationSettingsUpdateManyWithWhereWithoutNotificationsTypesInput[]
    deleteMany?: NotificationSettingsScalarWhereInput | NotificationSettingsScalarWhereInput[]
  }

  export type NotificationsUncheckedUpdateManyWithoutNotificationsTypesNestedInput = {
    create?: XOR<NotificationsCreateWithoutNotificationsTypesInput, NotificationsUncheckedCreateWithoutNotificationsTypesInput> | NotificationsCreateWithoutNotificationsTypesInput[] | NotificationsUncheckedCreateWithoutNotificationsTypesInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutNotificationsTypesInput | NotificationsCreateOrConnectWithoutNotificationsTypesInput[]
    upsert?: NotificationsUpsertWithWhereUniqueWithoutNotificationsTypesInput | NotificationsUpsertWithWhereUniqueWithoutNotificationsTypesInput[]
    createMany?: NotificationsCreateManyNotificationsTypesInputEnvelope
    set?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    disconnect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    delete?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    update?: NotificationsUpdateWithWhereUniqueWithoutNotificationsTypesInput | NotificationsUpdateWithWhereUniqueWithoutNotificationsTypesInput[]
    updateMany?: NotificationsUpdateManyWithWhereWithoutNotificationsTypesInput | NotificationsUpdateManyWithWhereWithoutNotificationsTypesInput[]
    deleteMany?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
  }

  export type ConferenceRanksCreateNestedManyWithoutRanksInput = {
    create?: XOR<ConferenceRanksCreateWithoutRanksInput, ConferenceRanksUncheckedCreateWithoutRanksInput> | ConferenceRanksCreateWithoutRanksInput[] | ConferenceRanksUncheckedCreateWithoutRanksInput[]
    connectOrCreate?: ConferenceRanksCreateOrConnectWithoutRanksInput | ConferenceRanksCreateOrConnectWithoutRanksInput[]
    createMany?: ConferenceRanksCreateManyRanksInputEnvelope
    connect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
  }

  export type JournalRanksCreateNestedManyWithoutRanksInput = {
    create?: XOR<JournalRanksCreateWithoutRanksInput, JournalRanksUncheckedCreateWithoutRanksInput> | JournalRanksCreateWithoutRanksInput[] | JournalRanksUncheckedCreateWithoutRanksInput[]
    connectOrCreate?: JournalRanksCreateOrConnectWithoutRanksInput | JournalRanksCreateOrConnectWithoutRanksInput[]
    createMany?: JournalRanksCreateManyRanksInputEnvelope
    connect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
  }

  export type SourcesCreateNestedOneWithoutRanksInput = {
    create?: XOR<SourcesCreateWithoutRanksInput, SourcesUncheckedCreateWithoutRanksInput>
    connectOrCreate?: SourcesCreateOrConnectWithoutRanksInput
    connect?: SourcesWhereUniqueInput
  }

  export type ConferenceRanksUncheckedCreateNestedManyWithoutRanksInput = {
    create?: XOR<ConferenceRanksCreateWithoutRanksInput, ConferenceRanksUncheckedCreateWithoutRanksInput> | ConferenceRanksCreateWithoutRanksInput[] | ConferenceRanksUncheckedCreateWithoutRanksInput[]
    connectOrCreate?: ConferenceRanksCreateOrConnectWithoutRanksInput | ConferenceRanksCreateOrConnectWithoutRanksInput[]
    createMany?: ConferenceRanksCreateManyRanksInputEnvelope
    connect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
  }

  export type JournalRanksUncheckedCreateNestedManyWithoutRanksInput = {
    create?: XOR<JournalRanksCreateWithoutRanksInput, JournalRanksUncheckedCreateWithoutRanksInput> | JournalRanksCreateWithoutRanksInput[] | JournalRanksUncheckedCreateWithoutRanksInput[]
    connectOrCreate?: JournalRanksCreateOrConnectWithoutRanksInput | JournalRanksCreateOrConnectWithoutRanksInput[]
    createMany?: JournalRanksCreateManyRanksInputEnvelope
    connect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
  }

  export type ConferenceRanksUpdateManyWithoutRanksNestedInput = {
    create?: XOR<ConferenceRanksCreateWithoutRanksInput, ConferenceRanksUncheckedCreateWithoutRanksInput> | ConferenceRanksCreateWithoutRanksInput[] | ConferenceRanksUncheckedCreateWithoutRanksInput[]
    connectOrCreate?: ConferenceRanksCreateOrConnectWithoutRanksInput | ConferenceRanksCreateOrConnectWithoutRanksInput[]
    upsert?: ConferenceRanksUpsertWithWhereUniqueWithoutRanksInput | ConferenceRanksUpsertWithWhereUniqueWithoutRanksInput[]
    createMany?: ConferenceRanksCreateManyRanksInputEnvelope
    set?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    disconnect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    delete?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    connect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    update?: ConferenceRanksUpdateWithWhereUniqueWithoutRanksInput | ConferenceRanksUpdateWithWhereUniqueWithoutRanksInput[]
    updateMany?: ConferenceRanksUpdateManyWithWhereWithoutRanksInput | ConferenceRanksUpdateManyWithWhereWithoutRanksInput[]
    deleteMany?: ConferenceRanksScalarWhereInput | ConferenceRanksScalarWhereInput[]
  }

  export type JournalRanksUpdateManyWithoutRanksNestedInput = {
    create?: XOR<JournalRanksCreateWithoutRanksInput, JournalRanksUncheckedCreateWithoutRanksInput> | JournalRanksCreateWithoutRanksInput[] | JournalRanksUncheckedCreateWithoutRanksInput[]
    connectOrCreate?: JournalRanksCreateOrConnectWithoutRanksInput | JournalRanksCreateOrConnectWithoutRanksInput[]
    upsert?: JournalRanksUpsertWithWhereUniqueWithoutRanksInput | JournalRanksUpsertWithWhereUniqueWithoutRanksInput[]
    createMany?: JournalRanksCreateManyRanksInputEnvelope
    set?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    disconnect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    delete?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    connect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    update?: JournalRanksUpdateWithWhereUniqueWithoutRanksInput | JournalRanksUpdateWithWhereUniqueWithoutRanksInput[]
    updateMany?: JournalRanksUpdateManyWithWhereWithoutRanksInput | JournalRanksUpdateManyWithWhereWithoutRanksInput[]
    deleteMany?: JournalRanksScalarWhereInput | JournalRanksScalarWhereInput[]
  }

  export type SourcesUpdateOneRequiredWithoutRanksNestedInput = {
    create?: XOR<SourcesCreateWithoutRanksInput, SourcesUncheckedCreateWithoutRanksInput>
    connectOrCreate?: SourcesCreateOrConnectWithoutRanksInput
    upsert?: SourcesUpsertWithoutRanksInput
    connect?: SourcesWhereUniqueInput
    update?: XOR<XOR<SourcesUpdateToOneWithWhereWithoutRanksInput, SourcesUpdateWithoutRanksInput>, SourcesUncheckedUpdateWithoutRanksInput>
  }

  export type ConferenceRanksUncheckedUpdateManyWithoutRanksNestedInput = {
    create?: XOR<ConferenceRanksCreateWithoutRanksInput, ConferenceRanksUncheckedCreateWithoutRanksInput> | ConferenceRanksCreateWithoutRanksInput[] | ConferenceRanksUncheckedCreateWithoutRanksInput[]
    connectOrCreate?: ConferenceRanksCreateOrConnectWithoutRanksInput | ConferenceRanksCreateOrConnectWithoutRanksInput[]
    upsert?: ConferenceRanksUpsertWithWhereUniqueWithoutRanksInput | ConferenceRanksUpsertWithWhereUniqueWithoutRanksInput[]
    createMany?: ConferenceRanksCreateManyRanksInputEnvelope
    set?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    disconnect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    delete?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    connect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    update?: ConferenceRanksUpdateWithWhereUniqueWithoutRanksInput | ConferenceRanksUpdateWithWhereUniqueWithoutRanksInput[]
    updateMany?: ConferenceRanksUpdateManyWithWhereWithoutRanksInput | ConferenceRanksUpdateManyWithWhereWithoutRanksInput[]
    deleteMany?: ConferenceRanksScalarWhereInput | ConferenceRanksScalarWhereInput[]
  }

  export type JournalRanksUncheckedUpdateManyWithoutRanksNestedInput = {
    create?: XOR<JournalRanksCreateWithoutRanksInput, JournalRanksUncheckedCreateWithoutRanksInput> | JournalRanksCreateWithoutRanksInput[] | JournalRanksUncheckedCreateWithoutRanksInput[]
    connectOrCreate?: JournalRanksCreateOrConnectWithoutRanksInput | JournalRanksCreateOrConnectWithoutRanksInput[]
    upsert?: JournalRanksUpsertWithWhereUniqueWithoutRanksInput | JournalRanksUpsertWithWhereUniqueWithoutRanksInput[]
    createMany?: JournalRanksCreateManyRanksInputEnvelope
    set?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    disconnect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    delete?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    connect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    update?: JournalRanksUpdateWithWhereUniqueWithoutRanksInput | JournalRanksUpdateWithWhereUniqueWithoutRanksInput[]
    updateMany?: JournalRanksUpdateManyWithWhereWithoutRanksInput | JournalRanksUpdateManyWithWhereWithoutRanksInput[]
    deleteMany?: JournalRanksScalarWhereInput | JournalRanksScalarWhereInput[]
  }

  export type RanksCreateNestedManyWithoutSourcesInput = {
    create?: XOR<RanksCreateWithoutSourcesInput, RanksUncheckedCreateWithoutSourcesInput> | RanksCreateWithoutSourcesInput[] | RanksUncheckedCreateWithoutSourcesInput[]
    connectOrCreate?: RanksCreateOrConnectWithoutSourcesInput | RanksCreateOrConnectWithoutSourcesInput[]
    createMany?: RanksCreateManySourcesInputEnvelope
    connect?: RanksWhereUniqueInput | RanksWhereUniqueInput[]
  }

  export type RanksUncheckedCreateNestedManyWithoutSourcesInput = {
    create?: XOR<RanksCreateWithoutSourcesInput, RanksUncheckedCreateWithoutSourcesInput> | RanksCreateWithoutSourcesInput[] | RanksUncheckedCreateWithoutSourcesInput[]
    connectOrCreate?: RanksCreateOrConnectWithoutSourcesInput | RanksCreateOrConnectWithoutSourcesInput[]
    createMany?: RanksCreateManySourcesInputEnvelope
    connect?: RanksWhereUniqueInput | RanksWhereUniqueInput[]
  }

  export type RanksUpdateManyWithoutSourcesNestedInput = {
    create?: XOR<RanksCreateWithoutSourcesInput, RanksUncheckedCreateWithoutSourcesInput> | RanksCreateWithoutSourcesInput[] | RanksUncheckedCreateWithoutSourcesInput[]
    connectOrCreate?: RanksCreateOrConnectWithoutSourcesInput | RanksCreateOrConnectWithoutSourcesInput[]
    upsert?: RanksUpsertWithWhereUniqueWithoutSourcesInput | RanksUpsertWithWhereUniqueWithoutSourcesInput[]
    createMany?: RanksCreateManySourcesInputEnvelope
    set?: RanksWhereUniqueInput | RanksWhereUniqueInput[]
    disconnect?: RanksWhereUniqueInput | RanksWhereUniqueInput[]
    delete?: RanksWhereUniqueInput | RanksWhereUniqueInput[]
    connect?: RanksWhereUniqueInput | RanksWhereUniqueInput[]
    update?: RanksUpdateWithWhereUniqueWithoutSourcesInput | RanksUpdateWithWhereUniqueWithoutSourcesInput[]
    updateMany?: RanksUpdateManyWithWhereWithoutSourcesInput | RanksUpdateManyWithWhereWithoutSourcesInput[]
    deleteMany?: RanksScalarWhereInput | RanksScalarWhereInput[]
  }

  export type RanksUncheckedUpdateManyWithoutSourcesNestedInput = {
    create?: XOR<RanksCreateWithoutSourcesInput, RanksUncheckedCreateWithoutSourcesInput> | RanksCreateWithoutSourcesInput[] | RanksUncheckedCreateWithoutSourcesInput[]
    connectOrCreate?: RanksCreateOrConnectWithoutSourcesInput | RanksCreateOrConnectWithoutSourcesInput[]
    upsert?: RanksUpsertWithWhereUniqueWithoutSourcesInput | RanksUpsertWithWhereUniqueWithoutSourcesInput[]
    createMany?: RanksCreateManySourcesInputEnvelope
    set?: RanksWhereUniqueInput | RanksWhereUniqueInput[]
    disconnect?: RanksWhereUniqueInput | RanksWhereUniqueInput[]
    delete?: RanksWhereUniqueInput | RanksWhereUniqueInput[]
    connect?: RanksWhereUniqueInput | RanksWhereUniqueInput[]
    update?: RanksUpdateWithWhereUniqueWithoutSourcesInput | RanksUpdateWithWhereUniqueWithoutSourcesInput[]
    updateMany?: RanksUpdateManyWithWhereWithoutSourcesInput | RanksUpdateManyWithWhereWithoutSourcesInput[]
    deleteMany?: RanksScalarWhereInput | RanksScalarWhereInput[]
  }

  export type TopicsCreateNestedOneWithoutTopicUserInterestedsInput = {
    create?: XOR<TopicsCreateWithoutTopicUserInterestedsInput, TopicsUncheckedCreateWithoutTopicUserInterestedsInput>
    connectOrCreate?: TopicsCreateOrConnectWithoutTopicUserInterestedsInput
    connect?: TopicsWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutTopicUserInterestedsInput = {
    create?: XOR<UsersCreateWithoutTopicUserInterestedsInput, UsersUncheckedCreateWithoutTopicUserInterestedsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutTopicUserInterestedsInput
    connect?: UsersWhereUniqueInput
  }

  export type TopicsUpdateOneRequiredWithoutTopicUserInterestedsNestedInput = {
    create?: XOR<TopicsCreateWithoutTopicUserInterestedsInput, TopicsUncheckedCreateWithoutTopicUserInterestedsInput>
    connectOrCreate?: TopicsCreateOrConnectWithoutTopicUserInterestedsInput
    upsert?: TopicsUpsertWithoutTopicUserInterestedsInput
    connect?: TopicsWhereUniqueInput
    update?: XOR<XOR<TopicsUpdateToOneWithWhereWithoutTopicUserInterestedsInput, TopicsUpdateWithoutTopicUserInterestedsInput>, TopicsUncheckedUpdateWithoutTopicUserInterestedsInput>
  }

  export type UsersUpdateOneRequiredWithoutTopicUserInterestedsNestedInput = {
    create?: XOR<UsersCreateWithoutTopicUserInterestedsInput, UsersUncheckedCreateWithoutTopicUserInterestedsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutTopicUserInterestedsInput
    upsert?: UsersUpsertWithoutTopicUserInterestedsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutTopicUserInterestedsInput, UsersUpdateWithoutTopicUserInterestedsInput>, UsersUncheckedUpdateWithoutTopicUserInterestedsInput>
  }

  export type ConferenceTopicsCreateNestedManyWithoutTopicsInput = {
    create?: XOR<ConferenceTopicsCreateWithoutTopicsInput, ConferenceTopicsUncheckedCreateWithoutTopicsInput> | ConferenceTopicsCreateWithoutTopicsInput[] | ConferenceTopicsUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: ConferenceTopicsCreateOrConnectWithoutTopicsInput | ConferenceTopicsCreateOrConnectWithoutTopicsInput[]
    createMany?: ConferenceTopicsCreateManyTopicsInputEnvelope
    connect?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
  }

  export type JournalTopicsCreateNestedManyWithoutTopicsInput = {
    create?: XOR<JournalTopicsCreateWithoutTopicsInput, JournalTopicsUncheckedCreateWithoutTopicsInput> | JournalTopicsCreateWithoutTopicsInput[] | JournalTopicsUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: JournalTopicsCreateOrConnectWithoutTopicsInput | JournalTopicsCreateOrConnectWithoutTopicsInput[]
    createMany?: JournalTopicsCreateManyTopicsInputEnvelope
    connect?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
  }

  export type TopicUserInterestedsCreateNestedManyWithoutTopicsInput = {
    create?: XOR<TopicUserInterestedsCreateWithoutTopicsInput, TopicUserInterestedsUncheckedCreateWithoutTopicsInput> | TopicUserInterestedsCreateWithoutTopicsInput[] | TopicUserInterestedsUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: TopicUserInterestedsCreateOrConnectWithoutTopicsInput | TopicUserInterestedsCreateOrConnectWithoutTopicsInput[]
    createMany?: TopicUserInterestedsCreateManyTopicsInputEnvelope
    connect?: TopicUserInterestedsWhereUniqueInput | TopicUserInterestedsWhereUniqueInput[]
  }

  export type ConferenceTopicsUncheckedCreateNestedManyWithoutTopicsInput = {
    create?: XOR<ConferenceTopicsCreateWithoutTopicsInput, ConferenceTopicsUncheckedCreateWithoutTopicsInput> | ConferenceTopicsCreateWithoutTopicsInput[] | ConferenceTopicsUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: ConferenceTopicsCreateOrConnectWithoutTopicsInput | ConferenceTopicsCreateOrConnectWithoutTopicsInput[]
    createMany?: ConferenceTopicsCreateManyTopicsInputEnvelope
    connect?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
  }

  export type JournalTopicsUncheckedCreateNestedManyWithoutTopicsInput = {
    create?: XOR<JournalTopicsCreateWithoutTopicsInput, JournalTopicsUncheckedCreateWithoutTopicsInput> | JournalTopicsCreateWithoutTopicsInput[] | JournalTopicsUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: JournalTopicsCreateOrConnectWithoutTopicsInput | JournalTopicsCreateOrConnectWithoutTopicsInput[]
    createMany?: JournalTopicsCreateManyTopicsInputEnvelope
    connect?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
  }

  export type TopicUserInterestedsUncheckedCreateNestedManyWithoutTopicsInput = {
    create?: XOR<TopicUserInterestedsCreateWithoutTopicsInput, TopicUserInterestedsUncheckedCreateWithoutTopicsInput> | TopicUserInterestedsCreateWithoutTopicsInput[] | TopicUserInterestedsUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: TopicUserInterestedsCreateOrConnectWithoutTopicsInput | TopicUserInterestedsCreateOrConnectWithoutTopicsInput[]
    createMany?: TopicUserInterestedsCreateManyTopicsInputEnvelope
    connect?: TopicUserInterestedsWhereUniqueInput | TopicUserInterestedsWhereUniqueInput[]
  }

  export type ConferenceTopicsUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<ConferenceTopicsCreateWithoutTopicsInput, ConferenceTopicsUncheckedCreateWithoutTopicsInput> | ConferenceTopicsCreateWithoutTopicsInput[] | ConferenceTopicsUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: ConferenceTopicsCreateOrConnectWithoutTopicsInput | ConferenceTopicsCreateOrConnectWithoutTopicsInput[]
    upsert?: ConferenceTopicsUpsertWithWhereUniqueWithoutTopicsInput | ConferenceTopicsUpsertWithWhereUniqueWithoutTopicsInput[]
    createMany?: ConferenceTopicsCreateManyTopicsInputEnvelope
    set?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    disconnect?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    delete?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    connect?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    update?: ConferenceTopicsUpdateWithWhereUniqueWithoutTopicsInput | ConferenceTopicsUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: ConferenceTopicsUpdateManyWithWhereWithoutTopicsInput | ConferenceTopicsUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: ConferenceTopicsScalarWhereInput | ConferenceTopicsScalarWhereInput[]
  }

  export type JournalTopicsUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<JournalTopicsCreateWithoutTopicsInput, JournalTopicsUncheckedCreateWithoutTopicsInput> | JournalTopicsCreateWithoutTopicsInput[] | JournalTopicsUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: JournalTopicsCreateOrConnectWithoutTopicsInput | JournalTopicsCreateOrConnectWithoutTopicsInput[]
    upsert?: JournalTopicsUpsertWithWhereUniqueWithoutTopicsInput | JournalTopicsUpsertWithWhereUniqueWithoutTopicsInput[]
    createMany?: JournalTopicsCreateManyTopicsInputEnvelope
    set?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    disconnect?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    delete?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    connect?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    update?: JournalTopicsUpdateWithWhereUniqueWithoutTopicsInput | JournalTopicsUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: JournalTopicsUpdateManyWithWhereWithoutTopicsInput | JournalTopicsUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: JournalTopicsScalarWhereInput | JournalTopicsScalarWhereInput[]
  }

  export type TopicUserInterestedsUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<TopicUserInterestedsCreateWithoutTopicsInput, TopicUserInterestedsUncheckedCreateWithoutTopicsInput> | TopicUserInterestedsCreateWithoutTopicsInput[] | TopicUserInterestedsUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: TopicUserInterestedsCreateOrConnectWithoutTopicsInput | TopicUserInterestedsCreateOrConnectWithoutTopicsInput[]
    upsert?: TopicUserInterestedsUpsertWithWhereUniqueWithoutTopicsInput | TopicUserInterestedsUpsertWithWhereUniqueWithoutTopicsInput[]
    createMany?: TopicUserInterestedsCreateManyTopicsInputEnvelope
    set?: TopicUserInterestedsWhereUniqueInput | TopicUserInterestedsWhereUniqueInput[]
    disconnect?: TopicUserInterestedsWhereUniqueInput | TopicUserInterestedsWhereUniqueInput[]
    delete?: TopicUserInterestedsWhereUniqueInput | TopicUserInterestedsWhereUniqueInput[]
    connect?: TopicUserInterestedsWhereUniqueInput | TopicUserInterestedsWhereUniqueInput[]
    update?: TopicUserInterestedsUpdateWithWhereUniqueWithoutTopicsInput | TopicUserInterestedsUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: TopicUserInterestedsUpdateManyWithWhereWithoutTopicsInput | TopicUserInterestedsUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: TopicUserInterestedsScalarWhereInput | TopicUserInterestedsScalarWhereInput[]
  }

  export type ConferenceTopicsUncheckedUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<ConferenceTopicsCreateWithoutTopicsInput, ConferenceTopicsUncheckedCreateWithoutTopicsInput> | ConferenceTopicsCreateWithoutTopicsInput[] | ConferenceTopicsUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: ConferenceTopicsCreateOrConnectWithoutTopicsInput | ConferenceTopicsCreateOrConnectWithoutTopicsInput[]
    upsert?: ConferenceTopicsUpsertWithWhereUniqueWithoutTopicsInput | ConferenceTopicsUpsertWithWhereUniqueWithoutTopicsInput[]
    createMany?: ConferenceTopicsCreateManyTopicsInputEnvelope
    set?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    disconnect?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    delete?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    connect?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    update?: ConferenceTopicsUpdateWithWhereUniqueWithoutTopicsInput | ConferenceTopicsUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: ConferenceTopicsUpdateManyWithWhereWithoutTopicsInput | ConferenceTopicsUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: ConferenceTopicsScalarWhereInput | ConferenceTopicsScalarWhereInput[]
  }

  export type JournalTopicsUncheckedUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<JournalTopicsCreateWithoutTopicsInput, JournalTopicsUncheckedCreateWithoutTopicsInput> | JournalTopicsCreateWithoutTopicsInput[] | JournalTopicsUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: JournalTopicsCreateOrConnectWithoutTopicsInput | JournalTopicsCreateOrConnectWithoutTopicsInput[]
    upsert?: JournalTopicsUpsertWithWhereUniqueWithoutTopicsInput | JournalTopicsUpsertWithWhereUniqueWithoutTopicsInput[]
    createMany?: JournalTopicsCreateManyTopicsInputEnvelope
    set?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    disconnect?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    delete?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    connect?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    update?: JournalTopicsUpdateWithWhereUniqueWithoutTopicsInput | JournalTopicsUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: JournalTopicsUpdateManyWithWhereWithoutTopicsInput | JournalTopicsUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: JournalTopicsScalarWhereInput | JournalTopicsScalarWhereInput[]
  }

  export type TopicUserInterestedsUncheckedUpdateManyWithoutTopicsNestedInput = {
    create?: XOR<TopicUserInterestedsCreateWithoutTopicsInput, TopicUserInterestedsUncheckedCreateWithoutTopicsInput> | TopicUserInterestedsCreateWithoutTopicsInput[] | TopicUserInterestedsUncheckedCreateWithoutTopicsInput[]
    connectOrCreate?: TopicUserInterestedsCreateOrConnectWithoutTopicsInput | TopicUserInterestedsCreateOrConnectWithoutTopicsInput[]
    upsert?: TopicUserInterestedsUpsertWithWhereUniqueWithoutTopicsInput | TopicUserInterestedsUpsertWithWhereUniqueWithoutTopicsInput[]
    createMany?: TopicUserInterestedsCreateManyTopicsInputEnvelope
    set?: TopicUserInterestedsWhereUniqueInput | TopicUserInterestedsWhereUniqueInput[]
    disconnect?: TopicUserInterestedsWhereUniqueInput | TopicUserInterestedsWhereUniqueInput[]
    delete?: TopicUserInterestedsWhereUniqueInput | TopicUserInterestedsWhereUniqueInput[]
    connect?: TopicUserInterestedsWhereUniqueInput | TopicUserInterestedsWhereUniqueInput[]
    update?: TopicUserInterestedsUpdateWithWhereUniqueWithoutTopicsInput | TopicUserInterestedsUpdateWithWhereUniqueWithoutTopicsInput[]
    updateMany?: TopicUserInterestedsUpdateManyWithWhereWithoutTopicsInput | TopicUserInterestedsUpdateManyWithWhereWithoutTopicsInput[]
    deleteMany?: TopicUserInterestedsScalarWhereInput | TopicUserInterestedsScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutUserVerificationInput = {
    create?: XOR<UsersCreateWithoutUserVerificationInput, UsersUncheckedCreateWithoutUserVerificationInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserVerificationInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutUserVerificationNestedInput = {
    create?: XOR<UsersCreateWithoutUserVerificationInput, UsersUncheckedCreateWithoutUserVerificationInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserVerificationInput
    upsert?: UsersUpsertWithoutUserVerificationInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutUserVerificationInput, UsersUpdateWithoutUserVerificationInput>, UsersUncheckedUpdateWithoutUserVerificationInput>
  }

  export type ConferenceBlacklistsCreateNestedManyWithoutUsersInput = {
    create?: XOR<ConferenceBlacklistsCreateWithoutUsersInput, ConferenceBlacklistsUncheckedCreateWithoutUsersInput> | ConferenceBlacklistsCreateWithoutUsersInput[] | ConferenceBlacklistsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConferenceBlacklistsCreateOrConnectWithoutUsersInput | ConferenceBlacklistsCreateOrConnectWithoutUsersInput[]
    createMany?: ConferenceBlacklistsCreateManyUsersInputEnvelope
    connect?: ConferenceBlacklistsWhereUniqueInput | ConferenceBlacklistsWhereUniqueInput[]
  }

  export type ConferenceCalendarsCreateNestedManyWithoutUsersInput = {
    create?: XOR<ConferenceCalendarsCreateWithoutUsersInput, ConferenceCalendarsUncheckedCreateWithoutUsersInput> | ConferenceCalendarsCreateWithoutUsersInput[] | ConferenceCalendarsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConferenceCalendarsCreateOrConnectWithoutUsersInput | ConferenceCalendarsCreateOrConnectWithoutUsersInput[]
    createMany?: ConferenceCalendarsCreateManyUsersInputEnvelope
    connect?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
  }

  export type ConferenceFeedbacksCreateNestedManyWithoutUsersInput = {
    create?: XOR<ConferenceFeedbacksCreateWithoutUsersInput, ConferenceFeedbacksUncheckedCreateWithoutUsersInput> | ConferenceFeedbacksCreateWithoutUsersInput[] | ConferenceFeedbacksUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConferenceFeedbacksCreateOrConnectWithoutUsersInput | ConferenceFeedbacksCreateOrConnectWithoutUsersInput[]
    createMany?: ConferenceFeedbacksCreateManyUsersInputEnvelope
    connect?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
  }

  export type ConferenceFollowsCreateNestedManyWithoutUsersInput = {
    create?: XOR<ConferenceFollowsCreateWithoutUsersInput, ConferenceFollowsUncheckedCreateWithoutUsersInput> | ConferenceFollowsCreateWithoutUsersInput[] | ConferenceFollowsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConferenceFollowsCreateOrConnectWithoutUsersInput | ConferenceFollowsCreateOrConnectWithoutUsersInput[]
    createMany?: ConferenceFollowsCreateManyUsersInputEnvelope
    connect?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
  }

  export type ConferenceLikesCreateNestedManyWithoutUsersInput = {
    create?: XOR<ConferenceLikesCreateWithoutUsersInput, ConferenceLikesUncheckedCreateWithoutUsersInput> | ConferenceLikesCreateWithoutUsersInput[] | ConferenceLikesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConferenceLikesCreateOrConnectWithoutUsersInput | ConferenceLikesCreateOrConnectWithoutUsersInput[]
    createMany?: ConferenceLikesCreateManyUsersInputEnvelope
    connect?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
  }

  export type ConferencesCreateNestedManyWithoutUsersInput = {
    create?: XOR<ConferencesCreateWithoutUsersInput, ConferencesUncheckedCreateWithoutUsersInput> | ConferencesCreateWithoutUsersInput[] | ConferencesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConferencesCreateOrConnectWithoutUsersInput | ConferencesCreateOrConnectWithoutUsersInput[]
    createMany?: ConferencesCreateManyUsersInputEnvelope
    connect?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
  }

  export type JournalFollowsCreateNestedManyWithoutUsersInput = {
    create?: XOR<JournalFollowsCreateWithoutUsersInput, JournalFollowsUncheckedCreateWithoutUsersInput> | JournalFollowsCreateWithoutUsersInput[] | JournalFollowsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: JournalFollowsCreateOrConnectWithoutUsersInput | JournalFollowsCreateOrConnectWithoutUsersInput[]
    createMany?: JournalFollowsCreateManyUsersInputEnvelope
    connect?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
  }

  export type JournalLikesCreateNestedManyWithoutUsersInput = {
    create?: XOR<JournalLikesCreateWithoutUsersInput, JournalLikesUncheckedCreateWithoutUsersInput> | JournalLikesCreateWithoutUsersInput[] | JournalLikesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: JournalLikesCreateOrConnectWithoutUsersInput | JournalLikesCreateOrConnectWithoutUsersInput[]
    createMany?: JournalLikesCreateManyUsersInputEnvelope
    connect?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
  }

  export type JournalsCreateNestedManyWithoutUsersInput = {
    create?: XOR<JournalsCreateWithoutUsersInput, JournalsUncheckedCreateWithoutUsersInput> | JournalsCreateWithoutUsersInput[] | JournalsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: JournalsCreateOrConnectWithoutUsersInput | JournalsCreateOrConnectWithoutUsersInput[]
    createMany?: JournalsCreateManyUsersInputEnvelope
    connect?: JournalsWhereUniqueInput | JournalsWhereUniqueInput[]
  }

  export type NotificationSettingsCreateNestedManyWithoutUsersInput = {
    create?: XOR<NotificationSettingsCreateWithoutUsersInput, NotificationSettingsUncheckedCreateWithoutUsersInput> | NotificationSettingsCreateWithoutUsersInput[] | NotificationSettingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUsersInput | NotificationSettingsCreateOrConnectWithoutUsersInput[]
    createMany?: NotificationSettingsCreateManyUsersInputEnvelope
    connect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
  }

  export type NotificationsCreateNestedManyWithoutUsersInput = {
    create?: XOR<NotificationsCreateWithoutUsersInput, NotificationsUncheckedCreateWithoutUsersInput> | NotificationsCreateWithoutUsersInput[] | NotificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUsersInput | NotificationsCreateOrConnectWithoutUsersInput[]
    createMany?: NotificationsCreateManyUsersInputEnvelope
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
  }

  export type TopicUserInterestedsCreateNestedManyWithoutUsersInput = {
    create?: XOR<TopicUserInterestedsCreateWithoutUsersInput, TopicUserInterestedsUncheckedCreateWithoutUsersInput> | TopicUserInterestedsCreateWithoutUsersInput[] | TopicUserInterestedsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: TopicUserInterestedsCreateOrConnectWithoutUsersInput | TopicUserInterestedsCreateOrConnectWithoutUsersInput[]
    createMany?: TopicUserInterestedsCreateManyUsersInputEnvelope
    connect?: TopicUserInterestedsWhereUniqueInput | TopicUserInterestedsWhereUniqueInput[]
  }

  export type UserVerificationCreateNestedManyWithoutUsersInput = {
    create?: XOR<UserVerificationCreateWithoutUsersInput, UserVerificationUncheckedCreateWithoutUsersInput> | UserVerificationCreateWithoutUsersInput[] | UserVerificationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserVerificationCreateOrConnectWithoutUsersInput | UserVerificationCreateOrConnectWithoutUsersInput[]
    createMany?: UserVerificationCreateManyUsersInputEnvelope
    connect?: UserVerificationWhereUniqueInput | UserVerificationWhereUniqueInput[]
  }

  export type ConferenceBlacklistsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ConferenceBlacklistsCreateWithoutUsersInput, ConferenceBlacklistsUncheckedCreateWithoutUsersInput> | ConferenceBlacklistsCreateWithoutUsersInput[] | ConferenceBlacklistsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConferenceBlacklistsCreateOrConnectWithoutUsersInput | ConferenceBlacklistsCreateOrConnectWithoutUsersInput[]
    createMany?: ConferenceBlacklistsCreateManyUsersInputEnvelope
    connect?: ConferenceBlacklistsWhereUniqueInput | ConferenceBlacklistsWhereUniqueInput[]
  }

  export type ConferenceCalendarsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ConferenceCalendarsCreateWithoutUsersInput, ConferenceCalendarsUncheckedCreateWithoutUsersInput> | ConferenceCalendarsCreateWithoutUsersInput[] | ConferenceCalendarsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConferenceCalendarsCreateOrConnectWithoutUsersInput | ConferenceCalendarsCreateOrConnectWithoutUsersInput[]
    createMany?: ConferenceCalendarsCreateManyUsersInputEnvelope
    connect?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
  }

  export type ConferenceFeedbacksUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ConferenceFeedbacksCreateWithoutUsersInput, ConferenceFeedbacksUncheckedCreateWithoutUsersInput> | ConferenceFeedbacksCreateWithoutUsersInput[] | ConferenceFeedbacksUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConferenceFeedbacksCreateOrConnectWithoutUsersInput | ConferenceFeedbacksCreateOrConnectWithoutUsersInput[]
    createMany?: ConferenceFeedbacksCreateManyUsersInputEnvelope
    connect?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
  }

  export type ConferenceFollowsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ConferenceFollowsCreateWithoutUsersInput, ConferenceFollowsUncheckedCreateWithoutUsersInput> | ConferenceFollowsCreateWithoutUsersInput[] | ConferenceFollowsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConferenceFollowsCreateOrConnectWithoutUsersInput | ConferenceFollowsCreateOrConnectWithoutUsersInput[]
    createMany?: ConferenceFollowsCreateManyUsersInputEnvelope
    connect?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
  }

  export type ConferenceLikesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ConferenceLikesCreateWithoutUsersInput, ConferenceLikesUncheckedCreateWithoutUsersInput> | ConferenceLikesCreateWithoutUsersInput[] | ConferenceLikesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConferenceLikesCreateOrConnectWithoutUsersInput | ConferenceLikesCreateOrConnectWithoutUsersInput[]
    createMany?: ConferenceLikesCreateManyUsersInputEnvelope
    connect?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
  }

  export type ConferencesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ConferencesCreateWithoutUsersInput, ConferencesUncheckedCreateWithoutUsersInput> | ConferencesCreateWithoutUsersInput[] | ConferencesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConferencesCreateOrConnectWithoutUsersInput | ConferencesCreateOrConnectWithoutUsersInput[]
    createMany?: ConferencesCreateManyUsersInputEnvelope
    connect?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
  }

  export type JournalFollowsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<JournalFollowsCreateWithoutUsersInput, JournalFollowsUncheckedCreateWithoutUsersInput> | JournalFollowsCreateWithoutUsersInput[] | JournalFollowsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: JournalFollowsCreateOrConnectWithoutUsersInput | JournalFollowsCreateOrConnectWithoutUsersInput[]
    createMany?: JournalFollowsCreateManyUsersInputEnvelope
    connect?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
  }

  export type JournalLikesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<JournalLikesCreateWithoutUsersInput, JournalLikesUncheckedCreateWithoutUsersInput> | JournalLikesCreateWithoutUsersInput[] | JournalLikesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: JournalLikesCreateOrConnectWithoutUsersInput | JournalLikesCreateOrConnectWithoutUsersInput[]
    createMany?: JournalLikesCreateManyUsersInputEnvelope
    connect?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
  }

  export type JournalsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<JournalsCreateWithoutUsersInput, JournalsUncheckedCreateWithoutUsersInput> | JournalsCreateWithoutUsersInput[] | JournalsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: JournalsCreateOrConnectWithoutUsersInput | JournalsCreateOrConnectWithoutUsersInput[]
    createMany?: JournalsCreateManyUsersInputEnvelope
    connect?: JournalsWhereUniqueInput | JournalsWhereUniqueInput[]
  }

  export type NotificationSettingsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<NotificationSettingsCreateWithoutUsersInput, NotificationSettingsUncheckedCreateWithoutUsersInput> | NotificationSettingsCreateWithoutUsersInput[] | NotificationSettingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUsersInput | NotificationSettingsCreateOrConnectWithoutUsersInput[]
    createMany?: NotificationSettingsCreateManyUsersInputEnvelope
    connect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
  }

  export type NotificationsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<NotificationsCreateWithoutUsersInput, NotificationsUncheckedCreateWithoutUsersInput> | NotificationsCreateWithoutUsersInput[] | NotificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUsersInput | NotificationsCreateOrConnectWithoutUsersInput[]
    createMany?: NotificationsCreateManyUsersInputEnvelope
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
  }

  export type TopicUserInterestedsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<TopicUserInterestedsCreateWithoutUsersInput, TopicUserInterestedsUncheckedCreateWithoutUsersInput> | TopicUserInterestedsCreateWithoutUsersInput[] | TopicUserInterestedsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: TopicUserInterestedsCreateOrConnectWithoutUsersInput | TopicUserInterestedsCreateOrConnectWithoutUsersInput[]
    createMany?: TopicUserInterestedsCreateManyUsersInputEnvelope
    connect?: TopicUserInterestedsWhereUniqueInput | TopicUserInterestedsWhereUniqueInput[]
  }

  export type UserVerificationUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<UserVerificationCreateWithoutUsersInput, UserVerificationUncheckedCreateWithoutUsersInput> | UserVerificationCreateWithoutUsersInput[] | UserVerificationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserVerificationCreateOrConnectWithoutUsersInput | UserVerificationCreateOrConnectWithoutUsersInput[]
    createMany?: UserVerificationCreateManyUsersInputEnvelope
    connect?: UserVerificationWhereUniqueInput | UserVerificationWhereUniqueInput[]
  }

  export type ConferenceBlacklistsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ConferenceBlacklistsCreateWithoutUsersInput, ConferenceBlacklistsUncheckedCreateWithoutUsersInput> | ConferenceBlacklistsCreateWithoutUsersInput[] | ConferenceBlacklistsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConferenceBlacklistsCreateOrConnectWithoutUsersInput | ConferenceBlacklistsCreateOrConnectWithoutUsersInput[]
    upsert?: ConferenceBlacklistsUpsertWithWhereUniqueWithoutUsersInput | ConferenceBlacklistsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ConferenceBlacklistsCreateManyUsersInputEnvelope
    set?: ConferenceBlacklistsWhereUniqueInput | ConferenceBlacklistsWhereUniqueInput[]
    disconnect?: ConferenceBlacklistsWhereUniqueInput | ConferenceBlacklistsWhereUniqueInput[]
    delete?: ConferenceBlacklistsWhereUniqueInput | ConferenceBlacklistsWhereUniqueInput[]
    connect?: ConferenceBlacklistsWhereUniqueInput | ConferenceBlacklistsWhereUniqueInput[]
    update?: ConferenceBlacklistsUpdateWithWhereUniqueWithoutUsersInput | ConferenceBlacklistsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ConferenceBlacklistsUpdateManyWithWhereWithoutUsersInput | ConferenceBlacklistsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ConferenceBlacklistsScalarWhereInput | ConferenceBlacklistsScalarWhereInput[]
  }

  export type ConferenceCalendarsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ConferenceCalendarsCreateWithoutUsersInput, ConferenceCalendarsUncheckedCreateWithoutUsersInput> | ConferenceCalendarsCreateWithoutUsersInput[] | ConferenceCalendarsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConferenceCalendarsCreateOrConnectWithoutUsersInput | ConferenceCalendarsCreateOrConnectWithoutUsersInput[]
    upsert?: ConferenceCalendarsUpsertWithWhereUniqueWithoutUsersInput | ConferenceCalendarsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ConferenceCalendarsCreateManyUsersInputEnvelope
    set?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    disconnect?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    delete?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    connect?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    update?: ConferenceCalendarsUpdateWithWhereUniqueWithoutUsersInput | ConferenceCalendarsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ConferenceCalendarsUpdateManyWithWhereWithoutUsersInput | ConferenceCalendarsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ConferenceCalendarsScalarWhereInput | ConferenceCalendarsScalarWhereInput[]
  }

  export type ConferenceFeedbacksUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ConferenceFeedbacksCreateWithoutUsersInput, ConferenceFeedbacksUncheckedCreateWithoutUsersInput> | ConferenceFeedbacksCreateWithoutUsersInput[] | ConferenceFeedbacksUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConferenceFeedbacksCreateOrConnectWithoutUsersInput | ConferenceFeedbacksCreateOrConnectWithoutUsersInput[]
    upsert?: ConferenceFeedbacksUpsertWithWhereUniqueWithoutUsersInput | ConferenceFeedbacksUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ConferenceFeedbacksCreateManyUsersInputEnvelope
    set?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    disconnect?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    delete?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    connect?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    update?: ConferenceFeedbacksUpdateWithWhereUniqueWithoutUsersInput | ConferenceFeedbacksUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ConferenceFeedbacksUpdateManyWithWhereWithoutUsersInput | ConferenceFeedbacksUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ConferenceFeedbacksScalarWhereInput | ConferenceFeedbacksScalarWhereInput[]
  }

  export type ConferenceFollowsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ConferenceFollowsCreateWithoutUsersInput, ConferenceFollowsUncheckedCreateWithoutUsersInput> | ConferenceFollowsCreateWithoutUsersInput[] | ConferenceFollowsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConferenceFollowsCreateOrConnectWithoutUsersInput | ConferenceFollowsCreateOrConnectWithoutUsersInput[]
    upsert?: ConferenceFollowsUpsertWithWhereUniqueWithoutUsersInput | ConferenceFollowsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ConferenceFollowsCreateManyUsersInputEnvelope
    set?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    disconnect?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    delete?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    connect?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    update?: ConferenceFollowsUpdateWithWhereUniqueWithoutUsersInput | ConferenceFollowsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ConferenceFollowsUpdateManyWithWhereWithoutUsersInput | ConferenceFollowsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ConferenceFollowsScalarWhereInput | ConferenceFollowsScalarWhereInput[]
  }

  export type ConferenceLikesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ConferenceLikesCreateWithoutUsersInput, ConferenceLikesUncheckedCreateWithoutUsersInput> | ConferenceLikesCreateWithoutUsersInput[] | ConferenceLikesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConferenceLikesCreateOrConnectWithoutUsersInput | ConferenceLikesCreateOrConnectWithoutUsersInput[]
    upsert?: ConferenceLikesUpsertWithWhereUniqueWithoutUsersInput | ConferenceLikesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ConferenceLikesCreateManyUsersInputEnvelope
    set?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    disconnect?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    delete?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    connect?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    update?: ConferenceLikesUpdateWithWhereUniqueWithoutUsersInput | ConferenceLikesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ConferenceLikesUpdateManyWithWhereWithoutUsersInput | ConferenceLikesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ConferenceLikesScalarWhereInput | ConferenceLikesScalarWhereInput[]
  }

  export type ConferencesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ConferencesCreateWithoutUsersInput, ConferencesUncheckedCreateWithoutUsersInput> | ConferencesCreateWithoutUsersInput[] | ConferencesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConferencesCreateOrConnectWithoutUsersInput | ConferencesCreateOrConnectWithoutUsersInput[]
    upsert?: ConferencesUpsertWithWhereUniqueWithoutUsersInput | ConferencesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ConferencesCreateManyUsersInputEnvelope
    set?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
    disconnect?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
    delete?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
    connect?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
    update?: ConferencesUpdateWithWhereUniqueWithoutUsersInput | ConferencesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ConferencesUpdateManyWithWhereWithoutUsersInput | ConferencesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ConferencesScalarWhereInput | ConferencesScalarWhereInput[]
  }

  export type JournalFollowsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<JournalFollowsCreateWithoutUsersInput, JournalFollowsUncheckedCreateWithoutUsersInput> | JournalFollowsCreateWithoutUsersInput[] | JournalFollowsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: JournalFollowsCreateOrConnectWithoutUsersInput | JournalFollowsCreateOrConnectWithoutUsersInput[]
    upsert?: JournalFollowsUpsertWithWhereUniqueWithoutUsersInput | JournalFollowsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: JournalFollowsCreateManyUsersInputEnvelope
    set?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    disconnect?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    delete?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    connect?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    update?: JournalFollowsUpdateWithWhereUniqueWithoutUsersInput | JournalFollowsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: JournalFollowsUpdateManyWithWhereWithoutUsersInput | JournalFollowsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: JournalFollowsScalarWhereInput | JournalFollowsScalarWhereInput[]
  }

  export type JournalLikesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<JournalLikesCreateWithoutUsersInput, JournalLikesUncheckedCreateWithoutUsersInput> | JournalLikesCreateWithoutUsersInput[] | JournalLikesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: JournalLikesCreateOrConnectWithoutUsersInput | JournalLikesCreateOrConnectWithoutUsersInput[]
    upsert?: JournalLikesUpsertWithWhereUniqueWithoutUsersInput | JournalLikesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: JournalLikesCreateManyUsersInputEnvelope
    set?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    disconnect?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    delete?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    connect?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    update?: JournalLikesUpdateWithWhereUniqueWithoutUsersInput | JournalLikesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: JournalLikesUpdateManyWithWhereWithoutUsersInput | JournalLikesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: JournalLikesScalarWhereInput | JournalLikesScalarWhereInput[]
  }

  export type JournalsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<JournalsCreateWithoutUsersInput, JournalsUncheckedCreateWithoutUsersInput> | JournalsCreateWithoutUsersInput[] | JournalsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: JournalsCreateOrConnectWithoutUsersInput | JournalsCreateOrConnectWithoutUsersInput[]
    upsert?: JournalsUpsertWithWhereUniqueWithoutUsersInput | JournalsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: JournalsCreateManyUsersInputEnvelope
    set?: JournalsWhereUniqueInput | JournalsWhereUniqueInput[]
    disconnect?: JournalsWhereUniqueInput | JournalsWhereUniqueInput[]
    delete?: JournalsWhereUniqueInput | JournalsWhereUniqueInput[]
    connect?: JournalsWhereUniqueInput | JournalsWhereUniqueInput[]
    update?: JournalsUpdateWithWhereUniqueWithoutUsersInput | JournalsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: JournalsUpdateManyWithWhereWithoutUsersInput | JournalsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: JournalsScalarWhereInput | JournalsScalarWhereInput[]
  }

  export type NotificationSettingsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<NotificationSettingsCreateWithoutUsersInput, NotificationSettingsUncheckedCreateWithoutUsersInput> | NotificationSettingsCreateWithoutUsersInput[] | NotificationSettingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUsersInput | NotificationSettingsCreateOrConnectWithoutUsersInput[]
    upsert?: NotificationSettingsUpsertWithWhereUniqueWithoutUsersInput | NotificationSettingsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: NotificationSettingsCreateManyUsersInputEnvelope
    set?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    disconnect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    delete?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    connect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    update?: NotificationSettingsUpdateWithWhereUniqueWithoutUsersInput | NotificationSettingsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: NotificationSettingsUpdateManyWithWhereWithoutUsersInput | NotificationSettingsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: NotificationSettingsScalarWhereInput | NotificationSettingsScalarWhereInput[]
  }

  export type NotificationsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<NotificationsCreateWithoutUsersInput, NotificationsUncheckedCreateWithoutUsersInput> | NotificationsCreateWithoutUsersInput[] | NotificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUsersInput | NotificationsCreateOrConnectWithoutUsersInput[]
    upsert?: NotificationsUpsertWithWhereUniqueWithoutUsersInput | NotificationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: NotificationsCreateManyUsersInputEnvelope
    set?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    disconnect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    delete?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    update?: NotificationsUpdateWithWhereUniqueWithoutUsersInput | NotificationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: NotificationsUpdateManyWithWhereWithoutUsersInput | NotificationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
  }

  export type TopicUserInterestedsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<TopicUserInterestedsCreateWithoutUsersInput, TopicUserInterestedsUncheckedCreateWithoutUsersInput> | TopicUserInterestedsCreateWithoutUsersInput[] | TopicUserInterestedsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: TopicUserInterestedsCreateOrConnectWithoutUsersInput | TopicUserInterestedsCreateOrConnectWithoutUsersInput[]
    upsert?: TopicUserInterestedsUpsertWithWhereUniqueWithoutUsersInput | TopicUserInterestedsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: TopicUserInterestedsCreateManyUsersInputEnvelope
    set?: TopicUserInterestedsWhereUniqueInput | TopicUserInterestedsWhereUniqueInput[]
    disconnect?: TopicUserInterestedsWhereUniqueInput | TopicUserInterestedsWhereUniqueInput[]
    delete?: TopicUserInterestedsWhereUniqueInput | TopicUserInterestedsWhereUniqueInput[]
    connect?: TopicUserInterestedsWhereUniqueInput | TopicUserInterestedsWhereUniqueInput[]
    update?: TopicUserInterestedsUpdateWithWhereUniqueWithoutUsersInput | TopicUserInterestedsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: TopicUserInterestedsUpdateManyWithWhereWithoutUsersInput | TopicUserInterestedsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: TopicUserInterestedsScalarWhereInput | TopicUserInterestedsScalarWhereInput[]
  }

  export type UserVerificationUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UserVerificationCreateWithoutUsersInput, UserVerificationUncheckedCreateWithoutUsersInput> | UserVerificationCreateWithoutUsersInput[] | UserVerificationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserVerificationCreateOrConnectWithoutUsersInput | UserVerificationCreateOrConnectWithoutUsersInput[]
    upsert?: UserVerificationUpsertWithWhereUniqueWithoutUsersInput | UserVerificationUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: UserVerificationCreateManyUsersInputEnvelope
    set?: UserVerificationWhereUniqueInput | UserVerificationWhereUniqueInput[]
    disconnect?: UserVerificationWhereUniqueInput | UserVerificationWhereUniqueInput[]
    delete?: UserVerificationWhereUniqueInput | UserVerificationWhereUniqueInput[]
    connect?: UserVerificationWhereUniqueInput | UserVerificationWhereUniqueInput[]
    update?: UserVerificationUpdateWithWhereUniqueWithoutUsersInput | UserVerificationUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UserVerificationUpdateManyWithWhereWithoutUsersInput | UserVerificationUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UserVerificationScalarWhereInput | UserVerificationScalarWhereInput[]
  }

  export type ConferenceBlacklistsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ConferenceBlacklistsCreateWithoutUsersInput, ConferenceBlacklistsUncheckedCreateWithoutUsersInput> | ConferenceBlacklistsCreateWithoutUsersInput[] | ConferenceBlacklistsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConferenceBlacklistsCreateOrConnectWithoutUsersInput | ConferenceBlacklistsCreateOrConnectWithoutUsersInput[]
    upsert?: ConferenceBlacklistsUpsertWithWhereUniqueWithoutUsersInput | ConferenceBlacklistsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ConferenceBlacklistsCreateManyUsersInputEnvelope
    set?: ConferenceBlacklistsWhereUniqueInput | ConferenceBlacklistsWhereUniqueInput[]
    disconnect?: ConferenceBlacklistsWhereUniqueInput | ConferenceBlacklistsWhereUniqueInput[]
    delete?: ConferenceBlacklistsWhereUniqueInput | ConferenceBlacklistsWhereUniqueInput[]
    connect?: ConferenceBlacklistsWhereUniqueInput | ConferenceBlacklistsWhereUniqueInput[]
    update?: ConferenceBlacklistsUpdateWithWhereUniqueWithoutUsersInput | ConferenceBlacklistsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ConferenceBlacklistsUpdateManyWithWhereWithoutUsersInput | ConferenceBlacklistsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ConferenceBlacklistsScalarWhereInput | ConferenceBlacklistsScalarWhereInput[]
  }

  export type ConferenceCalendarsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ConferenceCalendarsCreateWithoutUsersInput, ConferenceCalendarsUncheckedCreateWithoutUsersInput> | ConferenceCalendarsCreateWithoutUsersInput[] | ConferenceCalendarsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConferenceCalendarsCreateOrConnectWithoutUsersInput | ConferenceCalendarsCreateOrConnectWithoutUsersInput[]
    upsert?: ConferenceCalendarsUpsertWithWhereUniqueWithoutUsersInput | ConferenceCalendarsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ConferenceCalendarsCreateManyUsersInputEnvelope
    set?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    disconnect?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    delete?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    connect?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    update?: ConferenceCalendarsUpdateWithWhereUniqueWithoutUsersInput | ConferenceCalendarsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ConferenceCalendarsUpdateManyWithWhereWithoutUsersInput | ConferenceCalendarsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ConferenceCalendarsScalarWhereInput | ConferenceCalendarsScalarWhereInput[]
  }

  export type ConferenceFeedbacksUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ConferenceFeedbacksCreateWithoutUsersInput, ConferenceFeedbacksUncheckedCreateWithoutUsersInput> | ConferenceFeedbacksCreateWithoutUsersInput[] | ConferenceFeedbacksUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConferenceFeedbacksCreateOrConnectWithoutUsersInput | ConferenceFeedbacksCreateOrConnectWithoutUsersInput[]
    upsert?: ConferenceFeedbacksUpsertWithWhereUniqueWithoutUsersInput | ConferenceFeedbacksUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ConferenceFeedbacksCreateManyUsersInputEnvelope
    set?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    disconnect?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    delete?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    connect?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    update?: ConferenceFeedbacksUpdateWithWhereUniqueWithoutUsersInput | ConferenceFeedbacksUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ConferenceFeedbacksUpdateManyWithWhereWithoutUsersInput | ConferenceFeedbacksUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ConferenceFeedbacksScalarWhereInput | ConferenceFeedbacksScalarWhereInput[]
  }

  export type ConferenceFollowsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ConferenceFollowsCreateWithoutUsersInput, ConferenceFollowsUncheckedCreateWithoutUsersInput> | ConferenceFollowsCreateWithoutUsersInput[] | ConferenceFollowsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConferenceFollowsCreateOrConnectWithoutUsersInput | ConferenceFollowsCreateOrConnectWithoutUsersInput[]
    upsert?: ConferenceFollowsUpsertWithWhereUniqueWithoutUsersInput | ConferenceFollowsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ConferenceFollowsCreateManyUsersInputEnvelope
    set?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    disconnect?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    delete?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    connect?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    update?: ConferenceFollowsUpdateWithWhereUniqueWithoutUsersInput | ConferenceFollowsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ConferenceFollowsUpdateManyWithWhereWithoutUsersInput | ConferenceFollowsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ConferenceFollowsScalarWhereInput | ConferenceFollowsScalarWhereInput[]
  }

  export type ConferenceLikesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ConferenceLikesCreateWithoutUsersInput, ConferenceLikesUncheckedCreateWithoutUsersInput> | ConferenceLikesCreateWithoutUsersInput[] | ConferenceLikesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConferenceLikesCreateOrConnectWithoutUsersInput | ConferenceLikesCreateOrConnectWithoutUsersInput[]
    upsert?: ConferenceLikesUpsertWithWhereUniqueWithoutUsersInput | ConferenceLikesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ConferenceLikesCreateManyUsersInputEnvelope
    set?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    disconnect?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    delete?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    connect?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    update?: ConferenceLikesUpdateWithWhereUniqueWithoutUsersInput | ConferenceLikesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ConferenceLikesUpdateManyWithWhereWithoutUsersInput | ConferenceLikesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ConferenceLikesScalarWhereInput | ConferenceLikesScalarWhereInput[]
  }

  export type ConferencesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ConferencesCreateWithoutUsersInput, ConferencesUncheckedCreateWithoutUsersInput> | ConferencesCreateWithoutUsersInput[] | ConferencesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConferencesCreateOrConnectWithoutUsersInput | ConferencesCreateOrConnectWithoutUsersInput[]
    upsert?: ConferencesUpsertWithWhereUniqueWithoutUsersInput | ConferencesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ConferencesCreateManyUsersInputEnvelope
    set?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
    disconnect?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
    delete?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
    connect?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
    update?: ConferencesUpdateWithWhereUniqueWithoutUsersInput | ConferencesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ConferencesUpdateManyWithWhereWithoutUsersInput | ConferencesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ConferencesScalarWhereInput | ConferencesScalarWhereInput[]
  }

  export type JournalFollowsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<JournalFollowsCreateWithoutUsersInput, JournalFollowsUncheckedCreateWithoutUsersInput> | JournalFollowsCreateWithoutUsersInput[] | JournalFollowsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: JournalFollowsCreateOrConnectWithoutUsersInput | JournalFollowsCreateOrConnectWithoutUsersInput[]
    upsert?: JournalFollowsUpsertWithWhereUniqueWithoutUsersInput | JournalFollowsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: JournalFollowsCreateManyUsersInputEnvelope
    set?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    disconnect?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    delete?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    connect?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    update?: JournalFollowsUpdateWithWhereUniqueWithoutUsersInput | JournalFollowsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: JournalFollowsUpdateManyWithWhereWithoutUsersInput | JournalFollowsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: JournalFollowsScalarWhereInput | JournalFollowsScalarWhereInput[]
  }

  export type JournalLikesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<JournalLikesCreateWithoutUsersInput, JournalLikesUncheckedCreateWithoutUsersInput> | JournalLikesCreateWithoutUsersInput[] | JournalLikesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: JournalLikesCreateOrConnectWithoutUsersInput | JournalLikesCreateOrConnectWithoutUsersInput[]
    upsert?: JournalLikesUpsertWithWhereUniqueWithoutUsersInput | JournalLikesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: JournalLikesCreateManyUsersInputEnvelope
    set?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    disconnect?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    delete?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    connect?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    update?: JournalLikesUpdateWithWhereUniqueWithoutUsersInput | JournalLikesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: JournalLikesUpdateManyWithWhereWithoutUsersInput | JournalLikesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: JournalLikesScalarWhereInput | JournalLikesScalarWhereInput[]
  }

  export type JournalsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<JournalsCreateWithoutUsersInput, JournalsUncheckedCreateWithoutUsersInput> | JournalsCreateWithoutUsersInput[] | JournalsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: JournalsCreateOrConnectWithoutUsersInput | JournalsCreateOrConnectWithoutUsersInput[]
    upsert?: JournalsUpsertWithWhereUniqueWithoutUsersInput | JournalsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: JournalsCreateManyUsersInputEnvelope
    set?: JournalsWhereUniqueInput | JournalsWhereUniqueInput[]
    disconnect?: JournalsWhereUniqueInput | JournalsWhereUniqueInput[]
    delete?: JournalsWhereUniqueInput | JournalsWhereUniqueInput[]
    connect?: JournalsWhereUniqueInput | JournalsWhereUniqueInput[]
    update?: JournalsUpdateWithWhereUniqueWithoutUsersInput | JournalsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: JournalsUpdateManyWithWhereWithoutUsersInput | JournalsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: JournalsScalarWhereInput | JournalsScalarWhereInput[]
  }

  export type NotificationSettingsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<NotificationSettingsCreateWithoutUsersInput, NotificationSettingsUncheckedCreateWithoutUsersInput> | NotificationSettingsCreateWithoutUsersInput[] | NotificationSettingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUsersInput | NotificationSettingsCreateOrConnectWithoutUsersInput[]
    upsert?: NotificationSettingsUpsertWithWhereUniqueWithoutUsersInput | NotificationSettingsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: NotificationSettingsCreateManyUsersInputEnvelope
    set?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    disconnect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    delete?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    connect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    update?: NotificationSettingsUpdateWithWhereUniqueWithoutUsersInput | NotificationSettingsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: NotificationSettingsUpdateManyWithWhereWithoutUsersInput | NotificationSettingsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: NotificationSettingsScalarWhereInput | NotificationSettingsScalarWhereInput[]
  }

  export type NotificationsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<NotificationsCreateWithoutUsersInput, NotificationsUncheckedCreateWithoutUsersInput> | NotificationsCreateWithoutUsersInput[] | NotificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUsersInput | NotificationsCreateOrConnectWithoutUsersInput[]
    upsert?: NotificationsUpsertWithWhereUniqueWithoutUsersInput | NotificationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: NotificationsCreateManyUsersInputEnvelope
    set?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    disconnect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    delete?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    update?: NotificationsUpdateWithWhereUniqueWithoutUsersInput | NotificationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: NotificationsUpdateManyWithWhereWithoutUsersInput | NotificationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
  }

  export type TopicUserInterestedsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<TopicUserInterestedsCreateWithoutUsersInput, TopicUserInterestedsUncheckedCreateWithoutUsersInput> | TopicUserInterestedsCreateWithoutUsersInput[] | TopicUserInterestedsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: TopicUserInterestedsCreateOrConnectWithoutUsersInput | TopicUserInterestedsCreateOrConnectWithoutUsersInput[]
    upsert?: TopicUserInterestedsUpsertWithWhereUniqueWithoutUsersInput | TopicUserInterestedsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: TopicUserInterestedsCreateManyUsersInputEnvelope
    set?: TopicUserInterestedsWhereUniqueInput | TopicUserInterestedsWhereUniqueInput[]
    disconnect?: TopicUserInterestedsWhereUniqueInput | TopicUserInterestedsWhereUniqueInput[]
    delete?: TopicUserInterestedsWhereUniqueInput | TopicUserInterestedsWhereUniqueInput[]
    connect?: TopicUserInterestedsWhereUniqueInput | TopicUserInterestedsWhereUniqueInput[]
    update?: TopicUserInterestedsUpdateWithWhereUniqueWithoutUsersInput | TopicUserInterestedsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: TopicUserInterestedsUpdateManyWithWhereWithoutUsersInput | TopicUserInterestedsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: TopicUserInterestedsScalarWhereInput | TopicUserInterestedsScalarWhereInput[]
  }

  export type UserVerificationUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UserVerificationCreateWithoutUsersInput, UserVerificationUncheckedCreateWithoutUsersInput> | UserVerificationCreateWithoutUsersInput[] | UserVerificationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserVerificationCreateOrConnectWithoutUsersInput | UserVerificationCreateOrConnectWithoutUsersInput[]
    upsert?: UserVerificationUpsertWithWhereUniqueWithoutUsersInput | UserVerificationUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: UserVerificationCreateManyUsersInputEnvelope
    set?: UserVerificationWhereUniqueInput | UserVerificationWhereUniqueInput[]
    disconnect?: UserVerificationWhereUniqueInput | UserVerificationWhereUniqueInput[]
    delete?: UserVerificationWhereUniqueInput | UserVerificationWhereUniqueInput[]
    connect?: UserVerificationWhereUniqueInput | UserVerificationWhereUniqueInput[]
    update?: UserVerificationUpdateWithWhereUniqueWithoutUsersInput | UserVerificationUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UserVerificationUpdateManyWithWhereWithoutUsersInput | UserVerificationUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UserVerificationScalarWhereInput | UserVerificationScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type ConferencesCreateWithoutAdminsInput = {
    id: string
    title: string
    acronym: string
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
    ConferenceBlacklists?: ConferenceBlacklistsCreateNestedManyWithoutConferencesInput
    ConferenceCalendars?: ConferenceCalendarsCreateNestedManyWithoutConferencesInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsCreateNestedManyWithoutConferencesInput
    ConferenceFeedbacks?: ConferenceFeedbacksCreateNestedManyWithoutConferencesInput
    ConferenceFollows?: ConferenceFollowsCreateNestedManyWithoutConferencesInput
    ConferenceLikes?: ConferenceLikesCreateNestedManyWithoutConferencesInput
    ConferenceOrganizations?: ConferenceOrganizationsCreateNestedManyWithoutConferencesInput
    ConferenceRanks?: ConferenceRanksCreateNestedManyWithoutConferencesInput
    Users?: UsersCreateNestedOneWithoutConferencesInput
  }

  export type ConferencesUncheckedCreateWithoutAdminsInput = {
    id: string
    title: string
    acronym: string
    creatorId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceFollows?: ConferenceFollowsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceLikes?: ConferenceLikesUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceOrganizations?: ConferenceOrganizationsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceRanks?: ConferenceRanksUncheckedCreateNestedManyWithoutConferencesInput
  }

  export type ConferencesCreateOrConnectWithoutAdminsInput = {
    where: ConferencesWhereUniqueInput
    create: XOR<ConferencesCreateWithoutAdminsInput, ConferencesUncheckedCreateWithoutAdminsInput>
  }

  export type ConferencesCreateManyAdminsInputEnvelope = {
    data: ConferencesCreateManyAdminsInput | ConferencesCreateManyAdminsInput[]
    skipDuplicates?: boolean
  }

  export type ConferencesUpsertWithWhereUniqueWithoutAdminsInput = {
    where: ConferencesWhereUniqueInput
    update: XOR<ConferencesUpdateWithoutAdminsInput, ConferencesUncheckedUpdateWithoutAdminsInput>
    create: XOR<ConferencesCreateWithoutAdminsInput, ConferencesUncheckedCreateWithoutAdminsInput>
  }

  export type ConferencesUpdateWithWhereUniqueWithoutAdminsInput = {
    where: ConferencesWhereUniqueInput
    data: XOR<ConferencesUpdateWithoutAdminsInput, ConferencesUncheckedUpdateWithoutAdminsInput>
  }

  export type ConferencesUpdateManyWithWhereWithoutAdminsInput = {
    where: ConferencesScalarWhereInput
    data: XOR<ConferencesUpdateManyMutationInput, ConferencesUncheckedUpdateManyWithoutAdminsInput>
  }

  export type ConferencesScalarWhereInput = {
    AND?: ConferencesScalarWhereInput | ConferencesScalarWhereInput[]
    OR?: ConferencesScalarWhereInput[]
    NOT?: ConferencesScalarWhereInput | ConferencesScalarWhereInput[]
    id?: StringFilter<"Conferences"> | string
    title?: StringFilter<"Conferences"> | string
    acronym?: StringFilter<"Conferences"> | string
    creatorId?: StringNullableFilter<"Conferences"> | string | null
    createdAt?: DateTimeFilter<"Conferences"> | Date | string
    updatedAt?: DateTimeFilter<"Conferences"> | Date | string
    status?: StringFilter<"Conferences"> | string
    adminId?: StringNullableFilter<"Conferences"> | string | null
  }

  export type ConferencesCreateWithoutConferenceBlacklistsInput = {
    id: string
    title: string
    acronym: string
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
    ConferenceCalendars?: ConferenceCalendarsCreateNestedManyWithoutConferencesInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsCreateNestedManyWithoutConferencesInput
    ConferenceFeedbacks?: ConferenceFeedbacksCreateNestedManyWithoutConferencesInput
    ConferenceFollows?: ConferenceFollowsCreateNestedManyWithoutConferencesInput
    ConferenceLikes?: ConferenceLikesCreateNestedManyWithoutConferencesInput
    ConferenceOrganizations?: ConferenceOrganizationsCreateNestedManyWithoutConferencesInput
    ConferenceRanks?: ConferenceRanksCreateNestedManyWithoutConferencesInput
    Admins?: AdminsCreateNestedOneWithoutConferencesInput
    Users?: UsersCreateNestedOneWithoutConferencesInput
  }

  export type ConferencesUncheckedCreateWithoutConferenceBlacklistsInput = {
    id: string
    title: string
    acronym: string
    creatorId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
    adminId?: string | null
    ConferenceCalendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceFollows?: ConferenceFollowsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceLikes?: ConferenceLikesUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceOrganizations?: ConferenceOrganizationsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceRanks?: ConferenceRanksUncheckedCreateNestedManyWithoutConferencesInput
  }

  export type ConferencesCreateOrConnectWithoutConferenceBlacklistsInput = {
    where: ConferencesWhereUniqueInput
    create: XOR<ConferencesCreateWithoutConferenceBlacklistsInput, ConferencesUncheckedCreateWithoutConferenceBlacklistsInput>
  }

  export type UsersCreateWithoutConferenceBlacklistsInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceCalendars?: ConferenceCalendarsCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesCreateNestedManyWithoutUsersInput
    Journals?: JournalsCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutConferenceBlacklistsInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceCalendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesUncheckedCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesUncheckedCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesUncheckedCreateNestedManyWithoutUsersInput
    Journals?: JournalsUncheckedCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutConferenceBlacklistsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutConferenceBlacklistsInput, UsersUncheckedCreateWithoutConferenceBlacklistsInput>
  }

  export type ConferencesUpsertWithoutConferenceBlacklistsInput = {
    update: XOR<ConferencesUpdateWithoutConferenceBlacklistsInput, ConferencesUncheckedUpdateWithoutConferenceBlacklistsInput>
    create: XOR<ConferencesCreateWithoutConferenceBlacklistsInput, ConferencesUncheckedCreateWithoutConferenceBlacklistsInput>
    where?: ConferencesWhereInput
  }

  export type ConferencesUpdateToOneWithWhereWithoutConferenceBlacklistsInput = {
    where?: ConferencesWhereInput
    data: XOR<ConferencesUpdateWithoutConferenceBlacklistsInput, ConferencesUncheckedUpdateWithoutConferenceBlacklistsInput>
  }

  export type ConferencesUpdateWithoutConferenceBlacklistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    ConferenceCalendars?: ConferenceCalendarsUpdateManyWithoutConferencesNestedInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUpdateManyWithoutConferencesNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUpdateManyWithoutConferencesNestedInput
    ConferenceFollows?: ConferenceFollowsUpdateManyWithoutConferencesNestedInput
    ConferenceLikes?: ConferenceLikesUpdateManyWithoutConferencesNestedInput
    ConferenceOrganizations?: ConferenceOrganizationsUpdateManyWithoutConferencesNestedInput
    ConferenceRanks?: ConferenceRanksUpdateManyWithoutConferencesNestedInput
    Admins?: AdminsUpdateOneWithoutConferencesNestedInput
    Users?: UsersUpdateOneWithoutConferencesNestedInput
  }

  export type ConferencesUncheckedUpdateWithoutConferenceBlacklistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ConferenceCalendars?: ConferenceCalendarsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceFollows?: ConferenceFollowsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceLikes?: ConferenceLikesUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceOrganizations?: ConferenceOrganizationsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceRanks?: ConferenceRanksUncheckedUpdateManyWithoutConferencesNestedInput
  }

  export type UsersUpsertWithoutConferenceBlacklistsInput = {
    update: XOR<UsersUpdateWithoutConferenceBlacklistsInput, UsersUncheckedUpdateWithoutConferenceBlacklistsInput>
    create: XOR<UsersCreateWithoutConferenceBlacklistsInput, UsersUncheckedCreateWithoutConferenceBlacklistsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutConferenceBlacklistsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutConferenceBlacklistsInput, UsersUncheckedUpdateWithoutConferenceBlacklistsInput>
  }

  export type UsersUpdateWithoutConferenceBlacklistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceCalendars?: ConferenceCalendarsUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutConferenceBlacklistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceCalendars?: ConferenceCalendarsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUncheckedUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUncheckedUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUncheckedUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUncheckedUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUncheckedUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type ConferencesCreateWithoutConferenceCalendarsInput = {
    id: string
    title: string
    acronym: string
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
    ConferenceBlacklists?: ConferenceBlacklistsCreateNestedManyWithoutConferencesInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsCreateNestedManyWithoutConferencesInput
    ConferenceFeedbacks?: ConferenceFeedbacksCreateNestedManyWithoutConferencesInput
    ConferenceFollows?: ConferenceFollowsCreateNestedManyWithoutConferencesInput
    ConferenceLikes?: ConferenceLikesCreateNestedManyWithoutConferencesInput
    ConferenceOrganizations?: ConferenceOrganizationsCreateNestedManyWithoutConferencesInput
    ConferenceRanks?: ConferenceRanksCreateNestedManyWithoutConferencesInput
    Admins?: AdminsCreateNestedOneWithoutConferencesInput
    Users?: UsersCreateNestedOneWithoutConferencesInput
  }

  export type ConferencesUncheckedCreateWithoutConferenceCalendarsInput = {
    id: string
    title: string
    acronym: string
    creatorId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
    adminId?: string | null
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceFollows?: ConferenceFollowsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceLikes?: ConferenceLikesUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceOrganizations?: ConferenceOrganizationsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceRanks?: ConferenceRanksUncheckedCreateNestedManyWithoutConferencesInput
  }

  export type ConferencesCreateOrConnectWithoutConferenceCalendarsInput = {
    where: ConferencesWhereUniqueInput
    create: XOR<ConferencesCreateWithoutConferenceCalendarsInput, ConferencesUncheckedCreateWithoutConferenceCalendarsInput>
  }

  export type UsersCreateWithoutConferenceCalendarsInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesCreateNestedManyWithoutUsersInput
    Journals?: JournalsCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutConferenceCalendarsInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesUncheckedCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesUncheckedCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesUncheckedCreateNestedManyWithoutUsersInput
    Journals?: JournalsUncheckedCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutConferenceCalendarsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutConferenceCalendarsInput, UsersUncheckedCreateWithoutConferenceCalendarsInput>
  }

  export type ConferencesUpsertWithoutConferenceCalendarsInput = {
    update: XOR<ConferencesUpdateWithoutConferenceCalendarsInput, ConferencesUncheckedUpdateWithoutConferenceCalendarsInput>
    create: XOR<ConferencesCreateWithoutConferenceCalendarsInput, ConferencesUncheckedCreateWithoutConferenceCalendarsInput>
    where?: ConferencesWhereInput
  }

  export type ConferencesUpdateToOneWithWhereWithoutConferenceCalendarsInput = {
    where?: ConferencesWhereInput
    data: XOR<ConferencesUpdateWithoutConferenceCalendarsInput, ConferencesUncheckedUpdateWithoutConferenceCalendarsInput>
  }

  export type ConferencesUpdateWithoutConferenceCalendarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUpdateManyWithoutConferencesNestedInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUpdateManyWithoutConferencesNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUpdateManyWithoutConferencesNestedInput
    ConferenceFollows?: ConferenceFollowsUpdateManyWithoutConferencesNestedInput
    ConferenceLikes?: ConferenceLikesUpdateManyWithoutConferencesNestedInput
    ConferenceOrganizations?: ConferenceOrganizationsUpdateManyWithoutConferencesNestedInput
    ConferenceRanks?: ConferenceRanksUpdateManyWithoutConferencesNestedInput
    Admins?: AdminsUpdateOneWithoutConferencesNestedInput
    Users?: UsersUpdateOneWithoutConferencesNestedInput
  }

  export type ConferencesUncheckedUpdateWithoutConferenceCalendarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceFollows?: ConferenceFollowsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceLikes?: ConferenceLikesUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceOrganizations?: ConferenceOrganizationsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceRanks?: ConferenceRanksUncheckedUpdateManyWithoutConferencesNestedInput
  }

  export type UsersUpsertWithoutConferenceCalendarsInput = {
    update: XOR<UsersUpdateWithoutConferenceCalendarsInput, UsersUncheckedUpdateWithoutConferenceCalendarsInput>
    create: XOR<UsersCreateWithoutConferenceCalendarsInput, UsersUncheckedCreateWithoutConferenceCalendarsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutConferenceCalendarsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutConferenceCalendarsInput, UsersUncheckedUpdateWithoutConferenceCalendarsInput>
  }

  export type UsersUpdateWithoutConferenceCalendarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutConferenceCalendarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUncheckedUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUncheckedUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUncheckedUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUncheckedUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUncheckedUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type ConferencesCreateWithoutConferenceCrawlJobsInput = {
    id: string
    title: string
    acronym: string
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
    ConferenceBlacklists?: ConferenceBlacklistsCreateNestedManyWithoutConferencesInput
    ConferenceCalendars?: ConferenceCalendarsCreateNestedManyWithoutConferencesInput
    ConferenceFeedbacks?: ConferenceFeedbacksCreateNestedManyWithoutConferencesInput
    ConferenceFollows?: ConferenceFollowsCreateNestedManyWithoutConferencesInput
    ConferenceLikes?: ConferenceLikesCreateNestedManyWithoutConferencesInput
    ConferenceOrganizations?: ConferenceOrganizationsCreateNestedManyWithoutConferencesInput
    ConferenceRanks?: ConferenceRanksCreateNestedManyWithoutConferencesInput
    Admins?: AdminsCreateNestedOneWithoutConferencesInput
    Users?: UsersCreateNestedOneWithoutConferencesInput
  }

  export type ConferencesUncheckedCreateWithoutConferenceCrawlJobsInput = {
    id: string
    title: string
    acronym: string
    creatorId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
    adminId?: string | null
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceFollows?: ConferenceFollowsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceLikes?: ConferenceLikesUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceOrganizations?: ConferenceOrganizationsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceRanks?: ConferenceRanksUncheckedCreateNestedManyWithoutConferencesInput
  }

  export type ConferencesCreateOrConnectWithoutConferenceCrawlJobsInput = {
    where: ConferencesWhereUniqueInput
    create: XOR<ConferencesCreateWithoutConferenceCrawlJobsInput, ConferencesUncheckedCreateWithoutConferenceCrawlJobsInput>
  }

  export type ConferencesUpsertWithoutConferenceCrawlJobsInput = {
    update: XOR<ConferencesUpdateWithoutConferenceCrawlJobsInput, ConferencesUncheckedUpdateWithoutConferenceCrawlJobsInput>
    create: XOR<ConferencesCreateWithoutConferenceCrawlJobsInput, ConferencesUncheckedCreateWithoutConferenceCrawlJobsInput>
    where?: ConferencesWhereInput
  }

  export type ConferencesUpdateToOneWithWhereWithoutConferenceCrawlJobsInput = {
    where?: ConferencesWhereInput
    data: XOR<ConferencesUpdateWithoutConferenceCrawlJobsInput, ConferencesUncheckedUpdateWithoutConferenceCrawlJobsInput>
  }

  export type ConferencesUpdateWithoutConferenceCrawlJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUpdateManyWithoutConferencesNestedInput
    ConferenceCalendars?: ConferenceCalendarsUpdateManyWithoutConferencesNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUpdateManyWithoutConferencesNestedInput
    ConferenceFollows?: ConferenceFollowsUpdateManyWithoutConferencesNestedInput
    ConferenceLikes?: ConferenceLikesUpdateManyWithoutConferencesNestedInput
    ConferenceOrganizations?: ConferenceOrganizationsUpdateManyWithoutConferencesNestedInput
    ConferenceRanks?: ConferenceRanksUpdateManyWithoutConferencesNestedInput
    Admins?: AdminsUpdateOneWithoutConferencesNestedInput
    Users?: UsersUpdateOneWithoutConferencesNestedInput
  }

  export type ConferencesUncheckedUpdateWithoutConferenceCrawlJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceFollows?: ConferenceFollowsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceLikes?: ConferenceLikesUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceOrganizations?: ConferenceOrganizationsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceRanks?: ConferenceRanksUncheckedUpdateManyWithoutConferencesNestedInput
  }

  export type ConferenceOrganizationsCreateWithoutConferenceDatesInput = {
    id: string
    year?: number | null
    accessType: string
    isAvailable: boolean
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt?: Date | string
    updatedAt: Date | string
    Conferences: ConferencesCreateNestedOneWithoutConferenceOrganizationsInput
    ConferenceTopics?: ConferenceTopicsCreateNestedManyWithoutConferenceOrganizationsInput
    Locations?: LocationsCreateNestedManyWithoutConferenceOrganizationsInput
  }

  export type ConferenceOrganizationsUncheckedCreateWithoutConferenceDatesInput = {
    id: string
    year?: number | null
    accessType: string
    isAvailable: boolean
    conferenceId: string
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt?: Date | string
    updatedAt: Date | string
    ConferenceTopics?: ConferenceTopicsUncheckedCreateNestedManyWithoutConferenceOrganizationsInput
    Locations?: LocationsUncheckedCreateNestedManyWithoutConferenceOrganizationsInput
  }

  export type ConferenceOrganizationsCreateOrConnectWithoutConferenceDatesInput = {
    where: ConferenceOrganizationsWhereUniqueInput
    create: XOR<ConferenceOrganizationsCreateWithoutConferenceDatesInput, ConferenceOrganizationsUncheckedCreateWithoutConferenceDatesInput>
  }

  export type ConferenceOrganizationsUpsertWithoutConferenceDatesInput = {
    update: XOR<ConferenceOrganizationsUpdateWithoutConferenceDatesInput, ConferenceOrganizationsUncheckedUpdateWithoutConferenceDatesInput>
    create: XOR<ConferenceOrganizationsCreateWithoutConferenceDatesInput, ConferenceOrganizationsUncheckedCreateWithoutConferenceDatesInput>
    where?: ConferenceOrganizationsWhereInput
  }

  export type ConferenceOrganizationsUpdateToOneWithWhereWithoutConferenceDatesInput = {
    where?: ConferenceOrganizationsWhereInput
    data: XOR<ConferenceOrganizationsUpdateWithoutConferenceDatesInput, ConferenceOrganizationsUncheckedUpdateWithoutConferenceDatesInput>
  }

  export type ConferenceOrganizationsUpdateWithoutConferenceDatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Conferences?: ConferencesUpdateOneRequiredWithoutConferenceOrganizationsNestedInput
    ConferenceTopics?: ConferenceTopicsUpdateManyWithoutConferenceOrganizationsNestedInput
    Locations?: LocationsUpdateManyWithoutConferenceOrganizationsNestedInput
  }

  export type ConferenceOrganizationsUncheckedUpdateWithoutConferenceDatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    conferenceId?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ConferenceTopics?: ConferenceTopicsUncheckedUpdateManyWithoutConferenceOrganizationsNestedInput
    Locations?: LocationsUncheckedUpdateManyWithoutConferenceOrganizationsNestedInput
  }

  export type ConferencesCreateWithoutConferenceFeedbacksInput = {
    id: string
    title: string
    acronym: string
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
    ConferenceBlacklists?: ConferenceBlacklistsCreateNestedManyWithoutConferencesInput
    ConferenceCalendars?: ConferenceCalendarsCreateNestedManyWithoutConferencesInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsCreateNestedManyWithoutConferencesInput
    ConferenceFollows?: ConferenceFollowsCreateNestedManyWithoutConferencesInput
    ConferenceLikes?: ConferenceLikesCreateNestedManyWithoutConferencesInput
    ConferenceOrganizations?: ConferenceOrganizationsCreateNestedManyWithoutConferencesInput
    ConferenceRanks?: ConferenceRanksCreateNestedManyWithoutConferencesInput
    Admins?: AdminsCreateNestedOneWithoutConferencesInput
    Users?: UsersCreateNestedOneWithoutConferencesInput
  }

  export type ConferencesUncheckedCreateWithoutConferenceFeedbacksInput = {
    id: string
    title: string
    acronym: string
    creatorId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
    adminId?: string | null
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceFollows?: ConferenceFollowsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceLikes?: ConferenceLikesUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceOrganizations?: ConferenceOrganizationsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceRanks?: ConferenceRanksUncheckedCreateNestedManyWithoutConferencesInput
  }

  export type ConferencesCreateOrConnectWithoutConferenceFeedbacksInput = {
    where: ConferencesWhereUniqueInput
    create: XOR<ConferencesCreateWithoutConferenceFeedbacksInput, ConferencesUncheckedCreateWithoutConferenceFeedbacksInput>
  }

  export type UsersCreateWithoutConferenceFeedbacksInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsCreateNestedManyWithoutUsersInput
    ConferenceCalendars?: ConferenceCalendarsCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesCreateNestedManyWithoutUsersInput
    Journals?: JournalsCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutConferenceFeedbacksInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesUncheckedCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesUncheckedCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesUncheckedCreateNestedManyWithoutUsersInput
    Journals?: JournalsUncheckedCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutConferenceFeedbacksInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutConferenceFeedbacksInput, UsersUncheckedCreateWithoutConferenceFeedbacksInput>
  }

  export type ConferencesUpsertWithoutConferenceFeedbacksInput = {
    update: XOR<ConferencesUpdateWithoutConferenceFeedbacksInput, ConferencesUncheckedUpdateWithoutConferenceFeedbacksInput>
    create: XOR<ConferencesCreateWithoutConferenceFeedbacksInput, ConferencesUncheckedCreateWithoutConferenceFeedbacksInput>
    where?: ConferencesWhereInput
  }

  export type ConferencesUpdateToOneWithWhereWithoutConferenceFeedbacksInput = {
    where?: ConferencesWhereInput
    data: XOR<ConferencesUpdateWithoutConferenceFeedbacksInput, ConferencesUncheckedUpdateWithoutConferenceFeedbacksInput>
  }

  export type ConferencesUpdateWithoutConferenceFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUpdateManyWithoutConferencesNestedInput
    ConferenceCalendars?: ConferenceCalendarsUpdateManyWithoutConferencesNestedInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUpdateManyWithoutConferencesNestedInput
    ConferenceFollows?: ConferenceFollowsUpdateManyWithoutConferencesNestedInput
    ConferenceLikes?: ConferenceLikesUpdateManyWithoutConferencesNestedInput
    ConferenceOrganizations?: ConferenceOrganizationsUpdateManyWithoutConferencesNestedInput
    ConferenceRanks?: ConferenceRanksUpdateManyWithoutConferencesNestedInput
    Admins?: AdminsUpdateOneWithoutConferencesNestedInput
    Users?: UsersUpdateOneWithoutConferencesNestedInput
  }

  export type ConferencesUncheckedUpdateWithoutConferenceFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceFollows?: ConferenceFollowsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceLikes?: ConferenceLikesUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceOrganizations?: ConferenceOrganizationsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceRanks?: ConferenceRanksUncheckedUpdateManyWithoutConferencesNestedInput
  }

  export type UsersUpsertWithoutConferenceFeedbacksInput = {
    update: XOR<UsersUpdateWithoutConferenceFeedbacksInput, UsersUncheckedUpdateWithoutConferenceFeedbacksInput>
    create: XOR<UsersCreateWithoutConferenceFeedbacksInput, UsersUncheckedCreateWithoutConferenceFeedbacksInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutConferenceFeedbacksInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutConferenceFeedbacksInput, UsersUncheckedUpdateWithoutConferenceFeedbacksInput>
  }

  export type UsersUpdateWithoutConferenceFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUpdateManyWithoutUsersNestedInput
    ConferenceCalendars?: ConferenceCalendarsUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutConferenceFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUncheckedUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUncheckedUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUncheckedUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUncheckedUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUncheckedUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type ConferencesCreateWithoutConferenceFollowsInput = {
    id: string
    title: string
    acronym: string
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
    ConferenceBlacklists?: ConferenceBlacklistsCreateNestedManyWithoutConferencesInput
    ConferenceCalendars?: ConferenceCalendarsCreateNestedManyWithoutConferencesInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsCreateNestedManyWithoutConferencesInput
    ConferenceFeedbacks?: ConferenceFeedbacksCreateNestedManyWithoutConferencesInput
    ConferenceLikes?: ConferenceLikesCreateNestedManyWithoutConferencesInput
    ConferenceOrganizations?: ConferenceOrganizationsCreateNestedManyWithoutConferencesInput
    ConferenceRanks?: ConferenceRanksCreateNestedManyWithoutConferencesInput
    Admins?: AdminsCreateNestedOneWithoutConferencesInput
    Users?: UsersCreateNestedOneWithoutConferencesInput
  }

  export type ConferencesUncheckedCreateWithoutConferenceFollowsInput = {
    id: string
    title: string
    acronym: string
    creatorId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
    adminId?: string | null
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceLikes?: ConferenceLikesUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceOrganizations?: ConferenceOrganizationsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceRanks?: ConferenceRanksUncheckedCreateNestedManyWithoutConferencesInput
  }

  export type ConferencesCreateOrConnectWithoutConferenceFollowsInput = {
    where: ConferencesWhereUniqueInput
    create: XOR<ConferencesCreateWithoutConferenceFollowsInput, ConferencesUncheckedCreateWithoutConferenceFollowsInput>
  }

  export type UsersCreateWithoutConferenceFollowsInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsCreateNestedManyWithoutUsersInput
    ConferenceCalendars?: ConferenceCalendarsCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesCreateNestedManyWithoutUsersInput
    Journals?: JournalsCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutConferenceFollowsInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesUncheckedCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesUncheckedCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesUncheckedCreateNestedManyWithoutUsersInput
    Journals?: JournalsUncheckedCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutConferenceFollowsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutConferenceFollowsInput, UsersUncheckedCreateWithoutConferenceFollowsInput>
  }

  export type ConferencesUpsertWithoutConferenceFollowsInput = {
    update: XOR<ConferencesUpdateWithoutConferenceFollowsInput, ConferencesUncheckedUpdateWithoutConferenceFollowsInput>
    create: XOR<ConferencesCreateWithoutConferenceFollowsInput, ConferencesUncheckedCreateWithoutConferenceFollowsInput>
    where?: ConferencesWhereInput
  }

  export type ConferencesUpdateToOneWithWhereWithoutConferenceFollowsInput = {
    where?: ConferencesWhereInput
    data: XOR<ConferencesUpdateWithoutConferenceFollowsInput, ConferencesUncheckedUpdateWithoutConferenceFollowsInput>
  }

  export type ConferencesUpdateWithoutConferenceFollowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUpdateManyWithoutConferencesNestedInput
    ConferenceCalendars?: ConferenceCalendarsUpdateManyWithoutConferencesNestedInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUpdateManyWithoutConferencesNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUpdateManyWithoutConferencesNestedInput
    ConferenceLikes?: ConferenceLikesUpdateManyWithoutConferencesNestedInput
    ConferenceOrganizations?: ConferenceOrganizationsUpdateManyWithoutConferencesNestedInput
    ConferenceRanks?: ConferenceRanksUpdateManyWithoutConferencesNestedInput
    Admins?: AdminsUpdateOneWithoutConferencesNestedInput
    Users?: UsersUpdateOneWithoutConferencesNestedInput
  }

  export type ConferencesUncheckedUpdateWithoutConferenceFollowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceLikes?: ConferenceLikesUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceOrganizations?: ConferenceOrganizationsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceRanks?: ConferenceRanksUncheckedUpdateManyWithoutConferencesNestedInput
  }

  export type UsersUpsertWithoutConferenceFollowsInput = {
    update: XOR<UsersUpdateWithoutConferenceFollowsInput, UsersUncheckedUpdateWithoutConferenceFollowsInput>
    create: XOR<UsersCreateWithoutConferenceFollowsInput, UsersUncheckedCreateWithoutConferenceFollowsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutConferenceFollowsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutConferenceFollowsInput, UsersUncheckedUpdateWithoutConferenceFollowsInput>
  }

  export type UsersUpdateWithoutConferenceFollowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUpdateManyWithoutUsersNestedInput
    ConferenceCalendars?: ConferenceCalendarsUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutConferenceFollowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUncheckedUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUncheckedUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUncheckedUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUncheckedUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUncheckedUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type ConferencesCreateWithoutConferenceLikesInput = {
    id: string
    title: string
    acronym: string
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
    ConferenceBlacklists?: ConferenceBlacklistsCreateNestedManyWithoutConferencesInput
    ConferenceCalendars?: ConferenceCalendarsCreateNestedManyWithoutConferencesInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsCreateNestedManyWithoutConferencesInput
    ConferenceFeedbacks?: ConferenceFeedbacksCreateNestedManyWithoutConferencesInput
    ConferenceFollows?: ConferenceFollowsCreateNestedManyWithoutConferencesInput
    ConferenceOrganizations?: ConferenceOrganizationsCreateNestedManyWithoutConferencesInput
    ConferenceRanks?: ConferenceRanksCreateNestedManyWithoutConferencesInput
    Admins?: AdminsCreateNestedOneWithoutConferencesInput
    Users?: UsersCreateNestedOneWithoutConferencesInput
  }

  export type ConferencesUncheckedCreateWithoutConferenceLikesInput = {
    id: string
    title: string
    acronym: string
    creatorId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
    adminId?: string | null
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceFollows?: ConferenceFollowsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceOrganizations?: ConferenceOrganizationsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceRanks?: ConferenceRanksUncheckedCreateNestedManyWithoutConferencesInput
  }

  export type ConferencesCreateOrConnectWithoutConferenceLikesInput = {
    where: ConferencesWhereUniqueInput
    create: XOR<ConferencesCreateWithoutConferenceLikesInput, ConferencesUncheckedCreateWithoutConferenceLikesInput>
  }

  export type UsersCreateWithoutConferenceLikesInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsCreateNestedManyWithoutUsersInput
    ConferenceCalendars?: ConferenceCalendarsCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesCreateNestedManyWithoutUsersInput
    Journals?: JournalsCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutConferenceLikesInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsUncheckedCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesUncheckedCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesUncheckedCreateNestedManyWithoutUsersInput
    Journals?: JournalsUncheckedCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutConferenceLikesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutConferenceLikesInput, UsersUncheckedCreateWithoutConferenceLikesInput>
  }

  export type ConferencesUpsertWithoutConferenceLikesInput = {
    update: XOR<ConferencesUpdateWithoutConferenceLikesInput, ConferencesUncheckedUpdateWithoutConferenceLikesInput>
    create: XOR<ConferencesCreateWithoutConferenceLikesInput, ConferencesUncheckedCreateWithoutConferenceLikesInput>
    where?: ConferencesWhereInput
  }

  export type ConferencesUpdateToOneWithWhereWithoutConferenceLikesInput = {
    where?: ConferencesWhereInput
    data: XOR<ConferencesUpdateWithoutConferenceLikesInput, ConferencesUncheckedUpdateWithoutConferenceLikesInput>
  }

  export type ConferencesUpdateWithoutConferenceLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUpdateManyWithoutConferencesNestedInput
    ConferenceCalendars?: ConferenceCalendarsUpdateManyWithoutConferencesNestedInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUpdateManyWithoutConferencesNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUpdateManyWithoutConferencesNestedInput
    ConferenceFollows?: ConferenceFollowsUpdateManyWithoutConferencesNestedInput
    ConferenceOrganizations?: ConferenceOrganizationsUpdateManyWithoutConferencesNestedInput
    ConferenceRanks?: ConferenceRanksUpdateManyWithoutConferencesNestedInput
    Admins?: AdminsUpdateOneWithoutConferencesNestedInput
    Users?: UsersUpdateOneWithoutConferencesNestedInput
  }

  export type ConferencesUncheckedUpdateWithoutConferenceLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceFollows?: ConferenceFollowsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceOrganizations?: ConferenceOrganizationsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceRanks?: ConferenceRanksUncheckedUpdateManyWithoutConferencesNestedInput
  }

  export type UsersUpsertWithoutConferenceLikesInput = {
    update: XOR<UsersUpdateWithoutConferenceLikesInput, UsersUncheckedUpdateWithoutConferenceLikesInput>
    create: XOR<UsersCreateWithoutConferenceLikesInput, UsersUncheckedCreateWithoutConferenceLikesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutConferenceLikesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutConferenceLikesInput, UsersUncheckedUpdateWithoutConferenceLikesInput>
  }

  export type UsersUpdateWithoutConferenceLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUpdateManyWithoutUsersNestedInput
    ConferenceCalendars?: ConferenceCalendarsUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutConferenceLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUncheckedUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUncheckedUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUncheckedUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUncheckedUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUncheckedUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type ConferenceDatesCreateWithoutConferenceOrganizationsInput = {
    id: string
    fromDate: Date | string
    toDate: Date | string
    type: string
    name: string
    createdAt?: Date | string
    updatedAt: Date | string
    isAvailable: boolean
  }

  export type ConferenceDatesUncheckedCreateWithoutConferenceOrganizationsInput = {
    id: string
    fromDate: Date | string
    toDate: Date | string
    type: string
    name: string
    createdAt?: Date | string
    updatedAt: Date | string
    isAvailable: boolean
  }

  export type ConferenceDatesCreateOrConnectWithoutConferenceOrganizationsInput = {
    where: ConferenceDatesWhereUniqueInput
    create: XOR<ConferenceDatesCreateWithoutConferenceOrganizationsInput, ConferenceDatesUncheckedCreateWithoutConferenceOrganizationsInput>
  }

  export type ConferenceDatesCreateManyConferenceOrganizationsInputEnvelope = {
    data: ConferenceDatesCreateManyConferenceOrganizationsInput | ConferenceDatesCreateManyConferenceOrganizationsInput[]
    skipDuplicates?: boolean
  }

  export type ConferencesCreateWithoutConferenceOrganizationsInput = {
    id: string
    title: string
    acronym: string
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
    ConferenceBlacklists?: ConferenceBlacklistsCreateNestedManyWithoutConferencesInput
    ConferenceCalendars?: ConferenceCalendarsCreateNestedManyWithoutConferencesInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsCreateNestedManyWithoutConferencesInput
    ConferenceFeedbacks?: ConferenceFeedbacksCreateNestedManyWithoutConferencesInput
    ConferenceFollows?: ConferenceFollowsCreateNestedManyWithoutConferencesInput
    ConferenceLikes?: ConferenceLikesCreateNestedManyWithoutConferencesInput
    ConferenceRanks?: ConferenceRanksCreateNestedManyWithoutConferencesInput
    Admins?: AdminsCreateNestedOneWithoutConferencesInput
    Users?: UsersCreateNestedOneWithoutConferencesInput
  }

  export type ConferencesUncheckedCreateWithoutConferenceOrganizationsInput = {
    id: string
    title: string
    acronym: string
    creatorId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
    adminId?: string | null
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceFollows?: ConferenceFollowsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceLikes?: ConferenceLikesUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceRanks?: ConferenceRanksUncheckedCreateNestedManyWithoutConferencesInput
  }

  export type ConferencesCreateOrConnectWithoutConferenceOrganizationsInput = {
    where: ConferencesWhereUniqueInput
    create: XOR<ConferencesCreateWithoutConferenceOrganizationsInput, ConferencesUncheckedCreateWithoutConferenceOrganizationsInput>
  }

  export type ConferenceTopicsCreateWithoutConferenceOrganizationsInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    Topics: TopicsCreateNestedOneWithoutConferenceTopicsInput
  }

  export type ConferenceTopicsUncheckedCreateWithoutConferenceOrganizationsInput = {
    id: string
    topicId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceTopicsCreateOrConnectWithoutConferenceOrganizationsInput = {
    where: ConferenceTopicsWhereUniqueInput
    create: XOR<ConferenceTopicsCreateWithoutConferenceOrganizationsInput, ConferenceTopicsUncheckedCreateWithoutConferenceOrganizationsInput>
  }

  export type ConferenceTopicsCreateManyConferenceOrganizationsInputEnvelope = {
    data: ConferenceTopicsCreateManyConferenceOrganizationsInput | ConferenceTopicsCreateManyConferenceOrganizationsInput[]
    skipDuplicates?: boolean
  }

  export type LocationsCreateWithoutConferenceOrganizationsInput = {
    id: string
    address?: string | null
    cityStateProvince?: string | null
    country?: string | null
    continent?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    isAvailable: boolean
  }

  export type LocationsUncheckedCreateWithoutConferenceOrganizationsInput = {
    id: string
    address?: string | null
    cityStateProvince?: string | null
    country?: string | null
    continent?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    isAvailable: boolean
  }

  export type LocationsCreateOrConnectWithoutConferenceOrganizationsInput = {
    where: LocationsWhereUniqueInput
    create: XOR<LocationsCreateWithoutConferenceOrganizationsInput, LocationsUncheckedCreateWithoutConferenceOrganizationsInput>
  }

  export type LocationsCreateManyConferenceOrganizationsInputEnvelope = {
    data: LocationsCreateManyConferenceOrganizationsInput | LocationsCreateManyConferenceOrganizationsInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceDatesUpsertWithWhereUniqueWithoutConferenceOrganizationsInput = {
    where: ConferenceDatesWhereUniqueInput
    update: XOR<ConferenceDatesUpdateWithoutConferenceOrganizationsInput, ConferenceDatesUncheckedUpdateWithoutConferenceOrganizationsInput>
    create: XOR<ConferenceDatesCreateWithoutConferenceOrganizationsInput, ConferenceDatesUncheckedCreateWithoutConferenceOrganizationsInput>
  }

  export type ConferenceDatesUpdateWithWhereUniqueWithoutConferenceOrganizationsInput = {
    where: ConferenceDatesWhereUniqueInput
    data: XOR<ConferenceDatesUpdateWithoutConferenceOrganizationsInput, ConferenceDatesUncheckedUpdateWithoutConferenceOrganizationsInput>
  }

  export type ConferenceDatesUpdateManyWithWhereWithoutConferenceOrganizationsInput = {
    where: ConferenceDatesScalarWhereInput
    data: XOR<ConferenceDatesUpdateManyMutationInput, ConferenceDatesUncheckedUpdateManyWithoutConferenceOrganizationsInput>
  }

  export type ConferenceDatesScalarWhereInput = {
    AND?: ConferenceDatesScalarWhereInput | ConferenceDatesScalarWhereInput[]
    OR?: ConferenceDatesScalarWhereInput[]
    NOT?: ConferenceDatesScalarWhereInput | ConferenceDatesScalarWhereInput[]
    id?: StringFilter<"ConferenceDates"> | string
    organizedId?: StringFilter<"ConferenceDates"> | string
    fromDate?: DateTimeFilter<"ConferenceDates"> | Date | string
    toDate?: DateTimeFilter<"ConferenceDates"> | Date | string
    type?: StringFilter<"ConferenceDates"> | string
    name?: StringFilter<"ConferenceDates"> | string
    createdAt?: DateTimeFilter<"ConferenceDates"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceDates"> | Date | string
    isAvailable?: BoolFilter<"ConferenceDates"> | boolean
  }

  export type ConferencesUpsertWithoutConferenceOrganizationsInput = {
    update: XOR<ConferencesUpdateWithoutConferenceOrganizationsInput, ConferencesUncheckedUpdateWithoutConferenceOrganizationsInput>
    create: XOR<ConferencesCreateWithoutConferenceOrganizationsInput, ConferencesUncheckedCreateWithoutConferenceOrganizationsInput>
    where?: ConferencesWhereInput
  }

  export type ConferencesUpdateToOneWithWhereWithoutConferenceOrganizationsInput = {
    where?: ConferencesWhereInput
    data: XOR<ConferencesUpdateWithoutConferenceOrganizationsInput, ConferencesUncheckedUpdateWithoutConferenceOrganizationsInput>
  }

  export type ConferencesUpdateWithoutConferenceOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUpdateManyWithoutConferencesNestedInput
    ConferenceCalendars?: ConferenceCalendarsUpdateManyWithoutConferencesNestedInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUpdateManyWithoutConferencesNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUpdateManyWithoutConferencesNestedInput
    ConferenceFollows?: ConferenceFollowsUpdateManyWithoutConferencesNestedInput
    ConferenceLikes?: ConferenceLikesUpdateManyWithoutConferencesNestedInput
    ConferenceRanks?: ConferenceRanksUpdateManyWithoutConferencesNestedInput
    Admins?: AdminsUpdateOneWithoutConferencesNestedInput
    Users?: UsersUpdateOneWithoutConferencesNestedInput
  }

  export type ConferencesUncheckedUpdateWithoutConferenceOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceFollows?: ConferenceFollowsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceLikes?: ConferenceLikesUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceRanks?: ConferenceRanksUncheckedUpdateManyWithoutConferencesNestedInput
  }

  export type ConferenceTopicsUpsertWithWhereUniqueWithoutConferenceOrganizationsInput = {
    where: ConferenceTopicsWhereUniqueInput
    update: XOR<ConferenceTopicsUpdateWithoutConferenceOrganizationsInput, ConferenceTopicsUncheckedUpdateWithoutConferenceOrganizationsInput>
    create: XOR<ConferenceTopicsCreateWithoutConferenceOrganizationsInput, ConferenceTopicsUncheckedCreateWithoutConferenceOrganizationsInput>
  }

  export type ConferenceTopicsUpdateWithWhereUniqueWithoutConferenceOrganizationsInput = {
    where: ConferenceTopicsWhereUniqueInput
    data: XOR<ConferenceTopicsUpdateWithoutConferenceOrganizationsInput, ConferenceTopicsUncheckedUpdateWithoutConferenceOrganizationsInput>
  }

  export type ConferenceTopicsUpdateManyWithWhereWithoutConferenceOrganizationsInput = {
    where: ConferenceTopicsScalarWhereInput
    data: XOR<ConferenceTopicsUpdateManyMutationInput, ConferenceTopicsUncheckedUpdateManyWithoutConferenceOrganizationsInput>
  }

  export type ConferenceTopicsScalarWhereInput = {
    AND?: ConferenceTopicsScalarWhereInput | ConferenceTopicsScalarWhereInput[]
    OR?: ConferenceTopicsScalarWhereInput[]
    NOT?: ConferenceTopicsScalarWhereInput | ConferenceTopicsScalarWhereInput[]
    id?: StringFilter<"ConferenceTopics"> | string
    organizeId?: StringFilter<"ConferenceTopics"> | string
    topicId?: StringFilter<"ConferenceTopics"> | string
    createdAt?: DateTimeFilter<"ConferenceTopics"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceTopics"> | Date | string
  }

  export type LocationsUpsertWithWhereUniqueWithoutConferenceOrganizationsInput = {
    where: LocationsWhereUniqueInput
    update: XOR<LocationsUpdateWithoutConferenceOrganizationsInput, LocationsUncheckedUpdateWithoutConferenceOrganizationsInput>
    create: XOR<LocationsCreateWithoutConferenceOrganizationsInput, LocationsUncheckedCreateWithoutConferenceOrganizationsInput>
  }

  export type LocationsUpdateWithWhereUniqueWithoutConferenceOrganizationsInput = {
    where: LocationsWhereUniqueInput
    data: XOR<LocationsUpdateWithoutConferenceOrganizationsInput, LocationsUncheckedUpdateWithoutConferenceOrganizationsInput>
  }

  export type LocationsUpdateManyWithWhereWithoutConferenceOrganizationsInput = {
    where: LocationsScalarWhereInput
    data: XOR<LocationsUpdateManyMutationInput, LocationsUncheckedUpdateManyWithoutConferenceOrganizationsInput>
  }

  export type LocationsScalarWhereInput = {
    AND?: LocationsScalarWhereInput | LocationsScalarWhereInput[]
    OR?: LocationsScalarWhereInput[]
    NOT?: LocationsScalarWhereInput | LocationsScalarWhereInput[]
    id?: StringFilter<"Locations"> | string
    address?: StringNullableFilter<"Locations"> | string | null
    cityStateProvince?: StringNullableFilter<"Locations"> | string | null
    country?: StringNullableFilter<"Locations"> | string | null
    continent?: StringNullableFilter<"Locations"> | string | null
    createdAt?: DateTimeFilter<"Locations"> | Date | string
    updatedAt?: DateTimeFilter<"Locations"> | Date | string
    isAvailable?: BoolFilter<"Locations"> | boolean
    organizeId?: StringFilter<"Locations"> | string
  }

  export type ConferencesCreateWithoutConferenceRanksInput = {
    id: string
    title: string
    acronym: string
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
    ConferenceBlacklists?: ConferenceBlacklistsCreateNestedManyWithoutConferencesInput
    ConferenceCalendars?: ConferenceCalendarsCreateNestedManyWithoutConferencesInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsCreateNestedManyWithoutConferencesInput
    ConferenceFeedbacks?: ConferenceFeedbacksCreateNestedManyWithoutConferencesInput
    ConferenceFollows?: ConferenceFollowsCreateNestedManyWithoutConferencesInput
    ConferenceLikes?: ConferenceLikesCreateNestedManyWithoutConferencesInput
    ConferenceOrganizations?: ConferenceOrganizationsCreateNestedManyWithoutConferencesInput
    Admins?: AdminsCreateNestedOneWithoutConferencesInput
    Users?: UsersCreateNestedOneWithoutConferencesInput
  }

  export type ConferencesUncheckedCreateWithoutConferenceRanksInput = {
    id: string
    title: string
    acronym: string
    creatorId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
    adminId?: string | null
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceFollows?: ConferenceFollowsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceLikes?: ConferenceLikesUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceOrganizations?: ConferenceOrganizationsUncheckedCreateNestedManyWithoutConferencesInput
  }

  export type ConferencesCreateOrConnectWithoutConferenceRanksInput = {
    where: ConferencesWhereUniqueInput
    create: XOR<ConferencesCreateWithoutConferenceRanksInput, ConferencesUncheckedCreateWithoutConferenceRanksInput>
  }

  export type FieldOfResearchsCreateWithoutConferenceRanksInput = {
    id: string
    name: string
    code: string
    JournalRanks?: JournalRanksCreateNestedManyWithoutFieldOfResearchsInput
  }

  export type FieldOfResearchsUncheckedCreateWithoutConferenceRanksInput = {
    id: string
    name: string
    code: string
    JournalRanks?: JournalRanksUncheckedCreateNestedManyWithoutFieldOfResearchsInput
  }

  export type FieldOfResearchsCreateOrConnectWithoutConferenceRanksInput = {
    where: FieldOfResearchsWhereUniqueInput
    create: XOR<FieldOfResearchsCreateWithoutConferenceRanksInput, FieldOfResearchsUncheckedCreateWithoutConferenceRanksInput>
  }

  export type RanksCreateWithoutConferenceRanksInput = {
    id: string
    name: string
    value: number
    JournalRanks?: JournalRanksCreateNestedManyWithoutRanksInput
    Sources: SourcesCreateNestedOneWithoutRanksInput
  }

  export type RanksUncheckedCreateWithoutConferenceRanksInput = {
    id: string
    name: string
    value: number
    sourceId: string
    JournalRanks?: JournalRanksUncheckedCreateNestedManyWithoutRanksInput
  }

  export type RanksCreateOrConnectWithoutConferenceRanksInput = {
    where: RanksWhereUniqueInput
    create: XOR<RanksCreateWithoutConferenceRanksInput, RanksUncheckedCreateWithoutConferenceRanksInput>
  }

  export type ConferencesUpsertWithoutConferenceRanksInput = {
    update: XOR<ConferencesUpdateWithoutConferenceRanksInput, ConferencesUncheckedUpdateWithoutConferenceRanksInput>
    create: XOR<ConferencesCreateWithoutConferenceRanksInput, ConferencesUncheckedCreateWithoutConferenceRanksInput>
    where?: ConferencesWhereInput
  }

  export type ConferencesUpdateToOneWithWhereWithoutConferenceRanksInput = {
    where?: ConferencesWhereInput
    data: XOR<ConferencesUpdateWithoutConferenceRanksInput, ConferencesUncheckedUpdateWithoutConferenceRanksInput>
  }

  export type ConferencesUpdateWithoutConferenceRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUpdateManyWithoutConferencesNestedInput
    ConferenceCalendars?: ConferenceCalendarsUpdateManyWithoutConferencesNestedInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUpdateManyWithoutConferencesNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUpdateManyWithoutConferencesNestedInput
    ConferenceFollows?: ConferenceFollowsUpdateManyWithoutConferencesNestedInput
    ConferenceLikes?: ConferenceLikesUpdateManyWithoutConferencesNestedInput
    ConferenceOrganizations?: ConferenceOrganizationsUpdateManyWithoutConferencesNestedInput
    Admins?: AdminsUpdateOneWithoutConferencesNestedInput
    Users?: UsersUpdateOneWithoutConferencesNestedInput
  }

  export type ConferencesUncheckedUpdateWithoutConferenceRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceFollows?: ConferenceFollowsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceLikes?: ConferenceLikesUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceOrganizations?: ConferenceOrganizationsUncheckedUpdateManyWithoutConferencesNestedInput
  }

  export type FieldOfResearchsUpsertWithoutConferenceRanksInput = {
    update: XOR<FieldOfResearchsUpdateWithoutConferenceRanksInput, FieldOfResearchsUncheckedUpdateWithoutConferenceRanksInput>
    create: XOR<FieldOfResearchsCreateWithoutConferenceRanksInput, FieldOfResearchsUncheckedCreateWithoutConferenceRanksInput>
    where?: FieldOfResearchsWhereInput
  }

  export type FieldOfResearchsUpdateToOneWithWhereWithoutConferenceRanksInput = {
    where?: FieldOfResearchsWhereInput
    data: XOR<FieldOfResearchsUpdateWithoutConferenceRanksInput, FieldOfResearchsUncheckedUpdateWithoutConferenceRanksInput>
  }

  export type FieldOfResearchsUpdateWithoutConferenceRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    JournalRanks?: JournalRanksUpdateManyWithoutFieldOfResearchsNestedInput
  }

  export type FieldOfResearchsUncheckedUpdateWithoutConferenceRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    JournalRanks?: JournalRanksUncheckedUpdateManyWithoutFieldOfResearchsNestedInput
  }

  export type RanksUpsertWithoutConferenceRanksInput = {
    update: XOR<RanksUpdateWithoutConferenceRanksInput, RanksUncheckedUpdateWithoutConferenceRanksInput>
    create: XOR<RanksCreateWithoutConferenceRanksInput, RanksUncheckedCreateWithoutConferenceRanksInput>
    where?: RanksWhereInput
  }

  export type RanksUpdateToOneWithWhereWithoutConferenceRanksInput = {
    where?: RanksWhereInput
    data: XOR<RanksUpdateWithoutConferenceRanksInput, RanksUncheckedUpdateWithoutConferenceRanksInput>
  }

  export type RanksUpdateWithoutConferenceRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    JournalRanks?: JournalRanksUpdateManyWithoutRanksNestedInput
    Sources?: SourcesUpdateOneRequiredWithoutRanksNestedInput
  }

  export type RanksUncheckedUpdateWithoutConferenceRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    sourceId?: StringFieldUpdateOperationsInput | string
    JournalRanks?: JournalRanksUncheckedUpdateManyWithoutRanksNestedInput
  }

  export type ConferenceOrganizationsCreateWithoutConferenceTopicsInput = {
    id: string
    year?: number | null
    accessType: string
    isAvailable: boolean
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt?: Date | string
    updatedAt: Date | string
    ConferenceDates?: ConferenceDatesCreateNestedManyWithoutConferenceOrganizationsInput
    Conferences: ConferencesCreateNestedOneWithoutConferenceOrganizationsInput
    Locations?: LocationsCreateNestedManyWithoutConferenceOrganizationsInput
  }

  export type ConferenceOrganizationsUncheckedCreateWithoutConferenceTopicsInput = {
    id: string
    year?: number | null
    accessType: string
    isAvailable: boolean
    conferenceId: string
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt?: Date | string
    updatedAt: Date | string
    ConferenceDates?: ConferenceDatesUncheckedCreateNestedManyWithoutConferenceOrganizationsInput
    Locations?: LocationsUncheckedCreateNestedManyWithoutConferenceOrganizationsInput
  }

  export type ConferenceOrganizationsCreateOrConnectWithoutConferenceTopicsInput = {
    where: ConferenceOrganizationsWhereUniqueInput
    create: XOR<ConferenceOrganizationsCreateWithoutConferenceTopicsInput, ConferenceOrganizationsUncheckedCreateWithoutConferenceTopicsInput>
  }

  export type TopicsCreateWithoutConferenceTopicsInput = {
    id: string
    name: string
    createdAt?: Date | string
    updatedAt: Date | string
    JournalTopics?: JournalTopicsCreateNestedManyWithoutTopicsInput
    TopicUserInteresteds?: TopicUserInterestedsCreateNestedManyWithoutTopicsInput
  }

  export type TopicsUncheckedCreateWithoutConferenceTopicsInput = {
    id: string
    name: string
    createdAt?: Date | string
    updatedAt: Date | string
    JournalTopics?: JournalTopicsUncheckedCreateNestedManyWithoutTopicsInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedCreateNestedManyWithoutTopicsInput
  }

  export type TopicsCreateOrConnectWithoutConferenceTopicsInput = {
    where: TopicsWhereUniqueInput
    create: XOR<TopicsCreateWithoutConferenceTopicsInput, TopicsUncheckedCreateWithoutConferenceTopicsInput>
  }

  export type ConferenceOrganizationsUpsertWithoutConferenceTopicsInput = {
    update: XOR<ConferenceOrganizationsUpdateWithoutConferenceTopicsInput, ConferenceOrganizationsUncheckedUpdateWithoutConferenceTopicsInput>
    create: XOR<ConferenceOrganizationsCreateWithoutConferenceTopicsInput, ConferenceOrganizationsUncheckedCreateWithoutConferenceTopicsInput>
    where?: ConferenceOrganizationsWhereInput
  }

  export type ConferenceOrganizationsUpdateToOneWithWhereWithoutConferenceTopicsInput = {
    where?: ConferenceOrganizationsWhereInput
    data: XOR<ConferenceOrganizationsUpdateWithoutConferenceTopicsInput, ConferenceOrganizationsUncheckedUpdateWithoutConferenceTopicsInput>
  }

  export type ConferenceOrganizationsUpdateWithoutConferenceTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ConferenceDates?: ConferenceDatesUpdateManyWithoutConferenceOrganizationsNestedInput
    Conferences?: ConferencesUpdateOneRequiredWithoutConferenceOrganizationsNestedInput
    Locations?: LocationsUpdateManyWithoutConferenceOrganizationsNestedInput
  }

  export type ConferenceOrganizationsUncheckedUpdateWithoutConferenceTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    conferenceId?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ConferenceDates?: ConferenceDatesUncheckedUpdateManyWithoutConferenceOrganizationsNestedInput
    Locations?: LocationsUncheckedUpdateManyWithoutConferenceOrganizationsNestedInput
  }

  export type TopicsUpsertWithoutConferenceTopicsInput = {
    update: XOR<TopicsUpdateWithoutConferenceTopicsInput, TopicsUncheckedUpdateWithoutConferenceTopicsInput>
    create: XOR<TopicsCreateWithoutConferenceTopicsInput, TopicsUncheckedCreateWithoutConferenceTopicsInput>
    where?: TopicsWhereInput
  }

  export type TopicsUpdateToOneWithWhereWithoutConferenceTopicsInput = {
    where?: TopicsWhereInput
    data: XOR<TopicsUpdateWithoutConferenceTopicsInput, TopicsUncheckedUpdateWithoutConferenceTopicsInput>
  }

  export type TopicsUpdateWithoutConferenceTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    JournalTopics?: JournalTopicsUpdateManyWithoutTopicsNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUpdateManyWithoutTopicsNestedInput
  }

  export type TopicsUncheckedUpdateWithoutConferenceTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    JournalTopics?: JournalTopicsUncheckedUpdateManyWithoutTopicsNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedUpdateManyWithoutTopicsNestedInput
  }

  export type ConferenceBlacklistsCreateWithoutConferencesInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    Users: UsersCreateNestedOneWithoutConferenceBlacklistsInput
  }

  export type ConferenceBlacklistsUncheckedCreateWithoutConferencesInput = {
    id: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceBlacklistsCreateOrConnectWithoutConferencesInput = {
    where: ConferenceBlacklistsWhereUniqueInput
    create: XOR<ConferenceBlacklistsCreateWithoutConferencesInput, ConferenceBlacklistsUncheckedCreateWithoutConferencesInput>
  }

  export type ConferenceBlacklistsCreateManyConferencesInputEnvelope = {
    data: ConferenceBlacklistsCreateManyConferencesInput | ConferenceBlacklistsCreateManyConferencesInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceCalendarsCreateWithoutConferencesInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    Users: UsersCreateNestedOneWithoutConferenceCalendarsInput
  }

  export type ConferenceCalendarsUncheckedCreateWithoutConferencesInput = {
    id: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceCalendarsCreateOrConnectWithoutConferencesInput = {
    where: ConferenceCalendarsWhereUniqueInput
    create: XOR<ConferenceCalendarsCreateWithoutConferencesInput, ConferenceCalendarsUncheckedCreateWithoutConferencesInput>
  }

  export type ConferenceCalendarsCreateManyConferencesInputEnvelope = {
    data: ConferenceCalendarsCreateManyConferencesInput | ConferenceCalendarsCreateManyConferencesInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceCrawlJobsCreateWithoutConferencesInput = {
    id: string
    status: string
    progress: number
    message: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceCrawlJobsUncheckedCreateWithoutConferencesInput = {
    id: string
    status: string
    progress: number
    message: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceCrawlJobsCreateOrConnectWithoutConferencesInput = {
    where: ConferenceCrawlJobsWhereUniqueInput
    create: XOR<ConferenceCrawlJobsCreateWithoutConferencesInput, ConferenceCrawlJobsUncheckedCreateWithoutConferencesInput>
  }

  export type ConferenceCrawlJobsCreateManyConferencesInputEnvelope = {
    data: ConferenceCrawlJobsCreateManyConferencesInput | ConferenceCrawlJobsCreateManyConferencesInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceFeedbacksCreateWithoutConferencesInput = {
    id: string
    description: string
    star: number
    createdAt?: Date | string
    updatedAt: Date | string
    Users: UsersCreateNestedOneWithoutConferenceFeedbacksInput
  }

  export type ConferenceFeedbacksUncheckedCreateWithoutConferencesInput = {
    id: string
    creatorId: string
    description: string
    star: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceFeedbacksCreateOrConnectWithoutConferencesInput = {
    where: ConferenceFeedbacksWhereUniqueInput
    create: XOR<ConferenceFeedbacksCreateWithoutConferencesInput, ConferenceFeedbacksUncheckedCreateWithoutConferencesInput>
  }

  export type ConferenceFeedbacksCreateManyConferencesInputEnvelope = {
    data: ConferenceFeedbacksCreateManyConferencesInput | ConferenceFeedbacksCreateManyConferencesInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceFollowsCreateWithoutConferencesInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    Users: UsersCreateNestedOneWithoutConferenceFollowsInput
  }

  export type ConferenceFollowsUncheckedCreateWithoutConferencesInput = {
    id: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceFollowsCreateOrConnectWithoutConferencesInput = {
    where: ConferenceFollowsWhereUniqueInput
    create: XOR<ConferenceFollowsCreateWithoutConferencesInput, ConferenceFollowsUncheckedCreateWithoutConferencesInput>
  }

  export type ConferenceFollowsCreateManyConferencesInputEnvelope = {
    data: ConferenceFollowsCreateManyConferencesInput | ConferenceFollowsCreateManyConferencesInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceLikesCreateWithoutConferencesInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    Users: UsersCreateNestedOneWithoutConferenceLikesInput
  }

  export type ConferenceLikesUncheckedCreateWithoutConferencesInput = {
    id: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceLikesCreateOrConnectWithoutConferencesInput = {
    where: ConferenceLikesWhereUniqueInput
    create: XOR<ConferenceLikesCreateWithoutConferencesInput, ConferenceLikesUncheckedCreateWithoutConferencesInput>
  }

  export type ConferenceLikesCreateManyConferencesInputEnvelope = {
    data: ConferenceLikesCreateManyConferencesInput | ConferenceLikesCreateManyConferencesInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceOrganizationsCreateWithoutConferencesInput = {
    id: string
    year?: number | null
    accessType: string
    isAvailable: boolean
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt?: Date | string
    updatedAt: Date | string
    ConferenceDates?: ConferenceDatesCreateNestedManyWithoutConferenceOrganizationsInput
    ConferenceTopics?: ConferenceTopicsCreateNestedManyWithoutConferenceOrganizationsInput
    Locations?: LocationsCreateNestedManyWithoutConferenceOrganizationsInput
  }

  export type ConferenceOrganizationsUncheckedCreateWithoutConferencesInput = {
    id: string
    year?: number | null
    accessType: string
    isAvailable: boolean
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt?: Date | string
    updatedAt: Date | string
    ConferenceDates?: ConferenceDatesUncheckedCreateNestedManyWithoutConferenceOrganizationsInput
    ConferenceTopics?: ConferenceTopicsUncheckedCreateNestedManyWithoutConferenceOrganizationsInput
    Locations?: LocationsUncheckedCreateNestedManyWithoutConferenceOrganizationsInput
  }

  export type ConferenceOrganizationsCreateOrConnectWithoutConferencesInput = {
    where: ConferenceOrganizationsWhereUniqueInput
    create: XOR<ConferenceOrganizationsCreateWithoutConferencesInput, ConferenceOrganizationsUncheckedCreateWithoutConferencesInput>
  }

  export type ConferenceOrganizationsCreateManyConferencesInputEnvelope = {
    data: ConferenceOrganizationsCreateManyConferencesInput | ConferenceOrganizationsCreateManyConferencesInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceRanksCreateWithoutConferencesInput = {
    id: string
    year: number
    FieldOfResearchs: FieldOfResearchsCreateNestedOneWithoutConferenceRanksInput
    Ranks: RanksCreateNestedOneWithoutConferenceRanksInput
  }

  export type ConferenceRanksUncheckedCreateWithoutConferencesInput = {
    id: string
    year: number
    fieldOfResearchId: string
    rankId: string
  }

  export type ConferenceRanksCreateOrConnectWithoutConferencesInput = {
    where: ConferenceRanksWhereUniqueInput
    create: XOR<ConferenceRanksCreateWithoutConferencesInput, ConferenceRanksUncheckedCreateWithoutConferencesInput>
  }

  export type ConferenceRanksCreateManyConferencesInputEnvelope = {
    data: ConferenceRanksCreateManyConferencesInput | ConferenceRanksCreateManyConferencesInput[]
    skipDuplicates?: boolean
  }

  export type AdminsCreateWithoutConferencesInput = {
    id: string
    email: string
    password: string
    fullName: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type AdminsUncheckedCreateWithoutConferencesInput = {
    id: string
    email: string
    password: string
    fullName: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type AdminsCreateOrConnectWithoutConferencesInput = {
    where: AdminsWhereUniqueInput
    create: XOR<AdminsCreateWithoutConferencesInput, AdminsUncheckedCreateWithoutConferencesInput>
  }

  export type UsersCreateWithoutConferencesInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsCreateNestedManyWithoutUsersInput
    ConferenceCalendars?: ConferenceCalendarsCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesCreateNestedManyWithoutUsersInput
    Journals?: JournalsCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutConferencesInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesUncheckedCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesUncheckedCreateNestedManyWithoutUsersInput
    Journals?: JournalsUncheckedCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutConferencesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutConferencesInput, UsersUncheckedCreateWithoutConferencesInput>
  }

  export type ConferenceBlacklistsUpsertWithWhereUniqueWithoutConferencesInput = {
    where: ConferenceBlacklistsWhereUniqueInput
    update: XOR<ConferenceBlacklistsUpdateWithoutConferencesInput, ConferenceBlacklistsUncheckedUpdateWithoutConferencesInput>
    create: XOR<ConferenceBlacklistsCreateWithoutConferencesInput, ConferenceBlacklistsUncheckedCreateWithoutConferencesInput>
  }

  export type ConferenceBlacklistsUpdateWithWhereUniqueWithoutConferencesInput = {
    where: ConferenceBlacklistsWhereUniqueInput
    data: XOR<ConferenceBlacklistsUpdateWithoutConferencesInput, ConferenceBlacklistsUncheckedUpdateWithoutConferencesInput>
  }

  export type ConferenceBlacklistsUpdateManyWithWhereWithoutConferencesInput = {
    where: ConferenceBlacklistsScalarWhereInput
    data: XOR<ConferenceBlacklistsUpdateManyMutationInput, ConferenceBlacklistsUncheckedUpdateManyWithoutConferencesInput>
  }

  export type ConferenceBlacklistsScalarWhereInput = {
    AND?: ConferenceBlacklistsScalarWhereInput | ConferenceBlacklistsScalarWhereInput[]
    OR?: ConferenceBlacklistsScalarWhereInput[]
    NOT?: ConferenceBlacklistsScalarWhereInput | ConferenceBlacklistsScalarWhereInput[]
    id?: StringFilter<"ConferenceBlacklists"> | string
    conferenceId?: StringFilter<"ConferenceBlacklists"> | string
    userId?: StringFilter<"ConferenceBlacklists"> | string
    createdAt?: DateTimeFilter<"ConferenceBlacklists"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceBlacklists"> | Date | string
  }

  export type ConferenceCalendarsUpsertWithWhereUniqueWithoutConferencesInput = {
    where: ConferenceCalendarsWhereUniqueInput
    update: XOR<ConferenceCalendarsUpdateWithoutConferencesInput, ConferenceCalendarsUncheckedUpdateWithoutConferencesInput>
    create: XOR<ConferenceCalendarsCreateWithoutConferencesInput, ConferenceCalendarsUncheckedCreateWithoutConferencesInput>
  }

  export type ConferenceCalendarsUpdateWithWhereUniqueWithoutConferencesInput = {
    where: ConferenceCalendarsWhereUniqueInput
    data: XOR<ConferenceCalendarsUpdateWithoutConferencesInput, ConferenceCalendarsUncheckedUpdateWithoutConferencesInput>
  }

  export type ConferenceCalendarsUpdateManyWithWhereWithoutConferencesInput = {
    where: ConferenceCalendarsScalarWhereInput
    data: XOR<ConferenceCalendarsUpdateManyMutationInput, ConferenceCalendarsUncheckedUpdateManyWithoutConferencesInput>
  }

  export type ConferenceCalendarsScalarWhereInput = {
    AND?: ConferenceCalendarsScalarWhereInput | ConferenceCalendarsScalarWhereInput[]
    OR?: ConferenceCalendarsScalarWhereInput[]
    NOT?: ConferenceCalendarsScalarWhereInput | ConferenceCalendarsScalarWhereInput[]
    id?: StringFilter<"ConferenceCalendars"> | string
    conferenceId?: StringFilter<"ConferenceCalendars"> | string
    userId?: StringFilter<"ConferenceCalendars"> | string
    createdAt?: DateTimeFilter<"ConferenceCalendars"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceCalendars"> | Date | string
  }

  export type ConferenceCrawlJobsUpsertWithWhereUniqueWithoutConferencesInput = {
    where: ConferenceCrawlJobsWhereUniqueInput
    update: XOR<ConferenceCrawlJobsUpdateWithoutConferencesInput, ConferenceCrawlJobsUncheckedUpdateWithoutConferencesInput>
    create: XOR<ConferenceCrawlJobsCreateWithoutConferencesInput, ConferenceCrawlJobsUncheckedCreateWithoutConferencesInput>
  }

  export type ConferenceCrawlJobsUpdateWithWhereUniqueWithoutConferencesInput = {
    where: ConferenceCrawlJobsWhereUniqueInput
    data: XOR<ConferenceCrawlJobsUpdateWithoutConferencesInput, ConferenceCrawlJobsUncheckedUpdateWithoutConferencesInput>
  }

  export type ConferenceCrawlJobsUpdateManyWithWhereWithoutConferencesInput = {
    where: ConferenceCrawlJobsScalarWhereInput
    data: XOR<ConferenceCrawlJobsUpdateManyMutationInput, ConferenceCrawlJobsUncheckedUpdateManyWithoutConferencesInput>
  }

  export type ConferenceCrawlJobsScalarWhereInput = {
    AND?: ConferenceCrawlJobsScalarWhereInput | ConferenceCrawlJobsScalarWhereInput[]
    OR?: ConferenceCrawlJobsScalarWhereInput[]
    NOT?: ConferenceCrawlJobsScalarWhereInput | ConferenceCrawlJobsScalarWhereInput[]
    id?: StringFilter<"ConferenceCrawlJobs"> | string
    conferenceId?: StringFilter<"ConferenceCrawlJobs"> | string
    status?: StringFilter<"ConferenceCrawlJobs"> | string
    progress?: IntFilter<"ConferenceCrawlJobs"> | number
    message?: StringFilter<"ConferenceCrawlJobs"> | string
    createdAt?: DateTimeFilter<"ConferenceCrawlJobs"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceCrawlJobs"> | Date | string
  }

  export type ConferenceFeedbacksUpsertWithWhereUniqueWithoutConferencesInput = {
    where: ConferenceFeedbacksWhereUniqueInput
    update: XOR<ConferenceFeedbacksUpdateWithoutConferencesInput, ConferenceFeedbacksUncheckedUpdateWithoutConferencesInput>
    create: XOR<ConferenceFeedbacksCreateWithoutConferencesInput, ConferenceFeedbacksUncheckedCreateWithoutConferencesInput>
  }

  export type ConferenceFeedbacksUpdateWithWhereUniqueWithoutConferencesInput = {
    where: ConferenceFeedbacksWhereUniqueInput
    data: XOR<ConferenceFeedbacksUpdateWithoutConferencesInput, ConferenceFeedbacksUncheckedUpdateWithoutConferencesInput>
  }

  export type ConferenceFeedbacksUpdateManyWithWhereWithoutConferencesInput = {
    where: ConferenceFeedbacksScalarWhereInput
    data: XOR<ConferenceFeedbacksUpdateManyMutationInput, ConferenceFeedbacksUncheckedUpdateManyWithoutConferencesInput>
  }

  export type ConferenceFeedbacksScalarWhereInput = {
    AND?: ConferenceFeedbacksScalarWhereInput | ConferenceFeedbacksScalarWhereInput[]
    OR?: ConferenceFeedbacksScalarWhereInput[]
    NOT?: ConferenceFeedbacksScalarWhereInput | ConferenceFeedbacksScalarWhereInput[]
    id?: StringFilter<"ConferenceFeedbacks"> | string
    conferenceId?: StringFilter<"ConferenceFeedbacks"> | string
    creatorId?: StringFilter<"ConferenceFeedbacks"> | string
    description?: StringFilter<"ConferenceFeedbacks"> | string
    star?: IntFilter<"ConferenceFeedbacks"> | number
    createdAt?: DateTimeFilter<"ConferenceFeedbacks"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceFeedbacks"> | Date | string
  }

  export type ConferenceFollowsUpsertWithWhereUniqueWithoutConferencesInput = {
    where: ConferenceFollowsWhereUniqueInput
    update: XOR<ConferenceFollowsUpdateWithoutConferencesInput, ConferenceFollowsUncheckedUpdateWithoutConferencesInput>
    create: XOR<ConferenceFollowsCreateWithoutConferencesInput, ConferenceFollowsUncheckedCreateWithoutConferencesInput>
  }

  export type ConferenceFollowsUpdateWithWhereUniqueWithoutConferencesInput = {
    where: ConferenceFollowsWhereUniqueInput
    data: XOR<ConferenceFollowsUpdateWithoutConferencesInput, ConferenceFollowsUncheckedUpdateWithoutConferencesInput>
  }

  export type ConferenceFollowsUpdateManyWithWhereWithoutConferencesInput = {
    where: ConferenceFollowsScalarWhereInput
    data: XOR<ConferenceFollowsUpdateManyMutationInput, ConferenceFollowsUncheckedUpdateManyWithoutConferencesInput>
  }

  export type ConferenceFollowsScalarWhereInput = {
    AND?: ConferenceFollowsScalarWhereInput | ConferenceFollowsScalarWhereInput[]
    OR?: ConferenceFollowsScalarWhereInput[]
    NOT?: ConferenceFollowsScalarWhereInput | ConferenceFollowsScalarWhereInput[]
    id?: StringFilter<"ConferenceFollows"> | string
    conferenceId?: StringFilter<"ConferenceFollows"> | string
    userId?: StringFilter<"ConferenceFollows"> | string
    createdAt?: DateTimeFilter<"ConferenceFollows"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceFollows"> | Date | string
  }

  export type ConferenceLikesUpsertWithWhereUniqueWithoutConferencesInput = {
    where: ConferenceLikesWhereUniqueInput
    update: XOR<ConferenceLikesUpdateWithoutConferencesInput, ConferenceLikesUncheckedUpdateWithoutConferencesInput>
    create: XOR<ConferenceLikesCreateWithoutConferencesInput, ConferenceLikesUncheckedCreateWithoutConferencesInput>
  }

  export type ConferenceLikesUpdateWithWhereUniqueWithoutConferencesInput = {
    where: ConferenceLikesWhereUniqueInput
    data: XOR<ConferenceLikesUpdateWithoutConferencesInput, ConferenceLikesUncheckedUpdateWithoutConferencesInput>
  }

  export type ConferenceLikesUpdateManyWithWhereWithoutConferencesInput = {
    where: ConferenceLikesScalarWhereInput
    data: XOR<ConferenceLikesUpdateManyMutationInput, ConferenceLikesUncheckedUpdateManyWithoutConferencesInput>
  }

  export type ConferenceLikesScalarWhereInput = {
    AND?: ConferenceLikesScalarWhereInput | ConferenceLikesScalarWhereInput[]
    OR?: ConferenceLikesScalarWhereInput[]
    NOT?: ConferenceLikesScalarWhereInput | ConferenceLikesScalarWhereInput[]
    id?: StringFilter<"ConferenceLikes"> | string
    conferenceId?: StringFilter<"ConferenceLikes"> | string
    userId?: StringFilter<"ConferenceLikes"> | string
    createdAt?: DateTimeFilter<"ConferenceLikes"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceLikes"> | Date | string
  }

  export type ConferenceOrganizationsUpsertWithWhereUniqueWithoutConferencesInput = {
    where: ConferenceOrganizationsWhereUniqueInput
    update: XOR<ConferenceOrganizationsUpdateWithoutConferencesInput, ConferenceOrganizationsUncheckedUpdateWithoutConferencesInput>
    create: XOR<ConferenceOrganizationsCreateWithoutConferencesInput, ConferenceOrganizationsUncheckedCreateWithoutConferencesInput>
  }

  export type ConferenceOrganizationsUpdateWithWhereUniqueWithoutConferencesInput = {
    where: ConferenceOrganizationsWhereUniqueInput
    data: XOR<ConferenceOrganizationsUpdateWithoutConferencesInput, ConferenceOrganizationsUncheckedUpdateWithoutConferencesInput>
  }

  export type ConferenceOrganizationsUpdateManyWithWhereWithoutConferencesInput = {
    where: ConferenceOrganizationsScalarWhereInput
    data: XOR<ConferenceOrganizationsUpdateManyMutationInput, ConferenceOrganizationsUncheckedUpdateManyWithoutConferencesInput>
  }

  export type ConferenceOrganizationsScalarWhereInput = {
    AND?: ConferenceOrganizationsScalarWhereInput | ConferenceOrganizationsScalarWhereInput[]
    OR?: ConferenceOrganizationsScalarWhereInput[]
    NOT?: ConferenceOrganizationsScalarWhereInput | ConferenceOrganizationsScalarWhereInput[]
    id?: StringFilter<"ConferenceOrganizations"> | string
    year?: IntNullableFilter<"ConferenceOrganizations"> | number | null
    accessType?: StringFilter<"ConferenceOrganizations"> | string
    isAvailable?: BoolFilter<"ConferenceOrganizations"> | boolean
    conferenceId?: StringFilter<"ConferenceOrganizations"> | string
    publisher?: StringFilter<"ConferenceOrganizations"> | string
    summerize?: StringFilter<"ConferenceOrganizations"> | string
    callForPaper?: StringFilter<"ConferenceOrganizations"> | string
    link?: StringFilter<"ConferenceOrganizations"> | string
    cfpLink?: StringFilter<"ConferenceOrganizations"> | string
    impLink?: StringFilter<"ConferenceOrganizations"> | string
    createdAt?: DateTimeFilter<"ConferenceOrganizations"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceOrganizations"> | Date | string
  }

  export type ConferenceRanksUpsertWithWhereUniqueWithoutConferencesInput = {
    where: ConferenceRanksWhereUniqueInput
    update: XOR<ConferenceRanksUpdateWithoutConferencesInput, ConferenceRanksUncheckedUpdateWithoutConferencesInput>
    create: XOR<ConferenceRanksCreateWithoutConferencesInput, ConferenceRanksUncheckedCreateWithoutConferencesInput>
  }

  export type ConferenceRanksUpdateWithWhereUniqueWithoutConferencesInput = {
    where: ConferenceRanksWhereUniqueInput
    data: XOR<ConferenceRanksUpdateWithoutConferencesInput, ConferenceRanksUncheckedUpdateWithoutConferencesInput>
  }

  export type ConferenceRanksUpdateManyWithWhereWithoutConferencesInput = {
    where: ConferenceRanksScalarWhereInput
    data: XOR<ConferenceRanksUpdateManyMutationInput, ConferenceRanksUncheckedUpdateManyWithoutConferencesInput>
  }

  export type ConferenceRanksScalarWhereInput = {
    AND?: ConferenceRanksScalarWhereInput | ConferenceRanksScalarWhereInput[]
    OR?: ConferenceRanksScalarWhereInput[]
    NOT?: ConferenceRanksScalarWhereInput | ConferenceRanksScalarWhereInput[]
    id?: StringFilter<"ConferenceRanks"> | string
    year?: IntFilter<"ConferenceRanks"> | number
    conferenceId?: StringFilter<"ConferenceRanks"> | string
    fieldOfResearchId?: StringFilter<"ConferenceRanks"> | string
    rankId?: StringFilter<"ConferenceRanks"> | string
  }

  export type AdminsUpsertWithoutConferencesInput = {
    update: XOR<AdminsUpdateWithoutConferencesInput, AdminsUncheckedUpdateWithoutConferencesInput>
    create: XOR<AdminsCreateWithoutConferencesInput, AdminsUncheckedCreateWithoutConferencesInput>
    where?: AdminsWhereInput
  }

  export type AdminsUpdateToOneWithWhereWithoutConferencesInput = {
    where?: AdminsWhereInput
    data: XOR<AdminsUpdateWithoutConferencesInput, AdminsUncheckedUpdateWithoutConferencesInput>
  }

  export type AdminsUpdateWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminsUncheckedUpdateWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersUpsertWithoutConferencesInput = {
    update: XOR<UsersUpdateWithoutConferencesInput, UsersUncheckedUpdateWithoutConferencesInput>
    create: XOR<UsersCreateWithoutConferencesInput, UsersUncheckedCreateWithoutConferencesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutConferencesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutConferencesInput, UsersUncheckedUpdateWithoutConferencesInput>
  }

  export type UsersUpdateWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUpdateManyWithoutUsersNestedInput
    ConferenceCalendars?: ConferenceCalendarsUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUncheckedUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUncheckedUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUncheckedUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUncheckedUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type ConferenceRanksCreateWithoutFieldOfResearchsInput = {
    id: string
    year: number
    Conferences: ConferencesCreateNestedOneWithoutConferenceRanksInput
    Ranks: RanksCreateNestedOneWithoutConferenceRanksInput
  }

  export type ConferenceRanksUncheckedCreateWithoutFieldOfResearchsInput = {
    id: string
    year: number
    conferenceId: string
    rankId: string
  }

  export type ConferenceRanksCreateOrConnectWithoutFieldOfResearchsInput = {
    where: ConferenceRanksWhereUniqueInput
    create: XOR<ConferenceRanksCreateWithoutFieldOfResearchsInput, ConferenceRanksUncheckedCreateWithoutFieldOfResearchsInput>
  }

  export type ConferenceRanksCreateManyFieldOfResearchsInputEnvelope = {
    data: ConferenceRanksCreateManyFieldOfResearchsInput | ConferenceRanksCreateManyFieldOfResearchsInput[]
    skipDuplicates?: boolean
  }

  export type JournalRanksCreateWithoutFieldOfResearchsInput = {
    id: string
    year: number
    Journals: JournalsCreateNestedOneWithoutJournalRanksInput
    Ranks: RanksCreateNestedOneWithoutJournalRanksInput
  }

  export type JournalRanksUncheckedCreateWithoutFieldOfResearchsInput = {
    id: string
    year: number
    journalId: string
    rankId: string
  }

  export type JournalRanksCreateOrConnectWithoutFieldOfResearchsInput = {
    where: JournalRanksWhereUniqueInput
    create: XOR<JournalRanksCreateWithoutFieldOfResearchsInput, JournalRanksUncheckedCreateWithoutFieldOfResearchsInput>
  }

  export type JournalRanksCreateManyFieldOfResearchsInputEnvelope = {
    data: JournalRanksCreateManyFieldOfResearchsInput | JournalRanksCreateManyFieldOfResearchsInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceRanksUpsertWithWhereUniqueWithoutFieldOfResearchsInput = {
    where: ConferenceRanksWhereUniqueInput
    update: XOR<ConferenceRanksUpdateWithoutFieldOfResearchsInput, ConferenceRanksUncheckedUpdateWithoutFieldOfResearchsInput>
    create: XOR<ConferenceRanksCreateWithoutFieldOfResearchsInput, ConferenceRanksUncheckedCreateWithoutFieldOfResearchsInput>
  }

  export type ConferenceRanksUpdateWithWhereUniqueWithoutFieldOfResearchsInput = {
    where: ConferenceRanksWhereUniqueInput
    data: XOR<ConferenceRanksUpdateWithoutFieldOfResearchsInput, ConferenceRanksUncheckedUpdateWithoutFieldOfResearchsInput>
  }

  export type ConferenceRanksUpdateManyWithWhereWithoutFieldOfResearchsInput = {
    where: ConferenceRanksScalarWhereInput
    data: XOR<ConferenceRanksUpdateManyMutationInput, ConferenceRanksUncheckedUpdateManyWithoutFieldOfResearchsInput>
  }

  export type JournalRanksUpsertWithWhereUniqueWithoutFieldOfResearchsInput = {
    where: JournalRanksWhereUniqueInput
    update: XOR<JournalRanksUpdateWithoutFieldOfResearchsInput, JournalRanksUncheckedUpdateWithoutFieldOfResearchsInput>
    create: XOR<JournalRanksCreateWithoutFieldOfResearchsInput, JournalRanksUncheckedCreateWithoutFieldOfResearchsInput>
  }

  export type JournalRanksUpdateWithWhereUniqueWithoutFieldOfResearchsInput = {
    where: JournalRanksWhereUniqueInput
    data: XOR<JournalRanksUpdateWithoutFieldOfResearchsInput, JournalRanksUncheckedUpdateWithoutFieldOfResearchsInput>
  }

  export type JournalRanksUpdateManyWithWhereWithoutFieldOfResearchsInput = {
    where: JournalRanksScalarWhereInput
    data: XOR<JournalRanksUpdateManyMutationInput, JournalRanksUncheckedUpdateManyWithoutFieldOfResearchsInput>
  }

  export type JournalRanksScalarWhereInput = {
    AND?: JournalRanksScalarWhereInput | JournalRanksScalarWhereInput[]
    OR?: JournalRanksScalarWhereInput[]
    NOT?: JournalRanksScalarWhereInput | JournalRanksScalarWhereInput[]
    id?: StringFilter<"JournalRanks"> | string
    year?: IntFilter<"JournalRanks"> | number
    journalId?: StringFilter<"JournalRanks"> | string
    fieldOfResearchId?: StringFilter<"JournalRanks"> | string
    rankId?: StringFilter<"JournalRanks"> | string
  }

  export type JournalsCreateWithoutJournalCrawlJobsInput = {
    id: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    JournalFollows?: JournalFollowsCreateNestedManyWithoutJournalsInput
    JournalLikes?: JournalLikesCreateNestedManyWithoutJournalsInput
    JournalRanks?: JournalRanksCreateNestedManyWithoutJournalsInput
    JournalTopics?: JournalTopicsCreateNestedManyWithoutJournalsInput
    Users: UsersCreateNestedOneWithoutJournalsInput
  }

  export type JournalsUncheckedCreateWithoutJournalCrawlJobsInput = {
    id: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    creator: string
    JournalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutJournalsInput
    JournalLikes?: JournalLikesUncheckedCreateNestedManyWithoutJournalsInput
    JournalRanks?: JournalRanksUncheckedCreateNestedManyWithoutJournalsInput
    JournalTopics?: JournalTopicsUncheckedCreateNestedManyWithoutJournalsInput
  }

  export type JournalsCreateOrConnectWithoutJournalCrawlJobsInput = {
    where: JournalsWhereUniqueInput
    create: XOR<JournalsCreateWithoutJournalCrawlJobsInput, JournalsUncheckedCreateWithoutJournalCrawlJobsInput>
  }

  export type JournalsUpsertWithoutJournalCrawlJobsInput = {
    update: XOR<JournalsUpdateWithoutJournalCrawlJobsInput, JournalsUncheckedUpdateWithoutJournalCrawlJobsInput>
    create: XOR<JournalsCreateWithoutJournalCrawlJobsInput, JournalsUncheckedCreateWithoutJournalCrawlJobsInput>
    where?: JournalsWhereInput
  }

  export type JournalsUpdateToOneWithWhereWithoutJournalCrawlJobsInput = {
    where?: JournalsWhereInput
    data: XOR<JournalsUpdateWithoutJournalCrawlJobsInput, JournalsUncheckedUpdateWithoutJournalCrawlJobsInput>
  }

  export type JournalsUpdateWithoutJournalCrawlJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    JournalFollows?: JournalFollowsUpdateManyWithoutJournalsNestedInput
    JournalLikes?: JournalLikesUpdateManyWithoutJournalsNestedInput
    JournalRanks?: JournalRanksUpdateManyWithoutJournalsNestedInput
    JournalTopics?: JournalTopicsUpdateManyWithoutJournalsNestedInput
    Users?: UsersUpdateOneRequiredWithoutJournalsNestedInput
  }

  export type JournalsUncheckedUpdateWithoutJournalCrawlJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    JournalFollows?: JournalFollowsUncheckedUpdateManyWithoutJournalsNestedInput
    JournalLikes?: JournalLikesUncheckedUpdateManyWithoutJournalsNestedInput
    JournalRanks?: JournalRanksUncheckedUpdateManyWithoutJournalsNestedInput
    JournalTopics?: JournalTopicsUncheckedUpdateManyWithoutJournalsNestedInput
  }

  export type JournalsCreateWithoutJournalFollowsInput = {
    id: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    JournalCrawlJobs?: JournalCrawlJobsCreateNestedManyWithoutJournalsInput
    JournalLikes?: JournalLikesCreateNestedManyWithoutJournalsInput
    JournalRanks?: JournalRanksCreateNestedManyWithoutJournalsInput
    JournalTopics?: JournalTopicsCreateNestedManyWithoutJournalsInput
    Users: UsersCreateNestedOneWithoutJournalsInput
  }

  export type JournalsUncheckedCreateWithoutJournalFollowsInput = {
    id: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    creator: string
    JournalCrawlJobs?: JournalCrawlJobsUncheckedCreateNestedManyWithoutJournalsInput
    JournalLikes?: JournalLikesUncheckedCreateNestedManyWithoutJournalsInput
    JournalRanks?: JournalRanksUncheckedCreateNestedManyWithoutJournalsInput
    JournalTopics?: JournalTopicsUncheckedCreateNestedManyWithoutJournalsInput
  }

  export type JournalsCreateOrConnectWithoutJournalFollowsInput = {
    where: JournalsWhereUniqueInput
    create: XOR<JournalsCreateWithoutJournalFollowsInput, JournalsUncheckedCreateWithoutJournalFollowsInput>
  }

  export type UsersCreateWithoutJournalFollowsInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsCreateNestedManyWithoutUsersInput
    ConferenceCalendars?: ConferenceCalendarsCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesCreateNestedManyWithoutUsersInput
    Journals?: JournalsCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutJournalFollowsInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesUncheckedCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesUncheckedCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesUncheckedCreateNestedManyWithoutUsersInput
    Journals?: JournalsUncheckedCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutJournalFollowsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutJournalFollowsInput, UsersUncheckedCreateWithoutJournalFollowsInput>
  }

  export type JournalsUpsertWithoutJournalFollowsInput = {
    update: XOR<JournalsUpdateWithoutJournalFollowsInput, JournalsUncheckedUpdateWithoutJournalFollowsInput>
    create: XOR<JournalsCreateWithoutJournalFollowsInput, JournalsUncheckedCreateWithoutJournalFollowsInput>
    where?: JournalsWhereInput
  }

  export type JournalsUpdateToOneWithWhereWithoutJournalFollowsInput = {
    where?: JournalsWhereInput
    data: XOR<JournalsUpdateWithoutJournalFollowsInput, JournalsUncheckedUpdateWithoutJournalFollowsInput>
  }

  export type JournalsUpdateWithoutJournalFollowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    JournalCrawlJobs?: JournalCrawlJobsUpdateManyWithoutJournalsNestedInput
    JournalLikes?: JournalLikesUpdateManyWithoutJournalsNestedInput
    JournalRanks?: JournalRanksUpdateManyWithoutJournalsNestedInput
    JournalTopics?: JournalTopicsUpdateManyWithoutJournalsNestedInput
    Users?: UsersUpdateOneRequiredWithoutJournalsNestedInput
  }

  export type JournalsUncheckedUpdateWithoutJournalFollowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    JournalCrawlJobs?: JournalCrawlJobsUncheckedUpdateManyWithoutJournalsNestedInput
    JournalLikes?: JournalLikesUncheckedUpdateManyWithoutJournalsNestedInput
    JournalRanks?: JournalRanksUncheckedUpdateManyWithoutJournalsNestedInput
    JournalTopics?: JournalTopicsUncheckedUpdateManyWithoutJournalsNestedInput
  }

  export type UsersUpsertWithoutJournalFollowsInput = {
    update: XOR<UsersUpdateWithoutJournalFollowsInput, UsersUncheckedUpdateWithoutJournalFollowsInput>
    create: XOR<UsersCreateWithoutJournalFollowsInput, UsersUncheckedCreateWithoutJournalFollowsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutJournalFollowsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutJournalFollowsInput, UsersUncheckedUpdateWithoutJournalFollowsInput>
  }

  export type UsersUpdateWithoutJournalFollowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUpdateManyWithoutUsersNestedInput
    ConferenceCalendars?: ConferenceCalendarsUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutJournalFollowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUncheckedUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUncheckedUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUncheckedUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUncheckedUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type JournalsCreateWithoutJournalLikesInput = {
    id: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    JournalCrawlJobs?: JournalCrawlJobsCreateNestedManyWithoutJournalsInput
    JournalFollows?: JournalFollowsCreateNestedManyWithoutJournalsInput
    JournalRanks?: JournalRanksCreateNestedManyWithoutJournalsInput
    JournalTopics?: JournalTopicsCreateNestedManyWithoutJournalsInput
    Users: UsersCreateNestedOneWithoutJournalsInput
  }

  export type JournalsUncheckedCreateWithoutJournalLikesInput = {
    id: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    creator: string
    JournalCrawlJobs?: JournalCrawlJobsUncheckedCreateNestedManyWithoutJournalsInput
    JournalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutJournalsInput
    JournalRanks?: JournalRanksUncheckedCreateNestedManyWithoutJournalsInput
    JournalTopics?: JournalTopicsUncheckedCreateNestedManyWithoutJournalsInput
  }

  export type JournalsCreateOrConnectWithoutJournalLikesInput = {
    where: JournalsWhereUniqueInput
    create: XOR<JournalsCreateWithoutJournalLikesInput, JournalsUncheckedCreateWithoutJournalLikesInput>
  }

  export type UsersCreateWithoutJournalLikesInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsCreateNestedManyWithoutUsersInput
    ConferenceCalendars?: ConferenceCalendarsCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsCreateNestedManyWithoutUsersInput
    Journals?: JournalsCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutJournalLikesInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesUncheckedCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesUncheckedCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutUsersInput
    Journals?: JournalsUncheckedCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutJournalLikesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutJournalLikesInput, UsersUncheckedCreateWithoutJournalLikesInput>
  }

  export type JournalsUpsertWithoutJournalLikesInput = {
    update: XOR<JournalsUpdateWithoutJournalLikesInput, JournalsUncheckedUpdateWithoutJournalLikesInput>
    create: XOR<JournalsCreateWithoutJournalLikesInput, JournalsUncheckedCreateWithoutJournalLikesInput>
    where?: JournalsWhereInput
  }

  export type JournalsUpdateToOneWithWhereWithoutJournalLikesInput = {
    where?: JournalsWhereInput
    data: XOR<JournalsUpdateWithoutJournalLikesInput, JournalsUncheckedUpdateWithoutJournalLikesInput>
  }

  export type JournalsUpdateWithoutJournalLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    JournalCrawlJobs?: JournalCrawlJobsUpdateManyWithoutJournalsNestedInput
    JournalFollows?: JournalFollowsUpdateManyWithoutJournalsNestedInput
    JournalRanks?: JournalRanksUpdateManyWithoutJournalsNestedInput
    JournalTopics?: JournalTopicsUpdateManyWithoutJournalsNestedInput
    Users?: UsersUpdateOneRequiredWithoutJournalsNestedInput
  }

  export type JournalsUncheckedUpdateWithoutJournalLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    JournalCrawlJobs?: JournalCrawlJobsUncheckedUpdateManyWithoutJournalsNestedInput
    JournalFollows?: JournalFollowsUncheckedUpdateManyWithoutJournalsNestedInput
    JournalRanks?: JournalRanksUncheckedUpdateManyWithoutJournalsNestedInput
    JournalTopics?: JournalTopicsUncheckedUpdateManyWithoutJournalsNestedInput
  }

  export type UsersUpsertWithoutJournalLikesInput = {
    update: XOR<UsersUpdateWithoutJournalLikesInput, UsersUncheckedUpdateWithoutJournalLikesInput>
    create: XOR<UsersCreateWithoutJournalLikesInput, UsersUncheckedCreateWithoutJournalLikesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutJournalLikesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutJournalLikesInput, UsersUncheckedUpdateWithoutJournalLikesInput>
  }

  export type UsersUpdateWithoutJournalLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUpdateManyWithoutUsersNestedInput
    ConferenceCalendars?: ConferenceCalendarsUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutJournalLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUncheckedUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUncheckedUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUncheckedUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUncheckedUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type FieldOfResearchsCreateWithoutJournalRanksInput = {
    id: string
    name: string
    code: string
    ConferenceRanks?: ConferenceRanksCreateNestedManyWithoutFieldOfResearchsInput
  }

  export type FieldOfResearchsUncheckedCreateWithoutJournalRanksInput = {
    id: string
    name: string
    code: string
    ConferenceRanks?: ConferenceRanksUncheckedCreateNestedManyWithoutFieldOfResearchsInput
  }

  export type FieldOfResearchsCreateOrConnectWithoutJournalRanksInput = {
    where: FieldOfResearchsWhereUniqueInput
    create: XOR<FieldOfResearchsCreateWithoutJournalRanksInput, FieldOfResearchsUncheckedCreateWithoutJournalRanksInput>
  }

  export type JournalsCreateWithoutJournalRanksInput = {
    id: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    JournalCrawlJobs?: JournalCrawlJobsCreateNestedManyWithoutJournalsInput
    JournalFollows?: JournalFollowsCreateNestedManyWithoutJournalsInput
    JournalLikes?: JournalLikesCreateNestedManyWithoutJournalsInput
    JournalTopics?: JournalTopicsCreateNestedManyWithoutJournalsInput
    Users: UsersCreateNestedOneWithoutJournalsInput
  }

  export type JournalsUncheckedCreateWithoutJournalRanksInput = {
    id: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    creator: string
    JournalCrawlJobs?: JournalCrawlJobsUncheckedCreateNestedManyWithoutJournalsInput
    JournalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutJournalsInput
    JournalLikes?: JournalLikesUncheckedCreateNestedManyWithoutJournalsInput
    JournalTopics?: JournalTopicsUncheckedCreateNestedManyWithoutJournalsInput
  }

  export type JournalsCreateOrConnectWithoutJournalRanksInput = {
    where: JournalsWhereUniqueInput
    create: XOR<JournalsCreateWithoutJournalRanksInput, JournalsUncheckedCreateWithoutJournalRanksInput>
  }

  export type RanksCreateWithoutJournalRanksInput = {
    id: string
    name: string
    value: number
    ConferenceRanks?: ConferenceRanksCreateNestedManyWithoutRanksInput
    Sources: SourcesCreateNestedOneWithoutRanksInput
  }

  export type RanksUncheckedCreateWithoutJournalRanksInput = {
    id: string
    name: string
    value: number
    sourceId: string
    ConferenceRanks?: ConferenceRanksUncheckedCreateNestedManyWithoutRanksInput
  }

  export type RanksCreateOrConnectWithoutJournalRanksInput = {
    where: RanksWhereUniqueInput
    create: XOR<RanksCreateWithoutJournalRanksInput, RanksUncheckedCreateWithoutJournalRanksInput>
  }

  export type FieldOfResearchsUpsertWithoutJournalRanksInput = {
    update: XOR<FieldOfResearchsUpdateWithoutJournalRanksInput, FieldOfResearchsUncheckedUpdateWithoutJournalRanksInput>
    create: XOR<FieldOfResearchsCreateWithoutJournalRanksInput, FieldOfResearchsUncheckedCreateWithoutJournalRanksInput>
    where?: FieldOfResearchsWhereInput
  }

  export type FieldOfResearchsUpdateToOneWithWhereWithoutJournalRanksInput = {
    where?: FieldOfResearchsWhereInput
    data: XOR<FieldOfResearchsUpdateWithoutJournalRanksInput, FieldOfResearchsUncheckedUpdateWithoutJournalRanksInput>
  }

  export type FieldOfResearchsUpdateWithoutJournalRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    ConferenceRanks?: ConferenceRanksUpdateManyWithoutFieldOfResearchsNestedInput
  }

  export type FieldOfResearchsUncheckedUpdateWithoutJournalRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    ConferenceRanks?: ConferenceRanksUncheckedUpdateManyWithoutFieldOfResearchsNestedInput
  }

  export type JournalsUpsertWithoutJournalRanksInput = {
    update: XOR<JournalsUpdateWithoutJournalRanksInput, JournalsUncheckedUpdateWithoutJournalRanksInput>
    create: XOR<JournalsCreateWithoutJournalRanksInput, JournalsUncheckedCreateWithoutJournalRanksInput>
    where?: JournalsWhereInput
  }

  export type JournalsUpdateToOneWithWhereWithoutJournalRanksInput = {
    where?: JournalsWhereInput
    data: XOR<JournalsUpdateWithoutJournalRanksInput, JournalsUncheckedUpdateWithoutJournalRanksInput>
  }

  export type JournalsUpdateWithoutJournalRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    JournalCrawlJobs?: JournalCrawlJobsUpdateManyWithoutJournalsNestedInput
    JournalFollows?: JournalFollowsUpdateManyWithoutJournalsNestedInput
    JournalLikes?: JournalLikesUpdateManyWithoutJournalsNestedInput
    JournalTopics?: JournalTopicsUpdateManyWithoutJournalsNestedInput
    Users?: UsersUpdateOneRequiredWithoutJournalsNestedInput
  }

  export type JournalsUncheckedUpdateWithoutJournalRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    JournalCrawlJobs?: JournalCrawlJobsUncheckedUpdateManyWithoutJournalsNestedInput
    JournalFollows?: JournalFollowsUncheckedUpdateManyWithoutJournalsNestedInput
    JournalLikes?: JournalLikesUncheckedUpdateManyWithoutJournalsNestedInput
    JournalTopics?: JournalTopicsUncheckedUpdateManyWithoutJournalsNestedInput
  }

  export type RanksUpsertWithoutJournalRanksInput = {
    update: XOR<RanksUpdateWithoutJournalRanksInput, RanksUncheckedUpdateWithoutJournalRanksInput>
    create: XOR<RanksCreateWithoutJournalRanksInput, RanksUncheckedCreateWithoutJournalRanksInput>
    where?: RanksWhereInput
  }

  export type RanksUpdateToOneWithWhereWithoutJournalRanksInput = {
    where?: RanksWhereInput
    data: XOR<RanksUpdateWithoutJournalRanksInput, RanksUncheckedUpdateWithoutJournalRanksInput>
  }

  export type RanksUpdateWithoutJournalRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    ConferenceRanks?: ConferenceRanksUpdateManyWithoutRanksNestedInput
    Sources?: SourcesUpdateOneRequiredWithoutRanksNestedInput
  }

  export type RanksUncheckedUpdateWithoutJournalRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    sourceId?: StringFieldUpdateOperationsInput | string
    ConferenceRanks?: ConferenceRanksUncheckedUpdateManyWithoutRanksNestedInput
  }

  export type JournalsCreateWithoutJournalTopicsInput = {
    id: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    JournalCrawlJobs?: JournalCrawlJobsCreateNestedManyWithoutJournalsInput
    JournalFollows?: JournalFollowsCreateNestedManyWithoutJournalsInput
    JournalLikes?: JournalLikesCreateNestedManyWithoutJournalsInput
    JournalRanks?: JournalRanksCreateNestedManyWithoutJournalsInput
    Users: UsersCreateNestedOneWithoutJournalsInput
  }

  export type JournalsUncheckedCreateWithoutJournalTopicsInput = {
    id: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    creator: string
    JournalCrawlJobs?: JournalCrawlJobsUncheckedCreateNestedManyWithoutJournalsInput
    JournalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutJournalsInput
    JournalLikes?: JournalLikesUncheckedCreateNestedManyWithoutJournalsInput
    JournalRanks?: JournalRanksUncheckedCreateNestedManyWithoutJournalsInput
  }

  export type JournalsCreateOrConnectWithoutJournalTopicsInput = {
    where: JournalsWhereUniqueInput
    create: XOR<JournalsCreateWithoutJournalTopicsInput, JournalsUncheckedCreateWithoutJournalTopicsInput>
  }

  export type TopicsCreateWithoutJournalTopicsInput = {
    id: string
    name: string
    createdAt?: Date | string
    updatedAt: Date | string
    ConferenceTopics?: ConferenceTopicsCreateNestedManyWithoutTopicsInput
    TopicUserInteresteds?: TopicUserInterestedsCreateNestedManyWithoutTopicsInput
  }

  export type TopicsUncheckedCreateWithoutJournalTopicsInput = {
    id: string
    name: string
    createdAt?: Date | string
    updatedAt: Date | string
    ConferenceTopics?: ConferenceTopicsUncheckedCreateNestedManyWithoutTopicsInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedCreateNestedManyWithoutTopicsInput
  }

  export type TopicsCreateOrConnectWithoutJournalTopicsInput = {
    where: TopicsWhereUniqueInput
    create: XOR<TopicsCreateWithoutJournalTopicsInput, TopicsUncheckedCreateWithoutJournalTopicsInput>
  }

  export type JournalsUpsertWithoutJournalTopicsInput = {
    update: XOR<JournalsUpdateWithoutJournalTopicsInput, JournalsUncheckedUpdateWithoutJournalTopicsInput>
    create: XOR<JournalsCreateWithoutJournalTopicsInput, JournalsUncheckedCreateWithoutJournalTopicsInput>
    where?: JournalsWhereInput
  }

  export type JournalsUpdateToOneWithWhereWithoutJournalTopicsInput = {
    where?: JournalsWhereInput
    data: XOR<JournalsUpdateWithoutJournalTopicsInput, JournalsUncheckedUpdateWithoutJournalTopicsInput>
  }

  export type JournalsUpdateWithoutJournalTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    JournalCrawlJobs?: JournalCrawlJobsUpdateManyWithoutJournalsNestedInput
    JournalFollows?: JournalFollowsUpdateManyWithoutJournalsNestedInput
    JournalLikes?: JournalLikesUpdateManyWithoutJournalsNestedInput
    JournalRanks?: JournalRanksUpdateManyWithoutJournalsNestedInput
    Users?: UsersUpdateOneRequiredWithoutJournalsNestedInput
  }

  export type JournalsUncheckedUpdateWithoutJournalTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    JournalCrawlJobs?: JournalCrawlJobsUncheckedUpdateManyWithoutJournalsNestedInput
    JournalFollows?: JournalFollowsUncheckedUpdateManyWithoutJournalsNestedInput
    JournalLikes?: JournalLikesUncheckedUpdateManyWithoutJournalsNestedInput
    JournalRanks?: JournalRanksUncheckedUpdateManyWithoutJournalsNestedInput
  }

  export type TopicsUpsertWithoutJournalTopicsInput = {
    update: XOR<TopicsUpdateWithoutJournalTopicsInput, TopicsUncheckedUpdateWithoutJournalTopicsInput>
    create: XOR<TopicsCreateWithoutJournalTopicsInput, TopicsUncheckedCreateWithoutJournalTopicsInput>
    where?: TopicsWhereInput
  }

  export type TopicsUpdateToOneWithWhereWithoutJournalTopicsInput = {
    where?: TopicsWhereInput
    data: XOR<TopicsUpdateWithoutJournalTopicsInput, TopicsUncheckedUpdateWithoutJournalTopicsInput>
  }

  export type TopicsUpdateWithoutJournalTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ConferenceTopics?: ConferenceTopicsUpdateManyWithoutTopicsNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUpdateManyWithoutTopicsNestedInput
  }

  export type TopicsUncheckedUpdateWithoutJournalTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ConferenceTopics?: ConferenceTopicsUncheckedUpdateManyWithoutTopicsNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedUpdateManyWithoutTopicsNestedInput
  }

  export type JournalCrawlJobsCreateWithoutJournalsInput = {
    id: string
    status: string
    progress: number
    message: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type JournalCrawlJobsUncheckedCreateWithoutJournalsInput = {
    id: string
    status: string
    progress: number
    message: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type JournalCrawlJobsCreateOrConnectWithoutJournalsInput = {
    where: JournalCrawlJobsWhereUniqueInput
    create: XOR<JournalCrawlJobsCreateWithoutJournalsInput, JournalCrawlJobsUncheckedCreateWithoutJournalsInput>
  }

  export type JournalCrawlJobsCreateManyJournalsInputEnvelope = {
    data: JournalCrawlJobsCreateManyJournalsInput | JournalCrawlJobsCreateManyJournalsInput[]
    skipDuplicates?: boolean
  }

  export type JournalFollowsCreateWithoutJournalsInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    Users: UsersCreateNestedOneWithoutJournalFollowsInput
  }

  export type JournalFollowsUncheckedCreateWithoutJournalsInput = {
    id: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type JournalFollowsCreateOrConnectWithoutJournalsInput = {
    where: JournalFollowsWhereUniqueInput
    create: XOR<JournalFollowsCreateWithoutJournalsInput, JournalFollowsUncheckedCreateWithoutJournalsInput>
  }

  export type JournalFollowsCreateManyJournalsInputEnvelope = {
    data: JournalFollowsCreateManyJournalsInput | JournalFollowsCreateManyJournalsInput[]
    skipDuplicates?: boolean
  }

  export type JournalLikesCreateWithoutJournalsInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    Users: UsersCreateNestedOneWithoutJournalLikesInput
  }

  export type JournalLikesUncheckedCreateWithoutJournalsInput = {
    id: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type JournalLikesCreateOrConnectWithoutJournalsInput = {
    where: JournalLikesWhereUniqueInput
    create: XOR<JournalLikesCreateWithoutJournalsInput, JournalLikesUncheckedCreateWithoutJournalsInput>
  }

  export type JournalLikesCreateManyJournalsInputEnvelope = {
    data: JournalLikesCreateManyJournalsInput | JournalLikesCreateManyJournalsInput[]
    skipDuplicates?: boolean
  }

  export type JournalRanksCreateWithoutJournalsInput = {
    id: string
    year: number
    FieldOfResearchs: FieldOfResearchsCreateNestedOneWithoutJournalRanksInput
    Ranks: RanksCreateNestedOneWithoutJournalRanksInput
  }

  export type JournalRanksUncheckedCreateWithoutJournalsInput = {
    id: string
    year: number
    fieldOfResearchId: string
    rankId: string
  }

  export type JournalRanksCreateOrConnectWithoutJournalsInput = {
    where: JournalRanksWhereUniqueInput
    create: XOR<JournalRanksCreateWithoutJournalsInput, JournalRanksUncheckedCreateWithoutJournalsInput>
  }

  export type JournalRanksCreateManyJournalsInputEnvelope = {
    data: JournalRanksCreateManyJournalsInput | JournalRanksCreateManyJournalsInput[]
    skipDuplicates?: boolean
  }

  export type JournalTopicsCreateWithoutJournalsInput = {
    id: string
    Topics: TopicsCreateNestedOneWithoutJournalTopicsInput
  }

  export type JournalTopicsUncheckedCreateWithoutJournalsInput = {
    id: string
    topicId: string
  }

  export type JournalTopicsCreateOrConnectWithoutJournalsInput = {
    where: JournalTopicsWhereUniqueInput
    create: XOR<JournalTopicsCreateWithoutJournalsInput, JournalTopicsUncheckedCreateWithoutJournalsInput>
  }

  export type JournalTopicsCreateManyJournalsInputEnvelope = {
    data: JournalTopicsCreateManyJournalsInput | JournalTopicsCreateManyJournalsInput[]
    skipDuplicates?: boolean
  }

  export type UsersCreateWithoutJournalsInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsCreateNestedManyWithoutUsersInput
    ConferenceCalendars?: ConferenceCalendarsCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutJournalsInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesUncheckedCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesUncheckedCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesUncheckedCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutJournalsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutJournalsInput, UsersUncheckedCreateWithoutJournalsInput>
  }

  export type JournalCrawlJobsUpsertWithWhereUniqueWithoutJournalsInput = {
    where: JournalCrawlJobsWhereUniqueInput
    update: XOR<JournalCrawlJobsUpdateWithoutJournalsInput, JournalCrawlJobsUncheckedUpdateWithoutJournalsInput>
    create: XOR<JournalCrawlJobsCreateWithoutJournalsInput, JournalCrawlJobsUncheckedCreateWithoutJournalsInput>
  }

  export type JournalCrawlJobsUpdateWithWhereUniqueWithoutJournalsInput = {
    where: JournalCrawlJobsWhereUniqueInput
    data: XOR<JournalCrawlJobsUpdateWithoutJournalsInput, JournalCrawlJobsUncheckedUpdateWithoutJournalsInput>
  }

  export type JournalCrawlJobsUpdateManyWithWhereWithoutJournalsInput = {
    where: JournalCrawlJobsScalarWhereInput
    data: XOR<JournalCrawlJobsUpdateManyMutationInput, JournalCrawlJobsUncheckedUpdateManyWithoutJournalsInput>
  }

  export type JournalCrawlJobsScalarWhereInput = {
    AND?: JournalCrawlJobsScalarWhereInput | JournalCrawlJobsScalarWhereInput[]
    OR?: JournalCrawlJobsScalarWhereInput[]
    NOT?: JournalCrawlJobsScalarWhereInput | JournalCrawlJobsScalarWhereInput[]
    id?: StringFilter<"JournalCrawlJobs"> | string
    journalId?: StringFilter<"JournalCrawlJobs"> | string
    status?: StringFilter<"JournalCrawlJobs"> | string
    progress?: IntFilter<"JournalCrawlJobs"> | number
    message?: StringFilter<"JournalCrawlJobs"> | string
    createdAt?: DateTimeFilter<"JournalCrawlJobs"> | Date | string
    updatedAt?: DateTimeFilter<"JournalCrawlJobs"> | Date | string
  }

  export type JournalFollowsUpsertWithWhereUniqueWithoutJournalsInput = {
    where: JournalFollowsWhereUniqueInput
    update: XOR<JournalFollowsUpdateWithoutJournalsInput, JournalFollowsUncheckedUpdateWithoutJournalsInput>
    create: XOR<JournalFollowsCreateWithoutJournalsInput, JournalFollowsUncheckedCreateWithoutJournalsInput>
  }

  export type JournalFollowsUpdateWithWhereUniqueWithoutJournalsInput = {
    where: JournalFollowsWhereUniqueInput
    data: XOR<JournalFollowsUpdateWithoutJournalsInput, JournalFollowsUncheckedUpdateWithoutJournalsInput>
  }

  export type JournalFollowsUpdateManyWithWhereWithoutJournalsInput = {
    where: JournalFollowsScalarWhereInput
    data: XOR<JournalFollowsUpdateManyMutationInput, JournalFollowsUncheckedUpdateManyWithoutJournalsInput>
  }

  export type JournalFollowsScalarWhereInput = {
    AND?: JournalFollowsScalarWhereInput | JournalFollowsScalarWhereInput[]
    OR?: JournalFollowsScalarWhereInput[]
    NOT?: JournalFollowsScalarWhereInput | JournalFollowsScalarWhereInput[]
    id?: StringFilter<"JournalFollows"> | string
    journalId?: StringFilter<"JournalFollows"> | string
    userId?: StringFilter<"JournalFollows"> | string
    createdAt?: DateTimeFilter<"JournalFollows"> | Date | string
    updatedAt?: DateTimeFilter<"JournalFollows"> | Date | string
  }

  export type JournalLikesUpsertWithWhereUniqueWithoutJournalsInput = {
    where: JournalLikesWhereUniqueInput
    update: XOR<JournalLikesUpdateWithoutJournalsInput, JournalLikesUncheckedUpdateWithoutJournalsInput>
    create: XOR<JournalLikesCreateWithoutJournalsInput, JournalLikesUncheckedCreateWithoutJournalsInput>
  }

  export type JournalLikesUpdateWithWhereUniqueWithoutJournalsInput = {
    where: JournalLikesWhereUniqueInput
    data: XOR<JournalLikesUpdateWithoutJournalsInput, JournalLikesUncheckedUpdateWithoutJournalsInput>
  }

  export type JournalLikesUpdateManyWithWhereWithoutJournalsInput = {
    where: JournalLikesScalarWhereInput
    data: XOR<JournalLikesUpdateManyMutationInput, JournalLikesUncheckedUpdateManyWithoutJournalsInput>
  }

  export type JournalLikesScalarWhereInput = {
    AND?: JournalLikesScalarWhereInput | JournalLikesScalarWhereInput[]
    OR?: JournalLikesScalarWhereInput[]
    NOT?: JournalLikesScalarWhereInput | JournalLikesScalarWhereInput[]
    id?: StringFilter<"JournalLikes"> | string
    journalId?: StringFilter<"JournalLikes"> | string
    userId?: StringFilter<"JournalLikes"> | string
    createdAt?: DateTimeFilter<"JournalLikes"> | Date | string
    updatedAt?: DateTimeFilter<"JournalLikes"> | Date | string
  }

  export type JournalRanksUpsertWithWhereUniqueWithoutJournalsInput = {
    where: JournalRanksWhereUniqueInput
    update: XOR<JournalRanksUpdateWithoutJournalsInput, JournalRanksUncheckedUpdateWithoutJournalsInput>
    create: XOR<JournalRanksCreateWithoutJournalsInput, JournalRanksUncheckedCreateWithoutJournalsInput>
  }

  export type JournalRanksUpdateWithWhereUniqueWithoutJournalsInput = {
    where: JournalRanksWhereUniqueInput
    data: XOR<JournalRanksUpdateWithoutJournalsInput, JournalRanksUncheckedUpdateWithoutJournalsInput>
  }

  export type JournalRanksUpdateManyWithWhereWithoutJournalsInput = {
    where: JournalRanksScalarWhereInput
    data: XOR<JournalRanksUpdateManyMutationInput, JournalRanksUncheckedUpdateManyWithoutJournalsInput>
  }

  export type JournalTopicsUpsertWithWhereUniqueWithoutJournalsInput = {
    where: JournalTopicsWhereUniqueInput
    update: XOR<JournalTopicsUpdateWithoutJournalsInput, JournalTopicsUncheckedUpdateWithoutJournalsInput>
    create: XOR<JournalTopicsCreateWithoutJournalsInput, JournalTopicsUncheckedCreateWithoutJournalsInput>
  }

  export type JournalTopicsUpdateWithWhereUniqueWithoutJournalsInput = {
    where: JournalTopicsWhereUniqueInput
    data: XOR<JournalTopicsUpdateWithoutJournalsInput, JournalTopicsUncheckedUpdateWithoutJournalsInput>
  }

  export type JournalTopicsUpdateManyWithWhereWithoutJournalsInput = {
    where: JournalTopicsScalarWhereInput
    data: XOR<JournalTopicsUpdateManyMutationInput, JournalTopicsUncheckedUpdateManyWithoutJournalsInput>
  }

  export type JournalTopicsScalarWhereInput = {
    AND?: JournalTopicsScalarWhereInput | JournalTopicsScalarWhereInput[]
    OR?: JournalTopicsScalarWhereInput[]
    NOT?: JournalTopicsScalarWhereInput | JournalTopicsScalarWhereInput[]
    id?: StringFilter<"JournalTopics"> | string
    journalId?: StringFilter<"JournalTopics"> | string
    topicId?: StringFilter<"JournalTopics"> | string
  }

  export type UsersUpsertWithoutJournalsInput = {
    update: XOR<UsersUpdateWithoutJournalsInput, UsersUncheckedUpdateWithoutJournalsInput>
    create: XOR<UsersCreateWithoutJournalsInput, UsersUncheckedCreateWithoutJournalsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutJournalsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutJournalsInput, UsersUncheckedUpdateWithoutJournalsInput>
  }

  export type UsersUpdateWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUpdateManyWithoutUsersNestedInput
    ConferenceCalendars?: ConferenceCalendarsUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUncheckedUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUncheckedUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUncheckedUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUncheckedUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type ConferenceOrganizationsCreateWithoutLocationsInput = {
    id: string
    year?: number | null
    accessType: string
    isAvailable: boolean
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt?: Date | string
    updatedAt: Date | string
    ConferenceDates?: ConferenceDatesCreateNestedManyWithoutConferenceOrganizationsInput
    Conferences: ConferencesCreateNestedOneWithoutConferenceOrganizationsInput
    ConferenceTopics?: ConferenceTopicsCreateNestedManyWithoutConferenceOrganizationsInput
  }

  export type ConferenceOrganizationsUncheckedCreateWithoutLocationsInput = {
    id: string
    year?: number | null
    accessType: string
    isAvailable: boolean
    conferenceId: string
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt?: Date | string
    updatedAt: Date | string
    ConferenceDates?: ConferenceDatesUncheckedCreateNestedManyWithoutConferenceOrganizationsInput
    ConferenceTopics?: ConferenceTopicsUncheckedCreateNestedManyWithoutConferenceOrganizationsInput
  }

  export type ConferenceOrganizationsCreateOrConnectWithoutLocationsInput = {
    where: ConferenceOrganizationsWhereUniqueInput
    create: XOR<ConferenceOrganizationsCreateWithoutLocationsInput, ConferenceOrganizationsUncheckedCreateWithoutLocationsInput>
  }

  export type ConferenceOrganizationsUpsertWithoutLocationsInput = {
    update: XOR<ConferenceOrganizationsUpdateWithoutLocationsInput, ConferenceOrganizationsUncheckedUpdateWithoutLocationsInput>
    create: XOR<ConferenceOrganizationsCreateWithoutLocationsInput, ConferenceOrganizationsUncheckedCreateWithoutLocationsInput>
    where?: ConferenceOrganizationsWhereInput
  }

  export type ConferenceOrganizationsUpdateToOneWithWhereWithoutLocationsInput = {
    where?: ConferenceOrganizationsWhereInput
    data: XOR<ConferenceOrganizationsUpdateWithoutLocationsInput, ConferenceOrganizationsUncheckedUpdateWithoutLocationsInput>
  }

  export type ConferenceOrganizationsUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ConferenceDates?: ConferenceDatesUpdateManyWithoutConferenceOrganizationsNestedInput
    Conferences?: ConferencesUpdateOneRequiredWithoutConferenceOrganizationsNestedInput
    ConferenceTopics?: ConferenceTopicsUpdateManyWithoutConferenceOrganizationsNestedInput
  }

  export type ConferenceOrganizationsUncheckedUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    conferenceId?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ConferenceDates?: ConferenceDatesUncheckedUpdateManyWithoutConferenceOrganizationsNestedInput
    ConferenceTopics?: ConferenceTopicsUncheckedUpdateManyWithoutConferenceOrganizationsNestedInput
  }

  export type NotificationsTypesCreateWithoutNotificationSettingsInput = {
    id: string
    name: string
    createdAt?: Date | string
    updatedAt: Date | string
    Notifications?: NotificationsCreateNestedManyWithoutNotificationsTypesInput
  }

  export type NotificationsTypesUncheckedCreateWithoutNotificationSettingsInput = {
    id: string
    name: string
    createdAt?: Date | string
    updatedAt: Date | string
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutNotificationsTypesInput
  }

  export type NotificationsTypesCreateOrConnectWithoutNotificationSettingsInput = {
    where: NotificationsTypesWhereUniqueInput
    create: XOR<NotificationsTypesCreateWithoutNotificationSettingsInput, NotificationsTypesUncheckedCreateWithoutNotificationSettingsInput>
  }

  export type UsersCreateWithoutNotificationSettingsInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsCreateNestedManyWithoutUsersInput
    ConferenceCalendars?: ConferenceCalendarsCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesCreateNestedManyWithoutUsersInput
    Journals?: JournalsCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutNotificationSettingsInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesUncheckedCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesUncheckedCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesUncheckedCreateNestedManyWithoutUsersInput
    Journals?: JournalsUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutNotificationSettingsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutNotificationSettingsInput, UsersUncheckedCreateWithoutNotificationSettingsInput>
  }

  export type NotificationsTypesUpsertWithoutNotificationSettingsInput = {
    update: XOR<NotificationsTypesUpdateWithoutNotificationSettingsInput, NotificationsTypesUncheckedUpdateWithoutNotificationSettingsInput>
    create: XOR<NotificationsTypesCreateWithoutNotificationSettingsInput, NotificationsTypesUncheckedCreateWithoutNotificationSettingsInput>
    where?: NotificationsTypesWhereInput
  }

  export type NotificationsTypesUpdateToOneWithWhereWithoutNotificationSettingsInput = {
    where?: NotificationsTypesWhereInput
    data: XOR<NotificationsTypesUpdateWithoutNotificationSettingsInput, NotificationsTypesUncheckedUpdateWithoutNotificationSettingsInput>
  }

  export type NotificationsTypesUpdateWithoutNotificationSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Notifications?: NotificationsUpdateManyWithoutNotificationsTypesNestedInput
  }

  export type NotificationsTypesUncheckedUpdateWithoutNotificationSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Notifications?: NotificationsUncheckedUpdateManyWithoutNotificationsTypesNestedInput
  }

  export type UsersUpsertWithoutNotificationSettingsInput = {
    update: XOR<UsersUpdateWithoutNotificationSettingsInput, UsersUncheckedUpdateWithoutNotificationSettingsInput>
    create: XOR<UsersCreateWithoutNotificationSettingsInput, UsersUncheckedCreateWithoutNotificationSettingsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutNotificationSettingsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutNotificationSettingsInput, UsersUncheckedUpdateWithoutNotificationSettingsInput>
  }

  export type UsersUpdateWithoutNotificationSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUpdateManyWithoutUsersNestedInput
    ConferenceCalendars?: ConferenceCalendarsUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutNotificationSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUncheckedUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUncheckedUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUncheckedUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUncheckedUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type NotificationsTypesCreateWithoutNotificationsInput = {
    id: string
    name: string
    createdAt?: Date | string
    updatedAt: Date | string
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutNotificationsTypesInput
  }

  export type NotificationsTypesUncheckedCreateWithoutNotificationsInput = {
    id: string
    name: string
    createdAt?: Date | string
    updatedAt: Date | string
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutNotificationsTypesInput
  }

  export type NotificationsTypesCreateOrConnectWithoutNotificationsInput = {
    where: NotificationsTypesWhereUniqueInput
    create: XOR<NotificationsTypesCreateWithoutNotificationsInput, NotificationsTypesUncheckedCreateWithoutNotificationsInput>
  }

  export type UsersCreateWithoutNotificationsInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsCreateNestedManyWithoutUsersInput
    ConferenceCalendars?: ConferenceCalendarsCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesCreateNestedManyWithoutUsersInput
    Journals?: JournalsCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutNotificationsInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesUncheckedCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesUncheckedCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesUncheckedCreateNestedManyWithoutUsersInput
    Journals?: JournalsUncheckedCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutNotificationsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutNotificationsInput, UsersUncheckedCreateWithoutNotificationsInput>
  }

  export type NotificationsTypesUpsertWithoutNotificationsInput = {
    update: XOR<NotificationsTypesUpdateWithoutNotificationsInput, NotificationsTypesUncheckedUpdateWithoutNotificationsInput>
    create: XOR<NotificationsTypesCreateWithoutNotificationsInput, NotificationsTypesUncheckedCreateWithoutNotificationsInput>
    where?: NotificationsTypesWhereInput
  }

  export type NotificationsTypesUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: NotificationsTypesWhereInput
    data: XOR<NotificationsTypesUpdateWithoutNotificationsInput, NotificationsTypesUncheckedUpdateWithoutNotificationsInput>
  }

  export type NotificationsTypesUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NotificationSettings?: NotificationSettingsUpdateManyWithoutNotificationsTypesNestedInput
  }

  export type NotificationsTypesUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutNotificationsTypesNestedInput
  }

  export type UsersUpsertWithoutNotificationsInput = {
    update: XOR<UsersUpdateWithoutNotificationsInput, UsersUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UsersCreateWithoutNotificationsInput, UsersUncheckedCreateWithoutNotificationsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutNotificationsInput, UsersUncheckedUpdateWithoutNotificationsInput>
  }

  export type UsersUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUpdateManyWithoutUsersNestedInput
    ConferenceCalendars?: ConferenceCalendarsUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUncheckedUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUncheckedUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUncheckedUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUncheckedUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUncheckedUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type NotificationSettingsCreateWithoutNotificationsTypesInput = {
    id: string
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    Users: UsersCreateNestedOneWithoutNotificationSettingsInput
  }

  export type NotificationSettingsUncheckedCreateWithoutNotificationsTypesInput = {
    id: string
    userId: string
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NotificationSettingsCreateOrConnectWithoutNotificationsTypesInput = {
    where: NotificationSettingsWhereUniqueInput
    create: XOR<NotificationSettingsCreateWithoutNotificationsTypesInput, NotificationSettingsUncheckedCreateWithoutNotificationsTypesInput>
  }

  export type NotificationSettingsCreateManyNotificationsTypesInputEnvelope = {
    data: NotificationSettingsCreateManyNotificationsTypesInput | NotificationSettingsCreateManyNotificationsTypesInput[]
    skipDuplicates?: boolean
  }

  export type NotificationsCreateWithoutNotificationsTypesInput = {
    id: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    Users: UsersCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationsUncheckedCreateWithoutNotificationsTypesInput = {
    id: string
    userId: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NotificationsCreateOrConnectWithoutNotificationsTypesInput = {
    where: NotificationsWhereUniqueInput
    create: XOR<NotificationsCreateWithoutNotificationsTypesInput, NotificationsUncheckedCreateWithoutNotificationsTypesInput>
  }

  export type NotificationsCreateManyNotificationsTypesInputEnvelope = {
    data: NotificationsCreateManyNotificationsTypesInput | NotificationsCreateManyNotificationsTypesInput[]
    skipDuplicates?: boolean
  }

  export type NotificationSettingsUpsertWithWhereUniqueWithoutNotificationsTypesInput = {
    where: NotificationSettingsWhereUniqueInput
    update: XOR<NotificationSettingsUpdateWithoutNotificationsTypesInput, NotificationSettingsUncheckedUpdateWithoutNotificationsTypesInput>
    create: XOR<NotificationSettingsCreateWithoutNotificationsTypesInput, NotificationSettingsUncheckedCreateWithoutNotificationsTypesInput>
  }

  export type NotificationSettingsUpdateWithWhereUniqueWithoutNotificationsTypesInput = {
    where: NotificationSettingsWhereUniqueInput
    data: XOR<NotificationSettingsUpdateWithoutNotificationsTypesInput, NotificationSettingsUncheckedUpdateWithoutNotificationsTypesInput>
  }

  export type NotificationSettingsUpdateManyWithWhereWithoutNotificationsTypesInput = {
    where: NotificationSettingsScalarWhereInput
    data: XOR<NotificationSettingsUpdateManyMutationInput, NotificationSettingsUncheckedUpdateManyWithoutNotificationsTypesInput>
  }

  export type NotificationSettingsScalarWhereInput = {
    AND?: NotificationSettingsScalarWhereInput | NotificationSettingsScalarWhereInput[]
    OR?: NotificationSettingsScalarWhereInput[]
    NOT?: NotificationSettingsScalarWhereInput | NotificationSettingsScalarWhereInput[]
    id?: StringFilter<"NotificationSettings"> | string
    userId?: StringFilter<"NotificationSettings"> | string
    notificationId?: StringFilter<"NotificationSettings"> | string
    isEnabled?: BoolFilter<"NotificationSettings"> | boolean
    createdAt?: DateTimeFilter<"NotificationSettings"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationSettings"> | Date | string
  }

  export type NotificationsUpsertWithWhereUniqueWithoutNotificationsTypesInput = {
    where: NotificationsWhereUniqueInput
    update: XOR<NotificationsUpdateWithoutNotificationsTypesInput, NotificationsUncheckedUpdateWithoutNotificationsTypesInput>
    create: XOR<NotificationsCreateWithoutNotificationsTypesInput, NotificationsUncheckedCreateWithoutNotificationsTypesInput>
  }

  export type NotificationsUpdateWithWhereUniqueWithoutNotificationsTypesInput = {
    where: NotificationsWhereUniqueInput
    data: XOR<NotificationsUpdateWithoutNotificationsTypesInput, NotificationsUncheckedUpdateWithoutNotificationsTypesInput>
  }

  export type NotificationsUpdateManyWithWhereWithoutNotificationsTypesInput = {
    where: NotificationsScalarWhereInput
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyWithoutNotificationsTypesInput>
  }

  export type NotificationsScalarWhereInput = {
    AND?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
    OR?: NotificationsScalarWhereInput[]
    NOT?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
    id?: StringFilter<"Notifications"> | string
    notificationId?: StringFilter<"Notifications"> | string
    userId?: StringFilter<"Notifications"> | string
    message?: StringFilter<"Notifications"> | string
    isRead?: BoolFilter<"Notifications"> | boolean
    createdAt?: DateTimeFilter<"Notifications"> | Date | string
    updatedAt?: DateTimeFilter<"Notifications"> | Date | string
  }

  export type ConferenceRanksCreateWithoutRanksInput = {
    id: string
    year: number
    Conferences: ConferencesCreateNestedOneWithoutConferenceRanksInput
    FieldOfResearchs: FieldOfResearchsCreateNestedOneWithoutConferenceRanksInput
  }

  export type ConferenceRanksUncheckedCreateWithoutRanksInput = {
    id: string
    year: number
    conferenceId: string
    fieldOfResearchId: string
  }

  export type ConferenceRanksCreateOrConnectWithoutRanksInput = {
    where: ConferenceRanksWhereUniqueInput
    create: XOR<ConferenceRanksCreateWithoutRanksInput, ConferenceRanksUncheckedCreateWithoutRanksInput>
  }

  export type ConferenceRanksCreateManyRanksInputEnvelope = {
    data: ConferenceRanksCreateManyRanksInput | ConferenceRanksCreateManyRanksInput[]
    skipDuplicates?: boolean
  }

  export type JournalRanksCreateWithoutRanksInput = {
    id: string
    year: number
    FieldOfResearchs: FieldOfResearchsCreateNestedOneWithoutJournalRanksInput
    Journals: JournalsCreateNestedOneWithoutJournalRanksInput
  }

  export type JournalRanksUncheckedCreateWithoutRanksInput = {
    id: string
    year: number
    journalId: string
    fieldOfResearchId: string
  }

  export type JournalRanksCreateOrConnectWithoutRanksInput = {
    where: JournalRanksWhereUniqueInput
    create: XOR<JournalRanksCreateWithoutRanksInput, JournalRanksUncheckedCreateWithoutRanksInput>
  }

  export type JournalRanksCreateManyRanksInputEnvelope = {
    data: JournalRanksCreateManyRanksInput | JournalRanksCreateManyRanksInput[]
    skipDuplicates?: boolean
  }

  export type SourcesCreateWithoutRanksInput = {
    id: string
    name: string
    link?: string | null
  }

  export type SourcesUncheckedCreateWithoutRanksInput = {
    id: string
    name: string
    link?: string | null
  }

  export type SourcesCreateOrConnectWithoutRanksInput = {
    where: SourcesWhereUniqueInput
    create: XOR<SourcesCreateWithoutRanksInput, SourcesUncheckedCreateWithoutRanksInput>
  }

  export type ConferenceRanksUpsertWithWhereUniqueWithoutRanksInput = {
    where: ConferenceRanksWhereUniqueInput
    update: XOR<ConferenceRanksUpdateWithoutRanksInput, ConferenceRanksUncheckedUpdateWithoutRanksInput>
    create: XOR<ConferenceRanksCreateWithoutRanksInput, ConferenceRanksUncheckedCreateWithoutRanksInput>
  }

  export type ConferenceRanksUpdateWithWhereUniqueWithoutRanksInput = {
    where: ConferenceRanksWhereUniqueInput
    data: XOR<ConferenceRanksUpdateWithoutRanksInput, ConferenceRanksUncheckedUpdateWithoutRanksInput>
  }

  export type ConferenceRanksUpdateManyWithWhereWithoutRanksInput = {
    where: ConferenceRanksScalarWhereInput
    data: XOR<ConferenceRanksUpdateManyMutationInput, ConferenceRanksUncheckedUpdateManyWithoutRanksInput>
  }

  export type JournalRanksUpsertWithWhereUniqueWithoutRanksInput = {
    where: JournalRanksWhereUniqueInput
    update: XOR<JournalRanksUpdateWithoutRanksInput, JournalRanksUncheckedUpdateWithoutRanksInput>
    create: XOR<JournalRanksCreateWithoutRanksInput, JournalRanksUncheckedCreateWithoutRanksInput>
  }

  export type JournalRanksUpdateWithWhereUniqueWithoutRanksInput = {
    where: JournalRanksWhereUniqueInput
    data: XOR<JournalRanksUpdateWithoutRanksInput, JournalRanksUncheckedUpdateWithoutRanksInput>
  }

  export type JournalRanksUpdateManyWithWhereWithoutRanksInput = {
    where: JournalRanksScalarWhereInput
    data: XOR<JournalRanksUpdateManyMutationInput, JournalRanksUncheckedUpdateManyWithoutRanksInput>
  }

  export type SourcesUpsertWithoutRanksInput = {
    update: XOR<SourcesUpdateWithoutRanksInput, SourcesUncheckedUpdateWithoutRanksInput>
    create: XOR<SourcesCreateWithoutRanksInput, SourcesUncheckedCreateWithoutRanksInput>
    where?: SourcesWhereInput
  }

  export type SourcesUpdateToOneWithWhereWithoutRanksInput = {
    where?: SourcesWhereInput
    data: XOR<SourcesUpdateWithoutRanksInput, SourcesUncheckedUpdateWithoutRanksInput>
  }

  export type SourcesUpdateWithoutRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SourcesUncheckedUpdateWithoutRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RanksCreateWithoutSourcesInput = {
    id: string
    name: string
    value: number
    ConferenceRanks?: ConferenceRanksCreateNestedManyWithoutRanksInput
    JournalRanks?: JournalRanksCreateNestedManyWithoutRanksInput
  }

  export type RanksUncheckedCreateWithoutSourcesInput = {
    id: string
    name: string
    value: number
    ConferenceRanks?: ConferenceRanksUncheckedCreateNestedManyWithoutRanksInput
    JournalRanks?: JournalRanksUncheckedCreateNestedManyWithoutRanksInput
  }

  export type RanksCreateOrConnectWithoutSourcesInput = {
    where: RanksWhereUniqueInput
    create: XOR<RanksCreateWithoutSourcesInput, RanksUncheckedCreateWithoutSourcesInput>
  }

  export type RanksCreateManySourcesInputEnvelope = {
    data: RanksCreateManySourcesInput | RanksCreateManySourcesInput[]
    skipDuplicates?: boolean
  }

  export type RanksUpsertWithWhereUniqueWithoutSourcesInput = {
    where: RanksWhereUniqueInput
    update: XOR<RanksUpdateWithoutSourcesInput, RanksUncheckedUpdateWithoutSourcesInput>
    create: XOR<RanksCreateWithoutSourcesInput, RanksUncheckedCreateWithoutSourcesInput>
  }

  export type RanksUpdateWithWhereUniqueWithoutSourcesInput = {
    where: RanksWhereUniqueInput
    data: XOR<RanksUpdateWithoutSourcesInput, RanksUncheckedUpdateWithoutSourcesInput>
  }

  export type RanksUpdateManyWithWhereWithoutSourcesInput = {
    where: RanksScalarWhereInput
    data: XOR<RanksUpdateManyMutationInput, RanksUncheckedUpdateManyWithoutSourcesInput>
  }

  export type RanksScalarWhereInput = {
    AND?: RanksScalarWhereInput | RanksScalarWhereInput[]
    OR?: RanksScalarWhereInput[]
    NOT?: RanksScalarWhereInput | RanksScalarWhereInput[]
    id?: StringFilter<"Ranks"> | string
    name?: StringFilter<"Ranks"> | string
    value?: IntFilter<"Ranks"> | number
    sourceId?: StringFilter<"Ranks"> | string
  }

  export type TopicsCreateWithoutTopicUserInterestedsInput = {
    id: string
    name: string
    createdAt?: Date | string
    updatedAt: Date | string
    ConferenceTopics?: ConferenceTopicsCreateNestedManyWithoutTopicsInput
    JournalTopics?: JournalTopicsCreateNestedManyWithoutTopicsInput
  }

  export type TopicsUncheckedCreateWithoutTopicUserInterestedsInput = {
    id: string
    name: string
    createdAt?: Date | string
    updatedAt: Date | string
    ConferenceTopics?: ConferenceTopicsUncheckedCreateNestedManyWithoutTopicsInput
    JournalTopics?: JournalTopicsUncheckedCreateNestedManyWithoutTopicsInput
  }

  export type TopicsCreateOrConnectWithoutTopicUserInterestedsInput = {
    where: TopicsWhereUniqueInput
    create: XOR<TopicsCreateWithoutTopicUserInterestedsInput, TopicsUncheckedCreateWithoutTopicUserInterestedsInput>
  }

  export type UsersCreateWithoutTopicUserInterestedsInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsCreateNestedManyWithoutUsersInput
    ConferenceCalendars?: ConferenceCalendarsCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesCreateNestedManyWithoutUsersInput
    Journals?: JournalsCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutTopicUserInterestedsInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesUncheckedCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesUncheckedCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesUncheckedCreateNestedManyWithoutUsersInput
    Journals?: JournalsUncheckedCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    UserVerification?: UserVerificationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutTopicUserInterestedsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutTopicUserInterestedsInput, UsersUncheckedCreateWithoutTopicUserInterestedsInput>
  }

  export type TopicsUpsertWithoutTopicUserInterestedsInput = {
    update: XOR<TopicsUpdateWithoutTopicUserInterestedsInput, TopicsUncheckedUpdateWithoutTopicUserInterestedsInput>
    create: XOR<TopicsCreateWithoutTopicUserInterestedsInput, TopicsUncheckedCreateWithoutTopicUserInterestedsInput>
    where?: TopicsWhereInput
  }

  export type TopicsUpdateToOneWithWhereWithoutTopicUserInterestedsInput = {
    where?: TopicsWhereInput
    data: XOR<TopicsUpdateWithoutTopicUserInterestedsInput, TopicsUncheckedUpdateWithoutTopicUserInterestedsInput>
  }

  export type TopicsUpdateWithoutTopicUserInterestedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ConferenceTopics?: ConferenceTopicsUpdateManyWithoutTopicsNestedInput
    JournalTopics?: JournalTopicsUpdateManyWithoutTopicsNestedInput
  }

  export type TopicsUncheckedUpdateWithoutTopicUserInterestedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ConferenceTopics?: ConferenceTopicsUncheckedUpdateManyWithoutTopicsNestedInput
    JournalTopics?: JournalTopicsUncheckedUpdateManyWithoutTopicsNestedInput
  }

  export type UsersUpsertWithoutTopicUserInterestedsInput = {
    update: XOR<UsersUpdateWithoutTopicUserInterestedsInput, UsersUncheckedUpdateWithoutTopicUserInterestedsInput>
    create: XOR<UsersCreateWithoutTopicUserInterestedsInput, UsersUncheckedCreateWithoutTopicUserInterestedsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutTopicUserInterestedsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutTopicUserInterestedsInput, UsersUncheckedUpdateWithoutTopicUserInterestedsInput>
  }

  export type UsersUpdateWithoutTopicUserInterestedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUpdateManyWithoutUsersNestedInput
    ConferenceCalendars?: ConferenceCalendarsUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutTopicUserInterestedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUncheckedUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUncheckedUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUncheckedUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUncheckedUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUncheckedUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    UserVerification?: UserVerificationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type ConferenceTopicsCreateWithoutTopicsInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    ConferenceOrganizations: ConferenceOrganizationsCreateNestedOneWithoutConferenceTopicsInput
  }

  export type ConferenceTopicsUncheckedCreateWithoutTopicsInput = {
    id: string
    organizeId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceTopicsCreateOrConnectWithoutTopicsInput = {
    where: ConferenceTopicsWhereUniqueInput
    create: XOR<ConferenceTopicsCreateWithoutTopicsInput, ConferenceTopicsUncheckedCreateWithoutTopicsInput>
  }

  export type ConferenceTopicsCreateManyTopicsInputEnvelope = {
    data: ConferenceTopicsCreateManyTopicsInput | ConferenceTopicsCreateManyTopicsInput[]
    skipDuplicates?: boolean
  }

  export type JournalTopicsCreateWithoutTopicsInput = {
    id: string
    Journals: JournalsCreateNestedOneWithoutJournalTopicsInput
  }

  export type JournalTopicsUncheckedCreateWithoutTopicsInput = {
    id: string
    journalId: string
  }

  export type JournalTopicsCreateOrConnectWithoutTopicsInput = {
    where: JournalTopicsWhereUniqueInput
    create: XOR<JournalTopicsCreateWithoutTopicsInput, JournalTopicsUncheckedCreateWithoutTopicsInput>
  }

  export type JournalTopicsCreateManyTopicsInputEnvelope = {
    data: JournalTopicsCreateManyTopicsInput | JournalTopicsCreateManyTopicsInput[]
    skipDuplicates?: boolean
  }

  export type TopicUserInterestedsCreateWithoutTopicsInput = {
    createdAt?: Date | string
    updatedAt: Date | string
    Users: UsersCreateNestedOneWithoutTopicUserInterestedsInput
  }

  export type TopicUserInterestedsUncheckedCreateWithoutTopicsInput = {
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TopicUserInterestedsCreateOrConnectWithoutTopicsInput = {
    where: TopicUserInterestedsWhereUniqueInput
    create: XOR<TopicUserInterestedsCreateWithoutTopicsInput, TopicUserInterestedsUncheckedCreateWithoutTopicsInput>
  }

  export type TopicUserInterestedsCreateManyTopicsInputEnvelope = {
    data: TopicUserInterestedsCreateManyTopicsInput | TopicUserInterestedsCreateManyTopicsInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceTopicsUpsertWithWhereUniqueWithoutTopicsInput = {
    where: ConferenceTopicsWhereUniqueInput
    update: XOR<ConferenceTopicsUpdateWithoutTopicsInput, ConferenceTopicsUncheckedUpdateWithoutTopicsInput>
    create: XOR<ConferenceTopicsCreateWithoutTopicsInput, ConferenceTopicsUncheckedCreateWithoutTopicsInput>
  }

  export type ConferenceTopicsUpdateWithWhereUniqueWithoutTopicsInput = {
    where: ConferenceTopicsWhereUniqueInput
    data: XOR<ConferenceTopicsUpdateWithoutTopicsInput, ConferenceTopicsUncheckedUpdateWithoutTopicsInput>
  }

  export type ConferenceTopicsUpdateManyWithWhereWithoutTopicsInput = {
    where: ConferenceTopicsScalarWhereInput
    data: XOR<ConferenceTopicsUpdateManyMutationInput, ConferenceTopicsUncheckedUpdateManyWithoutTopicsInput>
  }

  export type JournalTopicsUpsertWithWhereUniqueWithoutTopicsInput = {
    where: JournalTopicsWhereUniqueInput
    update: XOR<JournalTopicsUpdateWithoutTopicsInput, JournalTopicsUncheckedUpdateWithoutTopicsInput>
    create: XOR<JournalTopicsCreateWithoutTopicsInput, JournalTopicsUncheckedCreateWithoutTopicsInput>
  }

  export type JournalTopicsUpdateWithWhereUniqueWithoutTopicsInput = {
    where: JournalTopicsWhereUniqueInput
    data: XOR<JournalTopicsUpdateWithoutTopicsInput, JournalTopicsUncheckedUpdateWithoutTopicsInput>
  }

  export type JournalTopicsUpdateManyWithWhereWithoutTopicsInput = {
    where: JournalTopicsScalarWhereInput
    data: XOR<JournalTopicsUpdateManyMutationInput, JournalTopicsUncheckedUpdateManyWithoutTopicsInput>
  }

  export type TopicUserInterestedsUpsertWithWhereUniqueWithoutTopicsInput = {
    where: TopicUserInterestedsWhereUniqueInput
    update: XOR<TopicUserInterestedsUpdateWithoutTopicsInput, TopicUserInterestedsUncheckedUpdateWithoutTopicsInput>
    create: XOR<TopicUserInterestedsCreateWithoutTopicsInput, TopicUserInterestedsUncheckedCreateWithoutTopicsInput>
  }

  export type TopicUserInterestedsUpdateWithWhereUniqueWithoutTopicsInput = {
    where: TopicUserInterestedsWhereUniqueInput
    data: XOR<TopicUserInterestedsUpdateWithoutTopicsInput, TopicUserInterestedsUncheckedUpdateWithoutTopicsInput>
  }

  export type TopicUserInterestedsUpdateManyWithWhereWithoutTopicsInput = {
    where: TopicUserInterestedsScalarWhereInput
    data: XOR<TopicUserInterestedsUpdateManyMutationInput, TopicUserInterestedsUncheckedUpdateManyWithoutTopicsInput>
  }

  export type TopicUserInterestedsScalarWhereInput = {
    AND?: TopicUserInterestedsScalarWhereInput | TopicUserInterestedsScalarWhereInput[]
    OR?: TopicUserInterestedsScalarWhereInput[]
    NOT?: TopicUserInterestedsScalarWhereInput | TopicUserInterestedsScalarWhereInput[]
    userId?: StringFilter<"TopicUserInteresteds"> | string
    topicId?: StringFilter<"TopicUserInteresteds"> | string
    createdAt?: DateTimeFilter<"TopicUserInteresteds"> | Date | string
    updatedAt?: DateTimeFilter<"TopicUserInteresteds"> | Date | string
  }

  export type UsersCreateWithoutUserVerificationInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsCreateNestedManyWithoutUsersInput
    ConferenceCalendars?: ConferenceCalendarsCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesCreateNestedManyWithoutUsersInput
    Journals?: JournalsCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutUserVerificationInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    aboutMe: string
    avatar: string
    background: string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutUsersInput
    ConferenceFollows?: ConferenceFollowsUncheckedCreateNestedManyWithoutUsersInput
    ConferenceLikes?: ConferenceLikesUncheckedCreateNestedManyWithoutUsersInput
    Conferences?: ConferencesUncheckedCreateNestedManyWithoutUsersInput
    JournalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutUsersInput
    JournalLikes?: JournalLikesUncheckedCreateNestedManyWithoutUsersInput
    Journals?: JournalsUncheckedCreateNestedManyWithoutUsersInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutUserVerificationInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUserVerificationInput, UsersUncheckedCreateWithoutUserVerificationInput>
  }

  export type UsersUpsertWithoutUserVerificationInput = {
    update: XOR<UsersUpdateWithoutUserVerificationInput, UsersUncheckedUpdateWithoutUserVerificationInput>
    create: XOR<UsersCreateWithoutUserVerificationInput, UsersUncheckedCreateWithoutUserVerificationInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutUserVerificationInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutUserVerificationInput, UsersUncheckedUpdateWithoutUserVerificationInput>
  }

  export type UsersUpdateWithoutUserVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUpdateManyWithoutUsersNestedInput
    ConferenceCalendars?: ConferenceCalendarsUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutUserVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceFollows?: ConferenceFollowsUncheckedUpdateManyWithoutUsersNestedInput
    ConferenceLikes?: ConferenceLikesUncheckedUpdateManyWithoutUsersNestedInput
    Conferences?: ConferencesUncheckedUpdateManyWithoutUsersNestedInput
    JournalFollows?: JournalFollowsUncheckedUpdateManyWithoutUsersNestedInput
    JournalLikes?: JournalLikesUncheckedUpdateManyWithoutUsersNestedInput
    Journals?: JournalsUncheckedUpdateManyWithoutUsersNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    TopicUserInteresteds?: TopicUserInterestedsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type ConferenceBlacklistsCreateWithoutUsersInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    Conferences: ConferencesCreateNestedOneWithoutConferenceBlacklistsInput
  }

  export type ConferenceBlacklistsUncheckedCreateWithoutUsersInput = {
    id: string
    conferenceId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceBlacklistsCreateOrConnectWithoutUsersInput = {
    where: ConferenceBlacklistsWhereUniqueInput
    create: XOR<ConferenceBlacklistsCreateWithoutUsersInput, ConferenceBlacklistsUncheckedCreateWithoutUsersInput>
  }

  export type ConferenceBlacklistsCreateManyUsersInputEnvelope = {
    data: ConferenceBlacklistsCreateManyUsersInput | ConferenceBlacklistsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceCalendarsCreateWithoutUsersInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    Conferences: ConferencesCreateNestedOneWithoutConferenceCalendarsInput
  }

  export type ConferenceCalendarsUncheckedCreateWithoutUsersInput = {
    id: string
    conferenceId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceCalendarsCreateOrConnectWithoutUsersInput = {
    where: ConferenceCalendarsWhereUniqueInput
    create: XOR<ConferenceCalendarsCreateWithoutUsersInput, ConferenceCalendarsUncheckedCreateWithoutUsersInput>
  }

  export type ConferenceCalendarsCreateManyUsersInputEnvelope = {
    data: ConferenceCalendarsCreateManyUsersInput | ConferenceCalendarsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceFeedbacksCreateWithoutUsersInput = {
    id: string
    description: string
    star: number
    createdAt?: Date | string
    updatedAt: Date | string
    Conferences: ConferencesCreateNestedOneWithoutConferenceFeedbacksInput
  }

  export type ConferenceFeedbacksUncheckedCreateWithoutUsersInput = {
    id: string
    conferenceId: string
    description: string
    star: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceFeedbacksCreateOrConnectWithoutUsersInput = {
    where: ConferenceFeedbacksWhereUniqueInput
    create: XOR<ConferenceFeedbacksCreateWithoutUsersInput, ConferenceFeedbacksUncheckedCreateWithoutUsersInput>
  }

  export type ConferenceFeedbacksCreateManyUsersInputEnvelope = {
    data: ConferenceFeedbacksCreateManyUsersInput | ConferenceFeedbacksCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceFollowsCreateWithoutUsersInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    Conferences: ConferencesCreateNestedOneWithoutConferenceFollowsInput
  }

  export type ConferenceFollowsUncheckedCreateWithoutUsersInput = {
    id: string
    conferenceId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceFollowsCreateOrConnectWithoutUsersInput = {
    where: ConferenceFollowsWhereUniqueInput
    create: XOR<ConferenceFollowsCreateWithoutUsersInput, ConferenceFollowsUncheckedCreateWithoutUsersInput>
  }

  export type ConferenceFollowsCreateManyUsersInputEnvelope = {
    data: ConferenceFollowsCreateManyUsersInput | ConferenceFollowsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceLikesCreateWithoutUsersInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    Conferences: ConferencesCreateNestedOneWithoutConferenceLikesInput
  }

  export type ConferenceLikesUncheckedCreateWithoutUsersInput = {
    id: string
    conferenceId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceLikesCreateOrConnectWithoutUsersInput = {
    where: ConferenceLikesWhereUniqueInput
    create: XOR<ConferenceLikesCreateWithoutUsersInput, ConferenceLikesUncheckedCreateWithoutUsersInput>
  }

  export type ConferenceLikesCreateManyUsersInputEnvelope = {
    data: ConferenceLikesCreateManyUsersInput | ConferenceLikesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ConferencesCreateWithoutUsersInput = {
    id: string
    title: string
    acronym: string
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
    ConferenceBlacklists?: ConferenceBlacklistsCreateNestedManyWithoutConferencesInput
    ConferenceCalendars?: ConferenceCalendarsCreateNestedManyWithoutConferencesInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsCreateNestedManyWithoutConferencesInput
    ConferenceFeedbacks?: ConferenceFeedbacksCreateNestedManyWithoutConferencesInput
    ConferenceFollows?: ConferenceFollowsCreateNestedManyWithoutConferencesInput
    ConferenceLikes?: ConferenceLikesCreateNestedManyWithoutConferencesInput
    ConferenceOrganizations?: ConferenceOrganizationsCreateNestedManyWithoutConferencesInput
    ConferenceRanks?: ConferenceRanksCreateNestedManyWithoutConferencesInput
    Admins?: AdminsCreateNestedOneWithoutConferencesInput
  }

  export type ConferencesUncheckedCreateWithoutUsersInput = {
    id: string
    title: string
    acronym: string
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
    adminId?: string | null
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceFollows?: ConferenceFollowsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceLikes?: ConferenceLikesUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceOrganizations?: ConferenceOrganizationsUncheckedCreateNestedManyWithoutConferencesInput
    ConferenceRanks?: ConferenceRanksUncheckedCreateNestedManyWithoutConferencesInput
  }

  export type ConferencesCreateOrConnectWithoutUsersInput = {
    where: ConferencesWhereUniqueInput
    create: XOR<ConferencesCreateWithoutUsersInput, ConferencesUncheckedCreateWithoutUsersInput>
  }

  export type ConferencesCreateManyUsersInputEnvelope = {
    data: ConferencesCreateManyUsersInput | ConferencesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type JournalFollowsCreateWithoutUsersInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    Journals: JournalsCreateNestedOneWithoutJournalFollowsInput
  }

  export type JournalFollowsUncheckedCreateWithoutUsersInput = {
    id: string
    journalId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type JournalFollowsCreateOrConnectWithoutUsersInput = {
    where: JournalFollowsWhereUniqueInput
    create: XOR<JournalFollowsCreateWithoutUsersInput, JournalFollowsUncheckedCreateWithoutUsersInput>
  }

  export type JournalFollowsCreateManyUsersInputEnvelope = {
    data: JournalFollowsCreateManyUsersInput | JournalFollowsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type JournalLikesCreateWithoutUsersInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    Journals: JournalsCreateNestedOneWithoutJournalLikesInput
  }

  export type JournalLikesUncheckedCreateWithoutUsersInput = {
    id: string
    journalId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type JournalLikesCreateOrConnectWithoutUsersInput = {
    where: JournalLikesWhereUniqueInput
    create: XOR<JournalLikesCreateWithoutUsersInput, JournalLikesUncheckedCreateWithoutUsersInput>
  }

  export type JournalLikesCreateManyUsersInputEnvelope = {
    data: JournalLikesCreateManyUsersInput | JournalLikesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type JournalsCreateWithoutUsersInput = {
    id: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    JournalCrawlJobs?: JournalCrawlJobsCreateNestedManyWithoutJournalsInput
    JournalFollows?: JournalFollowsCreateNestedManyWithoutJournalsInput
    JournalLikes?: JournalLikesCreateNestedManyWithoutJournalsInput
    JournalRanks?: JournalRanksCreateNestedManyWithoutJournalsInput
    JournalTopics?: JournalTopicsCreateNestedManyWithoutJournalsInput
  }

  export type JournalsUncheckedCreateWithoutUsersInput = {
    id: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    JournalCrawlJobs?: JournalCrawlJobsUncheckedCreateNestedManyWithoutJournalsInput
    JournalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutJournalsInput
    JournalLikes?: JournalLikesUncheckedCreateNestedManyWithoutJournalsInput
    JournalRanks?: JournalRanksUncheckedCreateNestedManyWithoutJournalsInput
    JournalTopics?: JournalTopicsUncheckedCreateNestedManyWithoutJournalsInput
  }

  export type JournalsCreateOrConnectWithoutUsersInput = {
    where: JournalsWhereUniqueInput
    create: XOR<JournalsCreateWithoutUsersInput, JournalsUncheckedCreateWithoutUsersInput>
  }

  export type JournalsCreateManyUsersInputEnvelope = {
    data: JournalsCreateManyUsersInput | JournalsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type NotificationSettingsCreateWithoutUsersInput = {
    id: string
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    NotificationsTypes: NotificationsTypesCreateNestedOneWithoutNotificationSettingsInput
  }

  export type NotificationSettingsUncheckedCreateWithoutUsersInput = {
    id: string
    notificationId: string
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NotificationSettingsCreateOrConnectWithoutUsersInput = {
    where: NotificationSettingsWhereUniqueInput
    create: XOR<NotificationSettingsCreateWithoutUsersInput, NotificationSettingsUncheckedCreateWithoutUsersInput>
  }

  export type NotificationSettingsCreateManyUsersInputEnvelope = {
    data: NotificationSettingsCreateManyUsersInput | NotificationSettingsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type NotificationsCreateWithoutUsersInput = {
    id: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    NotificationsTypes: NotificationsTypesCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationsUncheckedCreateWithoutUsersInput = {
    id: string
    notificationId: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NotificationsCreateOrConnectWithoutUsersInput = {
    where: NotificationsWhereUniqueInput
    create: XOR<NotificationsCreateWithoutUsersInput, NotificationsUncheckedCreateWithoutUsersInput>
  }

  export type NotificationsCreateManyUsersInputEnvelope = {
    data: NotificationsCreateManyUsersInput | NotificationsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type TopicUserInterestedsCreateWithoutUsersInput = {
    createdAt?: Date | string
    updatedAt: Date | string
    Topics: TopicsCreateNestedOneWithoutTopicUserInterestedsInput
  }

  export type TopicUserInterestedsUncheckedCreateWithoutUsersInput = {
    topicId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TopicUserInterestedsCreateOrConnectWithoutUsersInput = {
    where: TopicUserInterestedsWhereUniqueInput
    create: XOR<TopicUserInterestedsCreateWithoutUsersInput, TopicUserInterestedsUncheckedCreateWithoutUsersInput>
  }

  export type TopicUserInterestedsCreateManyUsersInputEnvelope = {
    data: TopicUserInterestedsCreateManyUsersInput | TopicUserInterestedsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type UserVerificationCreateWithoutUsersInput = {
    id: string
    verificationCode: string
    verificationCodeExpires: Date | string
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type UserVerificationUncheckedCreateWithoutUsersInput = {
    id: string
    verificationCode: string
    verificationCodeExpires: Date | string
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type UserVerificationCreateOrConnectWithoutUsersInput = {
    where: UserVerificationWhereUniqueInput
    create: XOR<UserVerificationCreateWithoutUsersInput, UserVerificationUncheckedCreateWithoutUsersInput>
  }

  export type UserVerificationCreateManyUsersInputEnvelope = {
    data: UserVerificationCreateManyUsersInput | UserVerificationCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceBlacklistsUpsertWithWhereUniqueWithoutUsersInput = {
    where: ConferenceBlacklistsWhereUniqueInput
    update: XOR<ConferenceBlacklistsUpdateWithoutUsersInput, ConferenceBlacklistsUncheckedUpdateWithoutUsersInput>
    create: XOR<ConferenceBlacklistsCreateWithoutUsersInput, ConferenceBlacklistsUncheckedCreateWithoutUsersInput>
  }

  export type ConferenceBlacklistsUpdateWithWhereUniqueWithoutUsersInput = {
    where: ConferenceBlacklistsWhereUniqueInput
    data: XOR<ConferenceBlacklistsUpdateWithoutUsersInput, ConferenceBlacklistsUncheckedUpdateWithoutUsersInput>
  }

  export type ConferenceBlacklistsUpdateManyWithWhereWithoutUsersInput = {
    where: ConferenceBlacklistsScalarWhereInput
    data: XOR<ConferenceBlacklistsUpdateManyMutationInput, ConferenceBlacklistsUncheckedUpdateManyWithoutUsersInput>
  }

  export type ConferenceCalendarsUpsertWithWhereUniqueWithoutUsersInput = {
    where: ConferenceCalendarsWhereUniqueInput
    update: XOR<ConferenceCalendarsUpdateWithoutUsersInput, ConferenceCalendarsUncheckedUpdateWithoutUsersInput>
    create: XOR<ConferenceCalendarsCreateWithoutUsersInput, ConferenceCalendarsUncheckedCreateWithoutUsersInput>
  }

  export type ConferenceCalendarsUpdateWithWhereUniqueWithoutUsersInput = {
    where: ConferenceCalendarsWhereUniqueInput
    data: XOR<ConferenceCalendarsUpdateWithoutUsersInput, ConferenceCalendarsUncheckedUpdateWithoutUsersInput>
  }

  export type ConferenceCalendarsUpdateManyWithWhereWithoutUsersInput = {
    where: ConferenceCalendarsScalarWhereInput
    data: XOR<ConferenceCalendarsUpdateManyMutationInput, ConferenceCalendarsUncheckedUpdateManyWithoutUsersInput>
  }

  export type ConferenceFeedbacksUpsertWithWhereUniqueWithoutUsersInput = {
    where: ConferenceFeedbacksWhereUniqueInput
    update: XOR<ConferenceFeedbacksUpdateWithoutUsersInput, ConferenceFeedbacksUncheckedUpdateWithoutUsersInput>
    create: XOR<ConferenceFeedbacksCreateWithoutUsersInput, ConferenceFeedbacksUncheckedCreateWithoutUsersInput>
  }

  export type ConferenceFeedbacksUpdateWithWhereUniqueWithoutUsersInput = {
    where: ConferenceFeedbacksWhereUniqueInput
    data: XOR<ConferenceFeedbacksUpdateWithoutUsersInput, ConferenceFeedbacksUncheckedUpdateWithoutUsersInput>
  }

  export type ConferenceFeedbacksUpdateManyWithWhereWithoutUsersInput = {
    where: ConferenceFeedbacksScalarWhereInput
    data: XOR<ConferenceFeedbacksUpdateManyMutationInput, ConferenceFeedbacksUncheckedUpdateManyWithoutUsersInput>
  }

  export type ConferenceFollowsUpsertWithWhereUniqueWithoutUsersInput = {
    where: ConferenceFollowsWhereUniqueInput
    update: XOR<ConferenceFollowsUpdateWithoutUsersInput, ConferenceFollowsUncheckedUpdateWithoutUsersInput>
    create: XOR<ConferenceFollowsCreateWithoutUsersInput, ConferenceFollowsUncheckedCreateWithoutUsersInput>
  }

  export type ConferenceFollowsUpdateWithWhereUniqueWithoutUsersInput = {
    where: ConferenceFollowsWhereUniqueInput
    data: XOR<ConferenceFollowsUpdateWithoutUsersInput, ConferenceFollowsUncheckedUpdateWithoutUsersInput>
  }

  export type ConferenceFollowsUpdateManyWithWhereWithoutUsersInput = {
    where: ConferenceFollowsScalarWhereInput
    data: XOR<ConferenceFollowsUpdateManyMutationInput, ConferenceFollowsUncheckedUpdateManyWithoutUsersInput>
  }

  export type ConferenceLikesUpsertWithWhereUniqueWithoutUsersInput = {
    where: ConferenceLikesWhereUniqueInput
    update: XOR<ConferenceLikesUpdateWithoutUsersInput, ConferenceLikesUncheckedUpdateWithoutUsersInput>
    create: XOR<ConferenceLikesCreateWithoutUsersInput, ConferenceLikesUncheckedCreateWithoutUsersInput>
  }

  export type ConferenceLikesUpdateWithWhereUniqueWithoutUsersInput = {
    where: ConferenceLikesWhereUniqueInput
    data: XOR<ConferenceLikesUpdateWithoutUsersInput, ConferenceLikesUncheckedUpdateWithoutUsersInput>
  }

  export type ConferenceLikesUpdateManyWithWhereWithoutUsersInput = {
    where: ConferenceLikesScalarWhereInput
    data: XOR<ConferenceLikesUpdateManyMutationInput, ConferenceLikesUncheckedUpdateManyWithoutUsersInput>
  }

  export type ConferencesUpsertWithWhereUniqueWithoutUsersInput = {
    where: ConferencesWhereUniqueInput
    update: XOR<ConferencesUpdateWithoutUsersInput, ConferencesUncheckedUpdateWithoutUsersInput>
    create: XOR<ConferencesCreateWithoutUsersInput, ConferencesUncheckedCreateWithoutUsersInput>
  }

  export type ConferencesUpdateWithWhereUniqueWithoutUsersInput = {
    where: ConferencesWhereUniqueInput
    data: XOR<ConferencesUpdateWithoutUsersInput, ConferencesUncheckedUpdateWithoutUsersInput>
  }

  export type ConferencesUpdateManyWithWhereWithoutUsersInput = {
    where: ConferencesScalarWhereInput
    data: XOR<ConferencesUpdateManyMutationInput, ConferencesUncheckedUpdateManyWithoutUsersInput>
  }

  export type JournalFollowsUpsertWithWhereUniqueWithoutUsersInput = {
    where: JournalFollowsWhereUniqueInput
    update: XOR<JournalFollowsUpdateWithoutUsersInput, JournalFollowsUncheckedUpdateWithoutUsersInput>
    create: XOR<JournalFollowsCreateWithoutUsersInput, JournalFollowsUncheckedCreateWithoutUsersInput>
  }

  export type JournalFollowsUpdateWithWhereUniqueWithoutUsersInput = {
    where: JournalFollowsWhereUniqueInput
    data: XOR<JournalFollowsUpdateWithoutUsersInput, JournalFollowsUncheckedUpdateWithoutUsersInput>
  }

  export type JournalFollowsUpdateManyWithWhereWithoutUsersInput = {
    where: JournalFollowsScalarWhereInput
    data: XOR<JournalFollowsUpdateManyMutationInput, JournalFollowsUncheckedUpdateManyWithoutUsersInput>
  }

  export type JournalLikesUpsertWithWhereUniqueWithoutUsersInput = {
    where: JournalLikesWhereUniqueInput
    update: XOR<JournalLikesUpdateWithoutUsersInput, JournalLikesUncheckedUpdateWithoutUsersInput>
    create: XOR<JournalLikesCreateWithoutUsersInput, JournalLikesUncheckedCreateWithoutUsersInput>
  }

  export type JournalLikesUpdateWithWhereUniqueWithoutUsersInput = {
    where: JournalLikesWhereUniqueInput
    data: XOR<JournalLikesUpdateWithoutUsersInput, JournalLikesUncheckedUpdateWithoutUsersInput>
  }

  export type JournalLikesUpdateManyWithWhereWithoutUsersInput = {
    where: JournalLikesScalarWhereInput
    data: XOR<JournalLikesUpdateManyMutationInput, JournalLikesUncheckedUpdateManyWithoutUsersInput>
  }

  export type JournalsUpsertWithWhereUniqueWithoutUsersInput = {
    where: JournalsWhereUniqueInput
    update: XOR<JournalsUpdateWithoutUsersInput, JournalsUncheckedUpdateWithoutUsersInput>
    create: XOR<JournalsCreateWithoutUsersInput, JournalsUncheckedCreateWithoutUsersInput>
  }

  export type JournalsUpdateWithWhereUniqueWithoutUsersInput = {
    where: JournalsWhereUniqueInput
    data: XOR<JournalsUpdateWithoutUsersInput, JournalsUncheckedUpdateWithoutUsersInput>
  }

  export type JournalsUpdateManyWithWhereWithoutUsersInput = {
    where: JournalsScalarWhereInput
    data: XOR<JournalsUpdateManyMutationInput, JournalsUncheckedUpdateManyWithoutUsersInput>
  }

  export type JournalsScalarWhereInput = {
    AND?: JournalsScalarWhereInput | JournalsScalarWhereInput[]
    OR?: JournalsScalarWhereInput[]
    NOT?: JournalsScalarWhereInput | JournalsScalarWhereInput[]
    id?: StringFilter<"Journals"> | string
    name?: StringFilter<"Journals"> | string
    issn?: StringFilter<"Journals"> | string
    hIndex?: IntFilter<"Journals"> | number
    publisher?: StringFilter<"Journals"> | string
    nation?: StringFilter<"Journals"> | string
    scope?: StringFilter<"Journals"> | string
    emailSubmission?: StringFilter<"Journals"> | string
    creator?: StringFilter<"Journals"> | string
  }

  export type NotificationSettingsUpsertWithWhereUniqueWithoutUsersInput = {
    where: NotificationSettingsWhereUniqueInput
    update: XOR<NotificationSettingsUpdateWithoutUsersInput, NotificationSettingsUncheckedUpdateWithoutUsersInput>
    create: XOR<NotificationSettingsCreateWithoutUsersInput, NotificationSettingsUncheckedCreateWithoutUsersInput>
  }

  export type NotificationSettingsUpdateWithWhereUniqueWithoutUsersInput = {
    where: NotificationSettingsWhereUniqueInput
    data: XOR<NotificationSettingsUpdateWithoutUsersInput, NotificationSettingsUncheckedUpdateWithoutUsersInput>
  }

  export type NotificationSettingsUpdateManyWithWhereWithoutUsersInput = {
    where: NotificationSettingsScalarWhereInput
    data: XOR<NotificationSettingsUpdateManyMutationInput, NotificationSettingsUncheckedUpdateManyWithoutUsersInput>
  }

  export type NotificationsUpsertWithWhereUniqueWithoutUsersInput = {
    where: NotificationsWhereUniqueInput
    update: XOR<NotificationsUpdateWithoutUsersInput, NotificationsUncheckedUpdateWithoutUsersInput>
    create: XOR<NotificationsCreateWithoutUsersInput, NotificationsUncheckedCreateWithoutUsersInput>
  }

  export type NotificationsUpdateWithWhereUniqueWithoutUsersInput = {
    where: NotificationsWhereUniqueInput
    data: XOR<NotificationsUpdateWithoutUsersInput, NotificationsUncheckedUpdateWithoutUsersInput>
  }

  export type NotificationsUpdateManyWithWhereWithoutUsersInput = {
    where: NotificationsScalarWhereInput
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyWithoutUsersInput>
  }

  export type TopicUserInterestedsUpsertWithWhereUniqueWithoutUsersInput = {
    where: TopicUserInterestedsWhereUniqueInput
    update: XOR<TopicUserInterestedsUpdateWithoutUsersInput, TopicUserInterestedsUncheckedUpdateWithoutUsersInput>
    create: XOR<TopicUserInterestedsCreateWithoutUsersInput, TopicUserInterestedsUncheckedCreateWithoutUsersInput>
  }

  export type TopicUserInterestedsUpdateWithWhereUniqueWithoutUsersInput = {
    where: TopicUserInterestedsWhereUniqueInput
    data: XOR<TopicUserInterestedsUpdateWithoutUsersInput, TopicUserInterestedsUncheckedUpdateWithoutUsersInput>
  }

  export type TopicUserInterestedsUpdateManyWithWhereWithoutUsersInput = {
    where: TopicUserInterestedsScalarWhereInput
    data: XOR<TopicUserInterestedsUpdateManyMutationInput, TopicUserInterestedsUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserVerificationUpsertWithWhereUniqueWithoutUsersInput = {
    where: UserVerificationWhereUniqueInput
    update: XOR<UserVerificationUpdateWithoutUsersInput, UserVerificationUncheckedUpdateWithoutUsersInput>
    create: XOR<UserVerificationCreateWithoutUsersInput, UserVerificationUncheckedCreateWithoutUsersInput>
  }

  export type UserVerificationUpdateWithWhereUniqueWithoutUsersInput = {
    where: UserVerificationWhereUniqueInput
    data: XOR<UserVerificationUpdateWithoutUsersInput, UserVerificationUncheckedUpdateWithoutUsersInput>
  }

  export type UserVerificationUpdateManyWithWhereWithoutUsersInput = {
    where: UserVerificationScalarWhereInput
    data: XOR<UserVerificationUpdateManyMutationInput, UserVerificationUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserVerificationScalarWhereInput = {
    AND?: UserVerificationScalarWhereInput | UserVerificationScalarWhereInput[]
    OR?: UserVerificationScalarWhereInput[]
    NOT?: UserVerificationScalarWhereInput | UserVerificationScalarWhereInput[]
    id?: StringFilter<"UserVerification"> | string
    userId?: StringFilter<"UserVerification"> | string
    verificationCode?: StringFilter<"UserVerification"> | string
    verificationCodeExpires?: DateTimeFilter<"UserVerification"> | Date | string
    isVerified?: BoolFilter<"UserVerification"> | boolean
    createdAt?: DateTimeFilter<"UserVerification"> | Date | string
    updatedAt?: DateTimeFilter<"UserVerification"> | Date | string
  }

  export type ConferencesCreateManyAdminsInput = {
    id: string
    title: string
    acronym: string
    creatorId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
  }

  export type ConferencesUpdateWithoutAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUpdateManyWithoutConferencesNestedInput
    ConferenceCalendars?: ConferenceCalendarsUpdateManyWithoutConferencesNestedInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUpdateManyWithoutConferencesNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUpdateManyWithoutConferencesNestedInput
    ConferenceFollows?: ConferenceFollowsUpdateManyWithoutConferencesNestedInput
    ConferenceLikes?: ConferenceLikesUpdateManyWithoutConferencesNestedInput
    ConferenceOrganizations?: ConferenceOrganizationsUpdateManyWithoutConferencesNestedInput
    ConferenceRanks?: ConferenceRanksUpdateManyWithoutConferencesNestedInput
    Users?: UsersUpdateOneWithoutConferencesNestedInput
  }

  export type ConferencesUncheckedUpdateWithoutAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceFollows?: ConferenceFollowsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceLikes?: ConferenceLikesUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceOrganizations?: ConferenceOrganizationsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceRanks?: ConferenceRanksUncheckedUpdateManyWithoutConferencesNestedInput
  }

  export type ConferencesUncheckedUpdateManyWithoutAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ConferenceDatesCreateManyConferenceOrganizationsInput = {
    id: string
    fromDate: Date | string
    toDate: Date | string
    type: string
    name: string
    createdAt?: Date | string
    updatedAt: Date | string
    isAvailable: boolean
  }

  export type ConferenceTopicsCreateManyConferenceOrganizationsInput = {
    id: string
    topicId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type LocationsCreateManyConferenceOrganizationsInput = {
    id: string
    address?: string | null
    cityStateProvince?: string | null
    country?: string | null
    continent?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    isAvailable: boolean
  }

  export type ConferenceDatesUpdateWithoutConferenceOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConferenceDatesUncheckedUpdateWithoutConferenceOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConferenceDatesUncheckedUpdateManyWithoutConferenceOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConferenceTopicsUpdateWithoutConferenceOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Topics?: TopicsUpdateOneRequiredWithoutConferenceTopicsNestedInput
  }

  export type ConferenceTopicsUncheckedUpdateWithoutConferenceOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceTopicsUncheckedUpdateManyWithoutConferenceOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationsUpdateWithoutConferenceOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityStateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LocationsUncheckedUpdateWithoutConferenceOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityStateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LocationsUncheckedUpdateManyWithoutConferenceOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityStateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConferenceBlacklistsCreateManyConferencesInput = {
    id: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceCalendarsCreateManyConferencesInput = {
    id: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceCrawlJobsCreateManyConferencesInput = {
    id: string
    status: string
    progress: number
    message: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceFeedbacksCreateManyConferencesInput = {
    id: string
    creatorId: string
    description: string
    star: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceFollowsCreateManyConferencesInput = {
    id: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceLikesCreateManyConferencesInput = {
    id: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceOrganizationsCreateManyConferencesInput = {
    id: string
    year?: number | null
    accessType: string
    isAvailable: boolean
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceRanksCreateManyConferencesInput = {
    id: string
    year: number
    fieldOfResearchId: string
    rankId: string
  }

  export type ConferenceBlacklistsUpdateWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUpdateOneRequiredWithoutConferenceBlacklistsNestedInput
  }

  export type ConferenceBlacklistsUncheckedUpdateWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceBlacklistsUncheckedUpdateManyWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCalendarsUpdateWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUpdateOneRequiredWithoutConferenceCalendarsNestedInput
  }

  export type ConferenceCalendarsUncheckedUpdateWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCalendarsUncheckedUpdateManyWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCrawlJobsUpdateWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCrawlJobsUncheckedUpdateWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCrawlJobsUncheckedUpdateManyWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFeedbacksUpdateWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    star?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUpdateOneRequiredWithoutConferenceFeedbacksNestedInput
  }

  export type ConferenceFeedbacksUncheckedUpdateWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    star?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFeedbacksUncheckedUpdateManyWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    star?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFollowsUpdateWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUpdateOneRequiredWithoutConferenceFollowsNestedInput
  }

  export type ConferenceFollowsUncheckedUpdateWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFollowsUncheckedUpdateManyWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceLikesUpdateWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUpdateOneRequiredWithoutConferenceLikesNestedInput
  }

  export type ConferenceLikesUncheckedUpdateWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceLikesUncheckedUpdateManyWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceOrganizationsUpdateWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ConferenceDates?: ConferenceDatesUpdateManyWithoutConferenceOrganizationsNestedInput
    ConferenceTopics?: ConferenceTopicsUpdateManyWithoutConferenceOrganizationsNestedInput
    Locations?: LocationsUpdateManyWithoutConferenceOrganizationsNestedInput
  }

  export type ConferenceOrganizationsUncheckedUpdateWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ConferenceDates?: ConferenceDatesUncheckedUpdateManyWithoutConferenceOrganizationsNestedInput
    ConferenceTopics?: ConferenceTopicsUncheckedUpdateManyWithoutConferenceOrganizationsNestedInput
    Locations?: LocationsUncheckedUpdateManyWithoutConferenceOrganizationsNestedInput
  }

  export type ConferenceOrganizationsUncheckedUpdateManyWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceRanksUpdateWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    FieldOfResearchs?: FieldOfResearchsUpdateOneRequiredWithoutConferenceRanksNestedInput
    Ranks?: RanksUpdateOneRequiredWithoutConferenceRanksNestedInput
  }

  export type ConferenceRanksUncheckedUpdateWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    fieldOfResearchId?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
  }

  export type ConferenceRanksUncheckedUpdateManyWithoutConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    fieldOfResearchId?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
  }

  export type ConferenceRanksCreateManyFieldOfResearchsInput = {
    id: string
    year: number
    conferenceId: string
    rankId: string
  }

  export type JournalRanksCreateManyFieldOfResearchsInput = {
    id: string
    year: number
    journalId: string
    rankId: string
  }

  export type ConferenceRanksUpdateWithoutFieldOfResearchsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    Conferences?: ConferencesUpdateOneRequiredWithoutConferenceRanksNestedInput
    Ranks?: RanksUpdateOneRequiredWithoutConferenceRanksNestedInput
  }

  export type ConferenceRanksUncheckedUpdateWithoutFieldOfResearchsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    conferenceId?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
  }

  export type ConferenceRanksUncheckedUpdateManyWithoutFieldOfResearchsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    conferenceId?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalRanksUpdateWithoutFieldOfResearchsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    Journals?: JournalsUpdateOneRequiredWithoutJournalRanksNestedInput
    Ranks?: RanksUpdateOneRequiredWithoutJournalRanksNestedInput
  }

  export type JournalRanksUncheckedUpdateWithoutFieldOfResearchsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    journalId?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalRanksUncheckedUpdateManyWithoutFieldOfResearchsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    journalId?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalCrawlJobsCreateManyJournalsInput = {
    id: string
    status: string
    progress: number
    message: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type JournalFollowsCreateManyJournalsInput = {
    id: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type JournalLikesCreateManyJournalsInput = {
    id: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type JournalRanksCreateManyJournalsInput = {
    id: string
    year: number
    fieldOfResearchId: string
    rankId: string
  }

  export type JournalTopicsCreateManyJournalsInput = {
    id: string
    topicId: string
  }

  export type JournalCrawlJobsUpdateWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalCrawlJobsUncheckedUpdateWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalCrawlJobsUncheckedUpdateManyWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalFollowsUpdateWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUpdateOneRequiredWithoutJournalFollowsNestedInput
  }

  export type JournalFollowsUncheckedUpdateWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalFollowsUncheckedUpdateManyWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLikesUpdateWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUpdateOneRequiredWithoutJournalLikesNestedInput
  }

  export type JournalLikesUncheckedUpdateWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLikesUncheckedUpdateManyWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalRanksUpdateWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    FieldOfResearchs?: FieldOfResearchsUpdateOneRequiredWithoutJournalRanksNestedInput
    Ranks?: RanksUpdateOneRequiredWithoutJournalRanksNestedInput
  }

  export type JournalRanksUncheckedUpdateWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    fieldOfResearchId?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalRanksUncheckedUpdateManyWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    fieldOfResearchId?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalTopicsUpdateWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    Topics?: TopicsUpdateOneRequiredWithoutJournalTopicsNestedInput
  }

  export type JournalTopicsUncheckedUpdateWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalTopicsUncheckedUpdateManyWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationSettingsCreateManyNotificationsTypesInput = {
    id: string
    userId: string
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NotificationsCreateManyNotificationsTypesInput = {
    id: string
    userId: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NotificationSettingsUpdateWithoutNotificationsTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUpdateOneRequiredWithoutNotificationSettingsNestedInput
  }

  export type NotificationSettingsUncheckedUpdateWithoutNotificationsTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsUncheckedUpdateManyWithoutNotificationsTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsUpdateWithoutNotificationsTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationsUncheckedUpdateWithoutNotificationsTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsUncheckedUpdateManyWithoutNotificationsTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceRanksCreateManyRanksInput = {
    id: string
    year: number
    conferenceId: string
    fieldOfResearchId: string
  }

  export type JournalRanksCreateManyRanksInput = {
    id: string
    year: number
    journalId: string
    fieldOfResearchId: string
  }

  export type ConferenceRanksUpdateWithoutRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    Conferences?: ConferencesUpdateOneRequiredWithoutConferenceRanksNestedInput
    FieldOfResearchs?: FieldOfResearchsUpdateOneRequiredWithoutConferenceRanksNestedInput
  }

  export type ConferenceRanksUncheckedUpdateWithoutRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    conferenceId?: StringFieldUpdateOperationsInput | string
    fieldOfResearchId?: StringFieldUpdateOperationsInput | string
  }

  export type ConferenceRanksUncheckedUpdateManyWithoutRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    conferenceId?: StringFieldUpdateOperationsInput | string
    fieldOfResearchId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalRanksUpdateWithoutRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    FieldOfResearchs?: FieldOfResearchsUpdateOneRequiredWithoutJournalRanksNestedInput
    Journals?: JournalsUpdateOneRequiredWithoutJournalRanksNestedInput
  }

  export type JournalRanksUncheckedUpdateWithoutRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    journalId?: StringFieldUpdateOperationsInput | string
    fieldOfResearchId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalRanksUncheckedUpdateManyWithoutRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    journalId?: StringFieldUpdateOperationsInput | string
    fieldOfResearchId?: StringFieldUpdateOperationsInput | string
  }

  export type RanksCreateManySourcesInput = {
    id: string
    name: string
    value: number
  }

  export type RanksUpdateWithoutSourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    ConferenceRanks?: ConferenceRanksUpdateManyWithoutRanksNestedInput
    JournalRanks?: JournalRanksUpdateManyWithoutRanksNestedInput
  }

  export type RanksUncheckedUpdateWithoutSourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    ConferenceRanks?: ConferenceRanksUncheckedUpdateManyWithoutRanksNestedInput
    JournalRanks?: JournalRanksUncheckedUpdateManyWithoutRanksNestedInput
  }

  export type RanksUncheckedUpdateManyWithoutSourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type ConferenceTopicsCreateManyTopicsInput = {
    id: string
    organizeId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type JournalTopicsCreateManyTopicsInput = {
    id: string
    journalId: string
  }

  export type TopicUserInterestedsCreateManyTopicsInput = {
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceTopicsUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ConferenceOrganizations?: ConferenceOrganizationsUpdateOneRequiredWithoutConferenceTopicsNestedInput
  }

  export type ConferenceTopicsUncheckedUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceTopicsUncheckedUpdateManyWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalTopicsUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    Journals?: JournalsUpdateOneRequiredWithoutJournalTopicsNestedInput
  }

  export type JournalTopicsUncheckedUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalTopicsUncheckedUpdateManyWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
  }

  export type TopicUserInterestedsUpdateWithoutTopicsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUpdateOneRequiredWithoutTopicUserInterestedsNestedInput
  }

  export type TopicUserInterestedsUncheckedUpdateWithoutTopicsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicUserInterestedsUncheckedUpdateManyWithoutTopicsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceBlacklistsCreateManyUsersInput = {
    id: string
    conferenceId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceCalendarsCreateManyUsersInput = {
    id: string
    conferenceId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceFeedbacksCreateManyUsersInput = {
    id: string
    conferenceId: string
    description: string
    star: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceFollowsCreateManyUsersInput = {
    id: string
    conferenceId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceLikesCreateManyUsersInput = {
    id: string
    conferenceId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferencesCreateManyUsersInput = {
    id: string
    title: string
    acronym: string
    createdAt?: Date | string
    updatedAt: Date | string
    status: string
    adminId?: string | null
  }

  export type JournalFollowsCreateManyUsersInput = {
    id: string
    journalId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type JournalLikesCreateManyUsersInput = {
    id: string
    journalId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type JournalsCreateManyUsersInput = {
    id: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
  }

  export type NotificationSettingsCreateManyUsersInput = {
    id: string
    notificationId: string
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NotificationsCreateManyUsersInput = {
    id: string
    notificationId: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TopicUserInterestedsCreateManyUsersInput = {
    topicId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type UserVerificationCreateManyUsersInput = {
    id: string
    verificationCode: string
    verificationCodeExpires: Date | string
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ConferenceBlacklistsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Conferences?: ConferencesUpdateOneRequiredWithoutConferenceBlacklistsNestedInput
  }

  export type ConferenceBlacklistsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceBlacklistsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCalendarsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Conferences?: ConferencesUpdateOneRequiredWithoutConferenceCalendarsNestedInput
  }

  export type ConferenceCalendarsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCalendarsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFeedbacksUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    star?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Conferences?: ConferencesUpdateOneRequiredWithoutConferenceFeedbacksNestedInput
  }

  export type ConferenceFeedbacksUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    star?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFeedbacksUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    star?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFollowsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Conferences?: ConferencesUpdateOneRequiredWithoutConferenceFollowsNestedInput
  }

  export type ConferenceFollowsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFollowsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceLikesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Conferences?: ConferencesUpdateOneRequiredWithoutConferenceLikesNestedInput
  }

  export type ConferenceLikesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceLikesUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferencesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    ConferenceBlacklists?: ConferenceBlacklistsUpdateManyWithoutConferencesNestedInput
    ConferenceCalendars?: ConferenceCalendarsUpdateManyWithoutConferencesNestedInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUpdateManyWithoutConferencesNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUpdateManyWithoutConferencesNestedInput
    ConferenceFollows?: ConferenceFollowsUpdateManyWithoutConferencesNestedInput
    ConferenceLikes?: ConferenceLikesUpdateManyWithoutConferencesNestedInput
    ConferenceOrganizations?: ConferenceOrganizationsUpdateManyWithoutConferencesNestedInput
    ConferenceRanks?: ConferenceRanksUpdateManyWithoutConferencesNestedInput
    Admins?: AdminsUpdateOneWithoutConferencesNestedInput
  }

  export type ConferencesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    ConferenceBlacklists?: ConferenceBlacklistsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceCalendars?: ConferenceCalendarsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceCrawlJobs?: ConferenceCrawlJobsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceFeedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceFollows?: ConferenceFollowsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceLikes?: ConferenceLikesUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceOrganizations?: ConferenceOrganizationsUncheckedUpdateManyWithoutConferencesNestedInput
    ConferenceRanks?: ConferenceRanksUncheckedUpdateManyWithoutConferencesNestedInput
  }

  export type ConferencesUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalFollowsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Journals?: JournalsUpdateOneRequiredWithoutJournalFollowsNestedInput
  }

  export type JournalFollowsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalFollowsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLikesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Journals?: JournalsUpdateOneRequiredWithoutJournalLikesNestedInput
  }

  export type JournalLikesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLikesUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    JournalCrawlJobs?: JournalCrawlJobsUpdateManyWithoutJournalsNestedInput
    JournalFollows?: JournalFollowsUpdateManyWithoutJournalsNestedInput
    JournalLikes?: JournalLikesUpdateManyWithoutJournalsNestedInput
    JournalRanks?: JournalRanksUpdateManyWithoutJournalsNestedInput
    JournalTopics?: JournalTopicsUpdateManyWithoutJournalsNestedInput
  }

  export type JournalsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    JournalCrawlJobs?: JournalCrawlJobsUncheckedUpdateManyWithoutJournalsNestedInput
    JournalFollows?: JournalFollowsUncheckedUpdateManyWithoutJournalsNestedInput
    JournalLikes?: JournalLikesUncheckedUpdateManyWithoutJournalsNestedInput
    JournalRanks?: JournalRanksUncheckedUpdateManyWithoutJournalsNestedInput
    JournalTopics?: JournalTopicsUncheckedUpdateManyWithoutJournalsNestedInput
  }

  export type JournalsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationSettingsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NotificationsTypes?: NotificationsTypesUpdateOneRequiredWithoutNotificationSettingsNestedInput
  }

  export type NotificationSettingsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NotificationsTypes?: NotificationsTypesUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicUserInterestedsUpdateWithoutUsersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Topics?: TopicsUpdateOneRequiredWithoutTopicUserInterestedsNestedInput
  }

  export type TopicUserInterestedsUncheckedUpdateWithoutUsersInput = {
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicUserInterestedsUncheckedUpdateManyWithoutUsersInput = {
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserVerificationUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    verificationCode?: StringFieldUpdateOperationsInput | string
    verificationCodeExpires?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserVerificationUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    verificationCode?: StringFieldUpdateOperationsInput | string
    verificationCodeExpires?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserVerificationUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    verificationCode?: StringFieldUpdateOperationsInput | string
    verificationCodeExpires?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}