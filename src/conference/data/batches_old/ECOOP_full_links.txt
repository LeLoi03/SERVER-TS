Conference full name: European Conference on Object-Oriented Programming (ECOOP)

1. Website of ECOOP_3: https://2025.ecoop.org/series/ecoop
Website information of ECOOP_3:

href="https://2025.ecoop.org" - ECOOP 2025
Mon 30 June - Fri 4 July 2025href="https://2025.ecoop.org/venue/ecoop-2025-venue" - Bergen, Norway
Toggle navigation 
 href="https://2025.ecoop.org/series/ecoop" - Series 
 href="https://2025.ecoop.org" - ECOOP 2025 
 All Editions | href="https://2026.ecoop.org" - ECOOP 2026 
 ECOOP 2025 
 href="https://2024.ecoop.org" - ECOOP 2024 
 href="https://2023.ecoop.org" - ECOOP 2023 
 href="https://2022.ecoop.org" - ECOOP 2022 
 href="https://2021.ecoop.org" - ECOOP 2021 
 href="https://2020.ecoop.org" - ECOOP 2020 
 href="https://2019.ecoop.org" - ECOOP 2019 
 href="https://2018.ecoop.org" - ECOOP 2018 
 href="https://2017.ecoop.org" - ECOOP 2017 
 href="https://2016.ecoop.org" - ECOOP 2016 
 href="https://2015.ecoop.org" - ECOOP 2015 
 href="http://2014.ecoop.org" - 2014: Uppsala 
 href="http://2013.ecoop.org" - 2013: Montpellier 
 href="http://ecoop12.cs.purdue.edu" - 2012: Beijing 
 href="http://scc-sentinel.lancs.ac.uk/ecoop11/" - 2011: Lancaster 
 href="http://ecoop2010.uni-mb.si" - 2010: Maribor 
 href="http://ecoop09.disi.unige.it" - 2009: Genova 
 href="https://ecoop08.cs.ucy.ac.cy" - 2008: Cyprus 
 href="http://ecoop07.swt.cs.tu-berlin.de" - 2007: Berlin 
 href="http://www.emn.fr/z-info/ecoop2006/" - 2006: Nice 
 href="http://2005.ecoop.org/" - 2005: Glasgow 
 href="https://conf.researchr.org/signin/ecoop-2025/https%3A%5Es%5Es2025.ecoop.org%5Esseries%5Esecoop" - Sign in 
 href="https://2025.ecoop.org/signup" - Sign up 
 Photo byDiego Delso 
 ECOOP 2025 
 Western Norway University of Applied Sciences 
 Bergen, Norway 
 30.6.-4.7.2025 
 Photo byViolet Ka I Pun 
 View of Bergen from Fløyen 
 Conference Venue 
 HVL Campus Bergen - Building K2 
 Photo by@agentj 
 Bryggen - World Cultural Heritage 
 Photo byPetr Šmerkl, Wikipedia 
 Håkonshallen 
 Photo byBjørn Christian Tørrissen 
 Inside Håkonshallen 
 Photo bySvein-Magne Tunli 
 Fantoft Stave Church 
 Photo bySvein-Magne Tunli 
 Bergen at night 
 ECOOP 
 All Editions 
  
 Mon 29 June - Fri 3 July 2026 Brussels, Belgiumhref="https://2026.ecoop.org" - ECOOP 2026
Welcome to the website of the ECOOP 2026 conference. We are working hard to fill the website with all related information. Please check back soon! 
 Mon 30 June - Fri 4 July 2025 Bergen, Norwayhref="https://2025.ecoop.org" - ECOOP 2025
withhref="https://2025.ecoop.org/home/gpce-2025" - GPCE 2025
,href="https://2025.ecoop.org/home/debt-2025" - DEBT 2025
,href="https://2025.ecoop.org/home/FTfJP-2025" - FTfJP 2025
,href="https://2025.ecoop.org/home/ICOOOLPS-2025" - ICOOOLPS 2025
,href="https://2025.ecoop.org/home/plf-plaid-2025" - PLF+PLAID 2025
,href="https://2025.ecoop.org/home/plss-2025" - PLSS 2025
,href="https://2025.ecoop.org/home/vortex-2025" - VORTEX 2025
ECOOP is Europe’s longest-standing annual Programming Languages conference, bringing together researchers, practitioners, and students to share their ideas and experiences in all topics related to programming languages, software development, systems and applications. ECOOP welcomes high quality research papers relating to these fields in a broad sense. ECOOP is committed to affordable open access publishing. Rec ... 
 Mon 16 - Fri 20 September 2024 Vienna, Austriahref="https://2024.ecoop.org" - ECOOP 2024
withhref="https://conf.researchr.org/home/issta-ecoop-2024" - ISSTA/ECOOP 2024
ECOOP is Europe’s longest-standing annual Programming Languages conference, bringing together researchers, practitioners, and students to share their ideas and experiences in all topics related to programming languages, software development, systems and applications. ECOOP welcomes high quality research papers relating to these fields in a broad sense. ECOOP is committed to affordable open access publishing. Rec ... 
 Mon 17 - Fri 21 July 2023 Seattle (University of Washington campus), Washington, United Stateshref="https://2023.ecoop.org" - ECOOP 2023
withhref="https://conf.researchr.org/home/ecoop-issta-2023" - ECOOP and ISSTA 2023
ECOOP is Europe’s longest-standing annual Programming Languages conference, bringing together researchers, practitioners, and students to share their ideas and experiences in all topics related to programming languages, software development, systems and applications. ECOOP welcomes high quality research papers relating to these fields in a broad sense. ECOOP is committed to affordable open access publishing. Rec ... 
 Mon 6 June - Thu 7 July 2022 Berlin, Germanyhref="https://2022.ecoop.org" - ECOOP 2022
withhref="https://2022.ecoop.org/home/scala-2022" - Scala 2022
,href="https://2022.ecoop.org/home/COP-2022" - COP 2022
,href="https://2022.ecoop.org/home/FTfJP-2022" - FTfJP 2022
,href="https://2022.ecoop.org/home/ICOOOLPS-2022" - ICOOOLPS 2022
,href="https://2022.ecoop.org/home/paw-2022" - PAW 2022
,href="https://2022.ecoop.org/home/plf-2022" - PLF 2022
,href="https://2022.ecoop.org/home/pride-2022" - PRIDE 2022
,href="https://2022.ecoop.org/home/truffle-2022" - Truffle 2022
,href="https://2022.ecoop.org/home/vortex-2022" - VORTEX 2022
ECOOP is Europe’s longest-standing annual Programming Languages (PL) conference, and welcomes high quality research papers relating to the PL field in a broad sense. This year the conference will feature dedicated paper categories for reproduction studies, experience reports, reflective “pearls”, and forward-thinking “new idea” papers. We are also pleased to have two Journal First routes for submission to ECOOP, ... 
 Sun 11 - Sat 17 July 2021 Onlinehref="https://2021.ecoop.org" - ECOOP 2021
withhref="https://conf.researchr.org/home/ecoop-issta-2021" - ECOOP and ISSTA 2021
ECOOP is Europe’s longest-standing annual Programming Languages conference, bringing together researchers, practitioners, and students to share their ideas and experiences in all topics related to programming languages, software development, object-oriented technologies, systems and applications. ECOOP welcomes high quality research papers relating to these fields in a broad sense. In 2021 we celebrate the 35th ... 
 Sun 15 - Tue 17 November 2020 Online Conferencehref="https://2020.ecoop.org" - ECOOP 2020
withSPLASH 2020 
 withhref="https://2020.ecoop.org/home/scala-2020" - Scala 2020
,href="https://2020.ecoop.org/home/COP-2020" - COP
,href="https://2020.ecoop.org/home/FTfJP-2020" - FTfJP 2020
,href="https://2020.ecoop.org/home/ICOOOLPS-2020" - ICOOOLPS 2020
,href="https://2020.ecoop.org/home/iwaco-2020" - IWACO 2020
,href="https://2020.ecoop.org/home/JSTools-2020" - JSTools 2020
,href="https://2020.ecoop.org/home/pride-2020" - PRIDE 2020
,href="https://2020.ecoop.org/home/soop-2020" - SOOP'20
,href="https://2020.ecoop.org/home/sysepl-2020" - SySEPL 2020
,href="https://2020.ecoop.org/home/vortex-2020" - VORTEX 2020
ECOOP is Europe’s longest-standing annual Programming Languages (PL) conference, and welcomes high quality research papers relating to the PL field in a broad sense. This year the conference will feature dedicated paper categories for reproduction studies, experience reports, reflective “pearls”, and forward-thinking “new idea” papers. We are also pleased to have two Journal First routes for submission to ECOOP, ... 
 Mon 15 - Fri 19 July 2019 Hammersmith, London, United Kingdomhref="https://2019.ecoop.org" - ECOOP 2019
withhref="https://2019.ecoop.org/home/aorta-2019" - AORTA 2019
,href="https://2019.ecoop.org/home/benchwork-2019" - BenchWork 2019
,href="https://2019.ecoop.org/home/COP-2019" - COP 2019
,href="https://2019.ecoop.org/home/FTfJP-2019" - FTfJP 2019
,href="https://2019.ecoop.org/home/ICOOOLPS-2019" - ICOOOLPS 2019
,href="https://2019.ecoop.org/home/PASS-ECOOP-2019" - PASS 2019
,href="https://2019.ecoop.org/home/panathon-2019" - Panathon 2019
,href="https://2019.ecoop.org/home/scala-2019" - Scala 2019
,href="https://2019.ecoop.org/home/vortex-2019" - VORTEX 2019
ECOOP is Europe’s longest-standing annual Programming Languages (PL) conference, and welcomes high quality research papers relating to the PL field in a broad sense. This year the conference will feature dedicated paper categories for reproduction studies, experience reports, reflective “pearls”, and forward-thinking “new idea” papers. We are also pleased to have two Journal First routes for submission to ECOOP, ... 
 Sun 15 - Sat 21 July 2018 Amsterdam, Netherlandshref="https://2018.ecoop.org" - ECOOP 2018
withhref="https://conf.researchr.org/home/ecoop-issta-2018" - ECOOP and ISSTA 2018
The ECOOP is the European forum for bringing together researchers, practitioners, and students to share their ideas and experiences in all topics related to programming languages, software development, object-oriented technologies, systems and applications. ECOOP will take place from July 19th to 21st 2018 in Amsterdam. Colocated conferences include ISSTA and Curry On. ECOOP is Open Access ... 
 Sun 18 - Fri 23 June 2017 Barcelona, Spainhref="https://2017.ecoop.org" - ECOOP 2017
withhref="https://conf.researchr.org/home/pldi-ecoop-2017" - PLDI, ECOOP, Curry On, DEBS, LCTES and ISMM
withhref="https://2017.ecoop.org/track/COP-2017-papers" - COP 2017
,href="https://2017.ecoop.org/track/FTfJP-2017-papers" - FTfJP 2017
,href="https://2017.ecoop.org/track/ICOOOLPS-2017-papers" - ICOOOLPS 2017
,href="https://2017.ecoop.org/track/iwaco-2017-papers" - IWACO 2017
,href="https://2017.ecoop.org/track/JSTools-2017-papers" - JSTools 2017
,href="https://2017.ecoop.org/track/pmldc-2017-papers" - PMLDC 2017
,href="https://2017.ecoop.org/track/vortex-2017-papers" - VORTEX 2017
The European Conference on Object-Oriented Programming is the European forum for bringing together researchers, practitioners, and students to share their ideas and experiences in all topics related to programming languages, software development, object-oriented technologies, systems and applications. It is a well-integrated collage of events, featuring carefully refereed technical papers, topic-focused workshop ... 
 Sun 17 - Fri 22 July 2016 Rome, Italyhref="https://2016.ecoop.org" - ECOOP 2016
withhref="https://conf.researchr.org/home/curryon-2016" - CurryOn 2016
,href="https://2016.ecoop.org/track/COP-2016" - COP 2016
,href="https://2016.ecoop.org/track/FTfJP-2016" - FTfJP 2016
,href="https://2016.ecoop.org/track/GRACE-2016" - GRACE 2016
,href="https://2016.ecoop.org/track/ICOOOLPS-2016" - ICOOOLPS 2016
,href="https://2016.ecoop.org/track/IWACO-2016" - IWACO 2016
,href="https://2016.ecoop.org/track/JSTools-2016" - JSTools 2016
,href="https://2016.ecoop.org/track/LIVE-2016" - LIVE 2016
,href="https://2016.ecoop.org/track/PMLDC-2016" - PMLDC 2016
,href="https://2016.ecoop.org/track/PX-2016" - PX 2016
,href="https://2016.ecoop.org/track/STOP-2016" - STOP 2016
,href="https://2016.ecoop.org/track/VORTEX-2016" - VORTEX 2016
At a glance: Videos | Awards | Proceedings | Artifacts | Restaurants | Walks The European Conference on Object-Oriented Programming covers all areas of object technology and related software development technologies. Come celebrate the 30th edition in Rome, Italy, on July 17-22, 2016. This year Curry On, the ECOOP Summer School, the PhD Symposium, and 11 workshops will be all co-locate ... 
 Sun 5 - Fri 10 July 2015 Prague, Czech Republichref="https://2015.ecoop.org" - ECOOP 2015
withhref="https://conf.researchr.org/home/COP-2015" - COP 2015
,href="https://conf.researchr.org/home/dsldi-2015" - DSLDI 2015
,href="https://conf.researchr.org/home/FTfJP-2015" - FTfJP 2015
,href="https://2015.ecoop.org/track/ICOOOLPS-2015-papers" - ICOOOLPS 2015
,href="https://conf.researchr.org/home/JSTools-2015" - JSTools 2015
,href="https://conf.researchr.org/home/MASPEGHI-2015" - MASPEGHI 2015
,href="https://conf.researchr.org/home/ML4PL-2015" - ML4PL 2015
,href="https://2015.ecoop.org/home/netpl-2015" - NetPL 2015
,href="https://conf.researchr.org/home/PLAS-2015" - PLAS 2015
,href="https://conf.researchr.org/home/PLE-2015" - PLE 2015
,href="https://conf.researchr.org/home/Pharo-2015" - Pharo 2015
,href="https://conf.researchr.org/home/RIOT-2015" - RIOT 2015
,STOP 2015,Truffle 2015 
 ECOOP/Curry On program here. The European Conference on Object-Oriented Programming covers all areas of object technology and related software development technologies. The 29th edition takes place 5-10 July, 2015 in Prague, Czech Republic. The program committee accepted 31 papers out of 136 submission. In addition the program includes 13 workshops, the doctoral symposium, the summer school and a code sprint. ... 
 June 20142014: Uppsala 
 More information on this edition athref="http://2014.ecoop.org" - http://2014.ecoop.org 
 June 20132013: Montpellier 
 More information on this edition athref="http://2013.ecoop.org" - http://2013.ecoop.org 
 June 20122012: Beijing 
 More information on this edition athref="http://ecoop12.cs.purdue.edu" - http://ecoop12.cs.purdue.edu 
 June 20112011: Lancaster 
 More information on this edition athref="http://scc-sentinel.lancs.ac.uk/ecoop11/" - http://scc-sentinel.lancs.ac.uk/ecoop11/ 
 June 20102010: Maribor 
 More information on this edition athref="http://ecoop2010.uni-mb.si" - http://ecoop2010.uni-mb.si 
 June 20092009: Genova 
 More information on this edition athref="http://ecoop09.disi.unige.it" - http://ecoop09.disi.unige.it 
 June 20082008: Cyprus 
 More information on this edition athref="https://ecoop08.cs.ucy.ac.cy" - https://ecoop08.cs.ucy.ac.cy 
 June 20072007: Berlin 
 More information on this edition athref="http://ecoop07.swt.cs.tu-berlin.de" - http://ecoop07.swt.cs.tu-berlin.de 
 June 20062006: Nice 
 More information on this edition athref="http://www.emn.fr/z-info/ecoop2006/" - http://www.emn.fr/z-info/ecoop2006/ 
 June 20052005: Glasgow 
 More information on this edition athref="http://2005.ecoop.org/" - http://2005.ecoop.org/ 
 Organizing Committee (ECOOP 2025) 
 href="https://2025.ecoop.org/profile/volkerstolz" - Volker StolzGeneral ChairHøgskulen på VestlandetNorway 
 href="https://2025.ecoop.org/profile/alexandrasilva" - Alexandra SilvaPC Co-ChairCornell UniversityUnited States 
 href="https://2025.ecoop.org/profile/jonathanaldrich" - Jonathan AldrichPC Co-ChairCarnegie Mellon UniversityUnited States 
 href="https://2025.ecoop.org/profile/violetkaipun" - Violet Ka I PunLocal Organization ChairWestern Norway University of Applied SciencesNorway 
 href="https://2025.ecoop.org/profile/maitran" - Mai TranDiversity and Inclusion ChairInterBe ASNorway 
 href="https://2025.ecoop.org/profile/clementaubert" - Clément AubertWorkshops/Tools Co-ChairAugusta UniversityUnited States 
 href="https://2025.ecoop.org/profile/giorgioaudrito" - Giorgio AudritoPublicity ChairUniversità di TorinoItaly 
 href="https://2025.ecoop.org/profile/mikhailbarash" - Mikhail BarashDoctoral Symposium Co-ChairUniversity of BergenNorway 
 Tosin Daniel OyetoyanSponsorship Co-Chair 
 Western Norway University of Applied Sciences 
 Norway 
 href="https://2025.ecoop.org/profile/karineevenmendoza" - Karine Even-MendozaArtifact Evaluation Co-ChairKing’s College LondonUnited Kingdom 
 href="https://2025.ecoop.org/profile/carlaferreira" - Carla FerreiraDoctoral Symposium Co-ChairNOVA University LisbonPortugal 
 href="https://2025.ecoop.org/profile/raphaelmonat" - Raphaël MonatArtifact Evaluation Co-ChairInria and University of LilleFrance 
 href="https://2025.ecoop.org/profile/ivanspajic1" - Ivan SpajićWeb ChairWestern Norway University of Applied SciencesNorway 
 href="https://2025.ecoop.org/profile/yannickzakowski1" - Yannick ZakowskiArtifact Evaluation Co-ChairInriaFrance 
 xSat 5 Apr 10:25 
 usinghref="https://conf.researchr.org" - conf.researchr.org
(href="http://yellowgrass.org/roadmap/conf.researchr.org" - v1.69.0
) 
 href="https://conf.researchr.org/support/conf" - Support page
 
 href="https://conf.researchr.org/signup/conf" - Sign Up

2. Website of ECOOP_3: https://2025.ecoop.org/
Website information of ECOOP_3:

href="https://2025.ecoop.org" - ECOOP 2025
Mon 30 June - Fri 4 July 2025href="https://2025.ecoop.org/venue/ecoop-2025-venue" - Bergen, Norway
Toggle navigation 
 Attending | href="https://2025.ecoop.org/venue/ecoop-2025-venue" - Venue: Western Norway University of Applied Sciences 
 href="https://2025.ecoop.org/venue/ecoop-2025-haakonshallen" - Reception: Håkonshallen 
 href="https://2025.ecoop.org/attending/travel" - Getting There (And Away) 
 href="https://2025.ecoop.org/attending/weather" - Weather 
 href="https://2025.ecoop.org/attending/accommodation" - Accommodation 
 href="https://2025.ecoop.org/attending/attending%5Esvisa-letters" - Visa Letters 
 Sponsorship 
 href="#" - Tracks | ECOOP 2025 
 href="https://2025.ecoop.org/track/ecoop-2025-technical-papers" - Technical Papers 
 href="https://2025.ecoop.org/track/ecoop-2025-artifact-evaluation" - Artifact Evaluation 
 href="https://2025.ecoop.org/track/ecoop-2025-colocated" - Colocated Events & Workshops 
 href="https://2025.ecoop.org/track/ecoop-2025-doctoral-symposium" - Doctoral Symposium 
 Co-hosted Conferences 
 href="https://2025.ecoop.org/home/gpce-2025" - GPCE 
 Workshops 
 href="https://2025.ecoop.org/home/debt-2025" - DEBT 
 href="https://2025.ecoop.org/home/FTfJP-2025" - FTfJP 
 href="https://2025.ecoop.org/home/ICOOOLPS-2025" - ICOOOLPS 
 href="https://2025.ecoop.org/home/plf-plaid-2025" - PLF+PLAID 
 href="https://2025.ecoop.org/home/plss-2025" - PLSS 
 href="https://2025.ecoop.org/home/vortex-2025" - VORTEX 
 Organization | ECOOP 2025 Committees 
 Organizing Committee 
 Track Committees 
 href="https://2025.ecoop.org/committee/ecoop-2025-technical-papers-programme-committee" - Technical Papers 
 href="https://2025.ecoop.org/committee/ecoop-2025-artifact-evaluation-artifact-evaluation-committee" - Artifact Evaluation 
 href="https://2025.ecoop.org/committee/ecoop-2025-doctoral-symposium-doctoral-symposium-committee" - Doctoral Symposium 
 Contributors 
 href="https://2025.ecoop.org/people-index" - People Index 
 Co-hosted Conferences 
 GPCE | Organizing Committee 
 Program Committee 
 Steering Committee 
 Workshops 
 DEBT | Organizing Committee 
 Program Committee 
 Steering Committee 
 FTfJP | Program Committee 
 Steering Committee 
 ICOOOLPS | Program Committee 
 PLF+PLAID | Organizing Committee 
 Program Committee 
 PLSS | href="https://2025.ecoop.org/committee/plss-2025-papers-organizers" - Organizers 
 Program Committee 
 VORTEX | Organizing Committee 
 Program Committee (to be finalized) 
 href="https://2025.ecoop.org/search//all" - Search 
 Series | href="https://2025.ecoop.org/series/ecoop" - Series 
 href="https://2026.ecoop.org" - ECOOP 2026 
 ECOOP 2025 
 href="https://2024.ecoop.org" - ECOOP 2024 
 href="https://2023.ecoop.org" - ECOOP 2023 
 href="https://2022.ecoop.org" - ECOOP 2022 
 href="https://2021.ecoop.org" - ECOOP 2021 
 href="https://2020.ecoop.org" - ECOOP 2020 
 href="https://2019.ecoop.org" - ECOOP 2019 
 href="https://2018.ecoop.org" - ECOOP 2018 
 href="https://2017.ecoop.org" - ECOOP 2017 
 href="https://2016.ecoop.org" - ECOOP 2016 
 href="https://2015.ecoop.org" - ECOOP 2015 
 href="http://2014.ecoop.org" - 2014: Uppsala 
 href="http://2013.ecoop.org" - 2013: Montpellier 
 href="http://ecoop12.cs.purdue.edu" - 2012: Beijing 
 href="http://scc-sentinel.lancs.ac.uk/ecoop11/" - 2011: Lancaster 
 href="http://ecoop2010.uni-mb.si" - 2010: Maribor 
 href="http://ecoop09.disi.unige.it" - 2009: Genova 
 href="https://ecoop08.cs.ucy.ac.cy" - 2008: Cyprus 
 href="http://ecoop07.swt.cs.tu-berlin.de" - 2007: Berlin 
 href="http://www.emn.fr/z-info/ecoop2006/" - 2006: Nice 
 href="http://2005.ecoop.org/" - 2005: Glasgow 
 href="https://conf.researchr.org/signin/ecoop-2025/https%3A%5Es%5Es2025.ecoop.org%5Es" - Sign in 
 href="https://2025.ecoop.org/signup" - Sign up 
 Photo byDiego Delso 
 ECOOP 2025 
 Western Norway University of Applied Sciences 
 Bergen, Norway 
 30.6.-4.7.2025 
 Photo byViolet Ka I Pun 
 View of Bergen from Fløyen 
 Conference Venue 
 HVL Campus Bergen - Building K2 
 Photo by@agentj 
 Bryggen - World Cultural Heritage 
 Photo byPetr Šmerkl, Wikipedia 
 Håkonshallen 
 Photo byBjørn Christian Tørrissen 
 Inside Håkonshallen 
 Photo bySvein-Magne Tunli 
 Fantoft Stave Church 
 Photo bySvein-Magne Tunli 
 Bergen at night 
 ECOOP 2025 
 ECOOP is Europe’s longest-standing annual Programming Languages conference, bringing together researchers, practitioners, and students to share their ideas and experiences in all topics related to programming languages, software development, systems and applications. ECOOP welcomes high quality research papers relating to these fields in a broad sense. 
 ECOOP is committed to affordable open access publishing. Recent year’s publications have been published by Dagstuhl’s LIPIcs series under a Creative Commons CC-BY license where the authors retain their copyright. ECOOP articles have been published without open access publishing fee and can be accessed via a DOI. LIPIcs is indexed in DBLP, Google Scholar, Scopus and others. 
 In 2025, ECOOP will be hosted by thehref="https://selabhvl.github.io" - Software Engineering research group
at theHøgskulen på Vestlandet (Western Norway University of Applied Sciences)in Bergen, Norway. 
 This year, ECOOP is arranged together with other events: 
  
 Event 
 ACM SIGPLAN International Conference on 
 href="home/gpce-2025" - Generative Programming: Concepts & Experiences (GPCE) 
 href="home/debt-2025" - DEBT 
 href="track/ecoop-2025-doctoral-symposium" - ECOOP Doctoral Symposium 
 href="home/FTfJP-2025" - FTfJP 
 href="home/ICOOOLPS-2025" - ICOOOLPS 
 href="home/plf-plaid-2025" - PLF+PLAID 
 href="home/vortex-2025" - VORTEX 
 href="home/plss-2025" - Workshop on Programming Language Standardization and Specification (PLSS) 
 ECOOP 2025 Tracks 
 href="https://2025.ecoop.org/track/ecoop-2025-technical-papers" - Technical Papers
|href="https://2025.ecoop.org/track/ecoop-2025-artifact-evaluation" - Artifact Evaluation
|href="https://2025.ecoop.org/track/ecoop-2025-colocated" - Colocated Events & Workshops
|href="https://2025.ecoop.org/track/ecoop-2025-doctoral-symposium" - Doctoral Symposium
 
 href="javascript:var btn=$('#tracks-in-navbar:not(.open)>a'); if(btn){ if(!btn.is(':visible')){$('.navbar-toggle').click();} } btn.click(); $('html, body').animate({scrollTop: $(btn).offset().top}, 200); void(0);" - Show all tracks
href="https://2025.ecoop.org/dates" - Important Dates
up till Mon 28 Apr 2025 
  
 Wed 9 Apr 2025updated 
 GPCEPaper Submission (Extended) 
 Tue 8 - Thu 10 Apr 2025 
 Technical PapersRound 2 Author response deadline 
 Tue 15 Apr 2025 
 FTfJPSubmission Deadline 
 Sun 20 Apr 2025 
 PLF+PLAIDSubmission deadline 
 Fri 25 Apr 2025updated 
 DEBTSubmission Deadline 
 Fri 25 Apr 2025new 
 VORTEXAbstract submission deadline 
 Fri 25 Apr 2025 
 Technical PapersRound 2 Notification 
 Mon 28 Apr 2025 
 Artifact EvaluationArtifact submission deadline (firm) 
 All important dates 
 Supporters 
  
 xSat 5 Apr 10:25 
 href="https://2025.ecoop.org" - ECOOP 2025
href="https://2025.ecoop.org/contact" - contact form
usinghref="https://conf.researchr.org" - conf.researchr.org
(href="http://yellowgrass.org/roadmap/conf.researchr.org" - v1.69.0
) 
 href="https://2025.ecoop.org/support" - Support page
 
 Tracks 
 href="https://2025.ecoop.org/track/ecoop-2025-technical-papers" - Technical Papers
 
 href="https://2025.ecoop.org/track/ecoop-2025-artifact-evaluation" - Artifact Evaluation
 
 href="https://2025.ecoop.org/track/ecoop-2025-colocated" - Colocated Events & Workshops
 
 href="https://2025.ecoop.org/track/ecoop-2025-doctoral-symposium" - Doctoral Symposium
Co-hosted Conferences 
 href="https://2025.ecoop.org/home/gpce-2025" - GPCE 2025
 
 Workshops 
 href="https://2025.ecoop.org/home/debt-2025" - DEBT 2025
 
 href="https://2025.ecoop.org/home/FTfJP-2025" - FTfJP 2025
 
 href="https://2025.ecoop.org/home/ICOOOLPS-2025" - ICOOOLPS 2025
 
 href="https://2025.ecoop.org/home/plf-plaid-2025" - PLF+PLAID 2025
 
 href="https://2025.ecoop.org/home/plss-2025" - PLSS 2025
 
 href="https://2025.ecoop.org/home/vortex-2025" - VORTEX 2025
Attending 
 href="https://2025.ecoop.org/venue/ecoop-2025-venue" - Venue: Western Norway University of Applied Sciences
 
 href="https://2025.ecoop.org/venue/ecoop-2025-haakonshallen" - Reception: Håkonshallen
 
 href="https://2025.ecoop.org/attending/travel" - Getting There (And Away)
 
 href="https://2025.ecoop.org/attending/weather" - Weather
 
 href="https://2025.ecoop.org/attending/accommodation" - Accommodation
 
 href="https://2025.ecoop.org/attending/attending%5Esvisa-letters" - Visa Letters
href="https://2025.ecoop.org/signup" - Sign Up

3. Website of ECOOP_3: https://2025.ecoop.org/
Website information of ECOOP_3:

href="https://2025.ecoop.org" - ECOOP 2025
Mon 30 June - Fri 4 July 2025href="https://2025.ecoop.org/venue/ecoop-2025-venue" - Bergen, Norway
Toggle navigation 
 Attending | href="https://2025.ecoop.org/venue/ecoop-2025-venue" - Venue: Western Norway University of Applied Sciences 
 href="https://2025.ecoop.org/venue/ecoop-2025-haakonshallen" - Reception: Håkonshallen 
 href="https://2025.ecoop.org/attending/travel" - Getting There (And Away) 
 href="https://2025.ecoop.org/attending/weather" - Weather 
 href="https://2025.ecoop.org/attending/accommodation" - Accommodation 
 href="https://2025.ecoop.org/attending/attending%5Esvisa-letters" - Visa Letters 
 Sponsorship 
 href="#" - Tracks | ECOOP 2025 
 href="https://2025.ecoop.org/track/ecoop-2025-technical-papers" - Technical Papers 
 href="https://2025.ecoop.org/track/ecoop-2025-artifact-evaluation" - Artifact Evaluation 
 href="https://2025.ecoop.org/track/ecoop-2025-colocated" - Colocated Events & Workshops 
 href="https://2025.ecoop.org/track/ecoop-2025-doctoral-symposium" - Doctoral Symposium 
 Co-hosted Conferences 
 href="https://2025.ecoop.org/home/gpce-2025" - GPCE 
 Workshops 
 href="https://2025.ecoop.org/home/debt-2025" - DEBT 
 href="https://2025.ecoop.org/home/FTfJP-2025" - FTfJP 
 href="https://2025.ecoop.org/home/ICOOOLPS-2025" - ICOOOLPS 
 href="https://2025.ecoop.org/home/plf-plaid-2025" - PLF+PLAID 
 href="https://2025.ecoop.org/home/plss-2025" - PLSS 
 href="https://2025.ecoop.org/home/vortex-2025" - VORTEX 
 Organization | ECOOP 2025 Committees 
 Organizing Committee 
 Track Committees 
 href="https://2025.ecoop.org/committee/ecoop-2025-technical-papers-programme-committee" - Technical Papers 
 href="https://2025.ecoop.org/committee/ecoop-2025-artifact-evaluation-artifact-evaluation-committee" - Artifact Evaluation 
 href="https://2025.ecoop.org/committee/ecoop-2025-doctoral-symposium-doctoral-symposium-committee" - Doctoral Symposium 
 Contributors 
 href="https://2025.ecoop.org/people-index" - People Index 
 Co-hosted Conferences 
 GPCE | Organizing Committee 
 Program Committee 
 Steering Committee 
 Workshops 
 DEBT | Organizing Committee 
 Program Committee 
 Steering Committee 
 FTfJP | Program Committee 
 Steering Committee 
 ICOOOLPS | Program Committee 
 PLF+PLAID | Organizing Committee 
 Program Committee 
 PLSS | href="https://2025.ecoop.org/committee/plss-2025-papers-organizers" - Organizers 
 Program Committee 
 VORTEX | Organizing Committee 
 Program Committee (to be finalized) 
 href="https://2025.ecoop.org/search//all" - Search 
 Series | href="https://2025.ecoop.org/series/ecoop" - Series 
 href="https://2026.ecoop.org" - ECOOP 2026 
 ECOOP 2025 
 href="https://2024.ecoop.org" - ECOOP 2024 
 href="https://2023.ecoop.org" - ECOOP 2023 
 href="https://2022.ecoop.org" - ECOOP 2022 
 href="https://2021.ecoop.org" - ECOOP 2021 
 href="https://2020.ecoop.org" - ECOOP 2020 
 href="https://2019.ecoop.org" - ECOOP 2019 
 href="https://2018.ecoop.org" - ECOOP 2018 
 href="https://2017.ecoop.org" - ECOOP 2017 
 href="https://2016.ecoop.org" - ECOOP 2016 
 href="https://2015.ecoop.org" - ECOOP 2015 
 href="http://2014.ecoop.org" - 2014: Uppsala 
 href="http://2013.ecoop.org" - 2013: Montpellier 
 href="http://ecoop12.cs.purdue.edu" - 2012: Beijing 
 href="http://scc-sentinel.lancs.ac.uk/ecoop11/" - 2011: Lancaster 
 href="http://ecoop2010.uni-mb.si" - 2010: Maribor 
 href="http://ecoop09.disi.unige.it" - 2009: Genova 
 href="https://ecoop08.cs.ucy.ac.cy" - 2008: Cyprus 
 href="http://ecoop07.swt.cs.tu-berlin.de" - 2007: Berlin 
 href="http://www.emn.fr/z-info/ecoop2006/" - 2006: Nice 
 href="http://2005.ecoop.org/" - 2005: Glasgow 
 href="https://conf.researchr.org/signin/ecoop-2025/https%3A%5Es%5Es2025.ecoop.org%5Es" - Sign in 
 href="https://2025.ecoop.org/signup" - Sign up 
 Photo byDiego Delso 
 ECOOP 2025 
 Western Norway University of Applied Sciences 
 Bergen, Norway 
 30.6.-4.7.2025 
 Photo byViolet Ka I Pun 
 View of Bergen from Fløyen 
 Conference Venue 
 HVL Campus Bergen - Building K2 
 Photo by@agentj 
 Bryggen - World Cultural Heritage 
 Photo byPetr Šmerkl, Wikipedia 
 Håkonshallen 
 Photo byBjørn Christian Tørrissen 
 Inside Håkonshallen 
 Photo bySvein-Magne Tunli 
 Fantoft Stave Church 
 Photo bySvein-Magne Tunli 
 Bergen at night 
 ECOOP 2025 
 ECOOP is Europe’s longest-standing annual Programming Languages conference, bringing together researchers, practitioners, and students to share their ideas and experiences in all topics related to programming languages, software development, systems and applications. ECOOP welcomes high quality research papers relating to these fields in a broad sense. 
 ECOOP is committed to affordable open access publishing. Recent year’s publications have been published by Dagstuhl’s LIPIcs series under a Creative Commons CC-BY license where the authors retain their copyright. ECOOP articles have been published without open access publishing fee and can be accessed via a DOI. LIPIcs is indexed in DBLP, Google Scholar, Scopus and others. 
 In 2025, ECOOP will be hosted by thehref="https://selabhvl.github.io" - Software Engineering research group
at theHøgskulen på Vestlandet (Western Norway University of Applied Sciences)in Bergen, Norway. 
 This year, ECOOP is arranged together with other events: 
  
 Event 
 ACM SIGPLAN International Conference on 
 href="home/gpce-2025" - Generative Programming: Concepts & Experiences (GPCE) 
 href="home/debt-2025" - DEBT 
 href="track/ecoop-2025-doctoral-symposium" - ECOOP Doctoral Symposium 
 href="home/FTfJP-2025" - FTfJP 
 href="home/ICOOOLPS-2025" - ICOOOLPS 
 href="home/plf-plaid-2025" - PLF+PLAID 
 href="home/vortex-2025" - VORTEX 
 href="home/plss-2025" - Workshop on Programming Language Standardization and Specification (PLSS) 
 ECOOP 2025 Tracks 
 href="https://2025.ecoop.org/track/ecoop-2025-technical-papers" - Technical Papers
|href="https://2025.ecoop.org/track/ecoop-2025-artifact-evaluation" - Artifact Evaluation
|href="https://2025.ecoop.org/track/ecoop-2025-colocated" - Colocated Events & Workshops
|href="https://2025.ecoop.org/track/ecoop-2025-doctoral-symposium" - Doctoral Symposium
 
 href="javascript:var btn=$('#tracks-in-navbar:not(.open)>a'); if(btn){ if(!btn.is(':visible')){$('.navbar-toggle').click();} } btn.click(); $('html, body').animate({scrollTop: $(btn).offset().top}, 200); void(0);" - Show all tracks
href="https://2025.ecoop.org/dates" - Important Dates
up till Mon 28 Apr 2025 
  
 Wed 9 Apr 2025updated 
 GPCEPaper Submission (Extended) 
 Tue 8 - Thu 10 Apr 2025 
 Technical PapersRound 2 Author response deadline 
 Tue 15 Apr 2025 
 FTfJPSubmission Deadline 
 Sun 20 Apr 2025 
 PLF+PLAIDSubmission deadline 
 Fri 25 Apr 2025updated 
 DEBTSubmission Deadline 
 Fri 25 Apr 2025new 
 VORTEXAbstract submission deadline 
 Fri 25 Apr 2025 
 Technical PapersRound 2 Notification 
 Mon 28 Apr 2025 
 Artifact EvaluationArtifact submission deadline (firm) 
 All important dates 
 Supporters 
  
 xSat 5 Apr 10:25 
 href="https://2025.ecoop.org" - ECOOP 2025
href="https://2025.ecoop.org/contact" - contact form
usinghref="https://conf.researchr.org" - conf.researchr.org
(href="http://yellowgrass.org/roadmap/conf.researchr.org" - v1.69.0
) 
 href="https://2025.ecoop.org/support" - Support page
 
 Tracks 
 href="https://2025.ecoop.org/track/ecoop-2025-technical-papers" - Technical Papers
 
 href="https://2025.ecoop.org/track/ecoop-2025-artifact-evaluation" - Artifact Evaluation
 
 href="https://2025.ecoop.org/track/ecoop-2025-colocated" - Colocated Events & Workshops
 
 href="https://2025.ecoop.org/track/ecoop-2025-doctoral-symposium" - Doctoral Symposium
Co-hosted Conferences 
 href="https://2025.ecoop.org/home/gpce-2025" - GPCE 2025
 
 Workshops 
 href="https://2025.ecoop.org/home/debt-2025" - DEBT 2025
 
 href="https://2025.ecoop.org/home/FTfJP-2025" - FTfJP 2025
 
 href="https://2025.ecoop.org/home/ICOOOLPS-2025" - ICOOOLPS 2025
 
 href="https://2025.ecoop.org/home/plf-plaid-2025" - PLF+PLAID 2025
 
 href="https://2025.ecoop.org/home/plss-2025" - PLSS 2025
 
 href="https://2025.ecoop.org/home/vortex-2025" - VORTEX 2025
Attending 
 href="https://2025.ecoop.org/venue/ecoop-2025-venue" - Venue: Western Norway University of Applied Sciences
 
 href="https://2025.ecoop.org/venue/ecoop-2025-haakonshallen" - Reception: Håkonshallen
 
 href="https://2025.ecoop.org/attending/travel" - Getting There (And Away)
 
 href="https://2025.ecoop.org/attending/weather" - Weather
 
 href="https://2025.ecoop.org/attending/accommodation" - Accommodation
 
 href="https://2025.ecoop.org/attending/attending%5Esvisa-letters" - Visa Letters
href="https://2025.ecoop.org/signup" - Sign Up

4. Website of ECOOP_3: https://drops.dagstuhl.de/entities/volume/LIPIcs-volume-313
Website information of ECOOP_3:

DROPS 
 Series | LIPIcs – Leibniz International Proceedings in Informatics 
 OASIcs – Open Access Series in Informatics 
 Dagstuhl Follow-Ups 
 Schloss Dagstuhl Jahresbericht 
 Discontinued Series 
 Journals | DARTS – Dagstuhl Artifacts Series 
 Dagstuhl Reports 
 Dagstuhl Manifestos 
 LITES – Leibniz Transactions on Embedded Systems 
 TGDK – Transactions on Graph Data and Knowledge 
 Conferences | AFT 
 AIB 
 AofA 
 APPROX 
 ATMOS 
 CALCO 
 CCC 
 CONCUR 
 COSIT 
 CP 
 CPM 
 CSL 
 DISC 
 DITAM 
 DNA 
 href="https://drops.dagstuhl.de/entities/conference/ECOOP" - ECOOP 
 ECRTS 
 ESA 
 FAB 
 FMBC 
 FORC 
 FSCD 
 FSTTCS 
 FUN 
 GD 
 GIScience 
 ICALP 
 ICDT 
 ICPEC 
 IPEC 
 iPMVM 
 ISAAC 
 ITC 
 ITCS 
 ITP 
 LDK 
 MFCS 
 Microservices 
 NG-RES 
 OPODIS 
 PARMA 
 RANDOM 
 SAND 
 SAT 
 SEA 
 SLATE 
 SNAPL 
 SoCG 
 STACS 
 SWAT 
 TIME 
 Tokenomics 
 TQC 
 TYPES 
 WABI 
 WCET 
 Artifacts | Supplementary Materials (Software, Datasets, ...) 
 dblp Artifacts 
 DARTS (Evaluated Artifacts) 
 Metadata Export | Metadata Export 
 OAI Interface 
 VolumeExport XML 
 Export ACM-XML 
 Export DOAJ-XML 
 Export Schema.org 
 Export HTML 
 LIPIcs, Volume 313 
 38th European Conference on Object-Oriented Programming (ECOOP 2024) 
 Part of: | Series: | Leibniz International Proceedings in Informatics (LIPIcs) | Part of: | Conference: | href="https://drops.dagstuhl.de/entities/conference/ECOOP" - European Conference on Object-Oriented Programming (ECOOP) 
 Event 
 href="https://2024.ecoop.org/" - ECOOP 2024, September 16-20, 2024, Vienna, Austria
Editors 
 Jonathan Aldrichhref="https://drops.dagstuhl.de/search/documents?author=Aldrich, Jonathan" - 
Carnegie Mellon University, Pittsburgh, PA, USA 
 Guido Salvaneschihref="https://drops.dagstuhl.de/search/documents?author=Salvaneschi, Guido" - 
University of St. Gallen, Switzerland 
 Publication Details 
 published at: 2024-09-12 
 Publisher: Schloss Dagstuhl – Leibniz-Zentrum für Informatik 
 ISBN: 978-3-95977-341-6 
 DBLP: | href="https://dblp.org/db/conf/ecoop/ecoop2024" - db/conf/ecoop/ecoop2024 
  
 Access Numbers 
 Detailed Access Statistics available here 
 Total Document Accesses (updated on a weekly basis): | 0 
 PDF Downloads 
 0 
 Metadata Views 
 DocumentsNo documents found matching your filter selection. 
 Document 
 Complete Volume 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024" - DOI: 10.4230/LIPIcs.ECOOP.2024
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024/LIPIcs.ECOOP.2024.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024" - LIPIcs, Volume 313, ECOOP 2024, Complete Volume
Authors:Jonathan Aldrich and Guido Salvaneschi 
 AbstractLIPIcs, Volume 313, ECOOP 2024, Complete Volume 
 Cite as38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 1-1324, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @Proceedings{aldrich_et_al:LIPIcs.ECOOP.2024 title = {{LIPIcs, Volume 313, ECOOP 2024, Complete Volume}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {1--1324}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024}, URN = {urn:nbn:de:0030-drops-208481}, doi = {10.4230/LIPIcs.ECOOP.2024}, annote = {Keywords: LIPIcs, Volume 313, ECOOP 2024, Complete Volume} }@Proceedings{aldrich_et_al:LIPIcs.ECOOP.2024 title = {{LIPIcs, Volume 313, ECOOP 2024, Complete Volume}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {1--1324}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024}, URN = {urn:nbn:de:0030-drops-208481}, doi = {10.4230/LIPIcs.ECOOP.2024}, annote = {Keywords: LIPIcs, Volume 313, ECOOP 2024, Complete Volume} }Document 
 Front Matter 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.0" - DOI: 10.4230/LIPIcs.ECOOP.2024.0
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.0/LIPIcs.ECOOP.2024.0.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.0" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.0" - Front Matter, Table of Contents, Preface, Conference Organization
Authors:Jonathan Aldrich and Guido Salvaneschi 
 AbstractFront Matter, Table of Contents, Preface, Conference Organization 
 Cite as38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 0:i-0:xx, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{aldrich_et_al:LIPIcs.ECOOP.2024.0 author = {Aldrich, Jonathan and Salvaneschi, Guido}, title = {{Front Matter, Table of Contents, Preface, Conference Organization}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {0:i--0:xx}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.0}, URN = {urn:nbn:de:0030-drops-208495}, doi = {10.4230/LIPIcs.ECOOP.2024.0}, annote = {Keywords: Front Matter, Table of Contents, Preface, Conference Organization} }@InProceedings{aldrich_et_al:LIPIcs.ECOOP.2024.0 author = {Aldrich, Jonathan and Salvaneschi, Guido}, title = {{Front Matter, Table of Contents, Preface, Conference Organization}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {0:i--0:xx}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.0}, URN = {urn:nbn:de:0030-drops-208495}, doi = {10.4230/LIPIcs.ECOOP.2024.0}, annote = {Keywords: Front Matter, Table of Contents, Preface, Conference Organization} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.1" - DOI: 10.4230/LIPIcs.ECOOP.2024.1
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.1/LIPIcs.ECOOP.2024.1.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.1" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.1" - A Sound Type System for Secure Currency Flow
Authors:Luca Aceto, Daniele Gorla, and Stian Lybech 
 AbstractIn this paper we focus on TinySol, a minimal calculus for Solidity smart contracts, introduced by Bartoletti et al. We start by rephrasing its syntax (to emphasise its object-oriented flavour) and give a new big-step operational semantics. We then use it to define two security properties, namely call integrity and noninterference. These two properties have some similarities in their definition, in that they both require that some part of a program is not influenced by the other part. However, we show that the two properties are actually incomparable. Nevertheless, we provide a type system for noninterference and show that well-typed programs satisfy call integrity as well; hence, programs that are accepted by our type system satisfy both properties. We finally discuss the practical usability of the type system and its limitations by means of some simple examples. 
 Cite asLuca Aceto, Daniele Gorla, and Stian Lybech. A Sound Type System for Secure Currency Flow. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 1:1-1:27, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{aceto_et_al:LIPIcs.ECOOP.2024.1 author = {Aceto, Luca and Gorla, Daniele and Lybech, Stian}, title = {{A Sound Type System for Secure Currency Flow}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {1:1--1:27}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.1}, URN = {urn:nbn:de:0030-drops-208508}, doi = {10.4230/LIPIcs.ECOOP.2024.1}, annote = {Keywords: smart contracts, call integrity, noninterference, type system} }@InProceedings{aceto_et_al:LIPIcs.ECOOP.2024.1 author = {Aceto, Luca and Gorla, Daniele and Lybech, Stian}, title = {{A Sound Type System for Secure Currency Flow}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {1:1--1:27}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.1}, URN = {urn:nbn:de:0030-drops-208508}, doi = {10.4230/LIPIcs.ECOOP.2024.1}, annote = {Keywords: smart contracts, call integrity, noninterference, type system} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.2" - DOI: 10.4230/LIPIcs.ECOOP.2024.2
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.2/LIPIcs.ECOOP.2024.2.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.2" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.2" - Runtime Instrumentation for Reactive Components
Authors:Luca Aceto, Duncan Paul Attard, Adrian Francalanza, and Anna Ingólfsdóttir 
 AbstractReactive software calls for instrumentation methods that uphold the reactive attributes of systems. Runtime verification imposes another demand on the instrumentation, namely that the trace event sequences it reports to monitors are sound - that is, they reflect actual executions of the system under scrutiny. This paper presents RIARC, a novel decentralised instrumentation algorithm for outline monitors meeting these two demands. Asynchrony in reactive software complicates the instrumentation due to potential trace event loss or reordering. RIARC overcomes these challenges using a next-hop IP routing approach to rearrange and report events soundly to monitors. RIARC is validated in two ways. We subject its corresponding implementation to rigorous systematic testing to confirm its correctness. In addition, we assess this implementation via extensive empirical experiments, subjecting it to large realistic workloads to ascertain its reactiveness. Our results show that RIARC optimises its memory and scheduler usage to maintain latency feasible for soft real-time applications. We also compare RIARC to inline and centralised monitoring, revealing that it induces comparable latency to inline monitoring in moderate concurrency settings where software performs long-running, computationally-intensive tasks, such as in Big Data stream processing. 
 Cite asLuca Aceto, Duncan Paul Attard, Adrian Francalanza, and Anna Ingólfsdóttir. Runtime Instrumentation for Reactive Components. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 2:1-2:33, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{aceto_et_al:LIPIcs.ECOOP.2024.2 author = {Aceto, Luca and Attard, Duncan Paul and Francalanza, Adrian and Ing\'{o}lfsd\'{o}ttir, Anna}, title = {{Runtime Instrumentation for Reactive Components}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {2:1--2:33}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.2}, URN = {urn:nbn:de:0030-drops-208511}, doi = {10.4230/LIPIcs.ECOOP.2024.2}, annote = {Keywords: Runtime instrumentation, decentralised monitoring, reactive systems} }@InProceedings{aceto_et_al:LIPIcs.ECOOP.2024.2 author = {Aceto, Luca and Attard, Duncan Paul and Francalanza, Adrian and Ing\'{o}lfsd\'{o}ttir, Anna}, title = {{Runtime Instrumentation for Reactive Components}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {2:1--2:33}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.2}, URN = {urn:nbn:de:0030-drops-208511}, doi = {10.4230/LIPIcs.ECOOP.2024.2}, annote = {Keywords: Runtime instrumentation, decentralised monitoring, reactive systems} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.3" - DOI: 10.4230/LIPIcs.ECOOP.2024.3
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.3/LIPIcs.ECOOP.2024.3.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.3" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.3" - A Dynamic Logic for Symbolic Execution for the Smart Contract Programming Language Michelson
Authors:Barnabas Arvay, Thi Thu Ha Doan, and Peter Thiemann 
 AbstractVerification of smart contracts is an important topic in the context of blockchain technology. We study an approach to verification that is based on symbolic execution. As a formal basis for symbolic execution, we design a dynamic logic for Michelson, the smart contract language of the Tezos blockchain, and prove its soundness in the proof assistant Agda. Towards the soundness proof we formalize the concrete semantics as well as its symbolic counterpart in a unified setting. The logic encompasses single contract runs as well as inter-contract runs chained in a single transaction. 
 Cite asBarnabas Arvay, Thi Thu Ha Doan, and Peter Thiemann. A Dynamic Logic for Symbolic Execution for the Smart Contract Programming Language Michelson. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 3:1-3:26, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{arvay_et_al:LIPIcs.ECOOP.2024.3 author = {Arvay, Barnabas and Doan, Thi Thu Ha and Thiemann, Peter}, title = {{A Dynamic Logic for Symbolic Execution for the Smart Contract Programming Language Michelson}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {3:1--3:26}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.3}, URN = {urn:nbn:de:0030-drops-208529}, doi = {10.4230/LIPIcs.ECOOP.2024.3}, annote = {Keywords: Smart Contract, Blockchain, Formal Verification, Symbolic Execution} }@InProceedings{arvay_et_al:LIPIcs.ECOOP.2024.3 author = {Arvay, Barnabas and Doan, Thi Thu Ha and Thiemann, Peter}, title = {{A Dynamic Logic for Symbolic Execution for the Smart Contract Programming Language Michelson}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {3:1--3:26}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.3}, URN = {urn:nbn:de:0030-drops-208529}, doi = {10.4230/LIPIcs.ECOOP.2024.3}, annote = {Keywords: Smart Contract, Blockchain, Formal Verification, Symbolic Execution} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.4" - DOI: 10.4230/LIPIcs.ECOOP.2024.4
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.4/LIPIcs.ECOOP.2024.4.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.4" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.4" - Dynamically Generating Callback Summaries for Enhancing Static Analysis
Authors:Steven Arzt, Marc Miltenberger, and Julius Näumann 
 AbstractInterprocedural static analyses require a complete and precise callgraph. Since third-party libraries are responsible for large portions of the code of an app, a substantial fraction of the effort in callgraph generation is therefore spent on the library code for each app. For analyses that are oblivious to the inner workings of a library and only require the user code to be processed, the library can be replaced with a summary that allows to reconstruct the callbacks from library code back to user code. To improve performance, we propose the automatic generation and use of precise pre-computed callgraph summaries for commonly used libraries. Reflective method calls within libraries and callback-driven APIs pose further challenges for generating precise callgraphs using static analysis. Pre-computed summaries can also help analyses avoid these challenges. We present CGMiner, an approach for automatically generating callgraph models for library code. It dynamically observes sample apps that use one or more particular target libraries. As we show, CGMiner yields more than 94% of correct edges, whereas existing work only achieves around 33% correct edges. CGMiner avoids the high false positive rate of existing tools. We show that CGMiner integrated into FlowDroid uncovers 40% more data flows than our baseline without callback summaries. 
 Cite asSteven Arzt, Marc Miltenberger, and Julius Näumann. Dynamically Generating Callback Summaries for Enhancing Static Analysis. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 4:1-4:27, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{arzt_et_al:LIPIcs.ECOOP.2024.4 author = {Arzt, Steven and Miltenberger, Marc and N\"{a}umann, Julius}, title = {{Dynamically Generating Callback Summaries for Enhancing Static Analysis}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {4:1--4:27}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.4}, URN = {urn:nbn:de:0030-drops-208533}, doi = {10.4230/LIPIcs.ECOOP.2024.4}, annote = {Keywords: dynamic analysis, callback detection, java, android} }@InProceedings{arzt_et_al:LIPIcs.ECOOP.2024.4 author = {Arzt, Steven and Miltenberger, Marc and N\"{a}umann, Julius}, title = {{Dynamically Generating Callback Summaries for Enhancing Static Analysis}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {4:1--4:27}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.4}, URN = {urn:nbn:de:0030-drops-208533}, doi = {10.4230/LIPIcs.ECOOP.2024.4}, annote = {Keywords: dynamic analysis, callback detection, java, android} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.5" - DOI: 10.4230/LIPIcs.ECOOP.2024.5
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.5/LIPIcs.ECOOP.2024.5.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.5" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.5" - Behavioural Up/down Casting For Statically Typed Languages
Authors:Lorenzo Bacchiani, Mario Bravetti, Marco Giunti, João Mota, and António Ravara 
 AbstractWe provide support for polymorphism in static typestate analysis for object-oriented languages with upcasts and downcasts. Recent work has shown how typestate analysis can be embedded in the development of Java programs to obtain safer behaviour at runtime, e.g., absence of null pointer errors and protocol completion. In that approach, inheritance is supported at the price of limiting casts in source code, thus only allowing those at the beginning of the protocol, i.e., immediately after objects creation, or at the end, and in turn seriously affecting the applicability of the analysis. In this paper, we provide a solution to this open problem in typestate analysis by introducing a theory based on a richer data structure, named typestate tree, which supports upcast and downcast operations at any point of the protocol by leveraging union and intersection types. The soundness of the typestate tree-based approach has been mechanised in Coq. The theory can be applied to most object-oriented languages statically analysable through typestates, thus opening new scenarios for acceptance of programs exploiting inheritance and casting. To defend this thesis, we show an application of the theory, by embedding the typestate tree mechanism in a Java-like object-oriented language, and proving its soundness. 
 Cite asLorenzo Bacchiani, Mario Bravetti, Marco Giunti, João Mota, and António Ravara. Behavioural Up/down Casting For Statically Typed Languages. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 5:1-5:28, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{bacchiani_et_al:LIPIcs.ECOOP.2024.5 author = {Bacchiani, Lorenzo and Bravetti, Mario and Giunti, Marco and Mota, Jo\~{a}o and Ravara, Ant\'{o}nio}, title = {{Behavioural Up/down Casting For Statically Typed Languages}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {5:1--5:28}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.5}, URN = {urn:nbn:de:0030-drops-208543}, doi = {10.4230/LIPIcs.ECOOP.2024.5}, annote = {Keywords: Behavioural types, object-oriented programming, subtyping, cast, typestates} }@InProceedings{bacchiani_et_al:LIPIcs.ECOOP.2024.5 author = {Bacchiani, Lorenzo and Bravetti, Mario and Giunti, Marco and Mota, Jo\~{a}o and Ravara, Ant\'{o}nio}, title = {{Behavioural Up/down Casting For Statically Typed Languages}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {5:1--5:28}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.5}, URN = {urn:nbn:de:0030-drops-208543}, doi = {10.4230/LIPIcs.ECOOP.2024.5}, annote = {Keywords: Behavioural types, object-oriented programming, subtyping, cast, typestates} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.6" - DOI: 10.4230/LIPIcs.ECOOP.2024.6
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.6/LIPIcs.ECOOP.2024.6.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.6" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.6" - Cross Module Quickening - The Curious Case of C Extensions
Authors:Felix Berlakovich and Stefan Brunthaler 
 AbstractDynamic programming languages such as Python offer expressive power and programmer productivity at the expense of performance. Although the topic of optimizing Python has received considerable attention over the years, a key obstacle remains elusive: C extensions. Time and again, optimized run-time environments, such as JIT compilers and optimizing interpreters, fall short of optimizing across C extensions, as they cannot reason about the native code hiding underneath. To bridge this gap, we present an analysis of C extensions for Python. The analysis data indicates that C extensions come in different varieties. One such variety is to merely speed up a single thing, such as reading a file and processing it directly in C. Another variety offers broad access through an API, resulting in a domain-specific language realized by function calls. While the former variety of C extensions offer little optimization potential for optimizing run-times, we find that the latter variety does offer considerable optimization potential. This optimization potential rests on dynamic locality that C extensions cannot readily tap. We introduce a new, interpreter-based optimization leveraging this untapped optimization potential called Cross-Module Quickening. The key idea is that C extensions can use an optimization interface to register highly-optimized operations on C extension-specific datatypes. A quickening interpreter uses these information to continuously specialize programs with C extensions. To quantify the attainable performance potential of going beyond C extensions, we demonstrate a concrete instantiation of Cross-Module Quickening for the CPython interpreter and the popular NumPy C extension. We evaluate our implementation with the NPBench benchmark suite and report performance improvements by a factor of up to 2.84. 
 Cite asFelix Berlakovich and Stefan Brunthaler. Cross Module Quickening - The Curious Case of C Extensions. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 6:1-6:29, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{berlakovich_et_al:LIPIcs.ECOOP.2024.6 author = {Berlakovich, Felix and Brunthaler, Stefan}, title = {{Cross Module Quickening - The Curious Case of C Extensions}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {6:1--6:29}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.6}, URN = {urn:nbn:de:0030-drops-208557}, doi = {10.4230/LIPIcs.ECOOP.2024.6}, annote = {Keywords: interpreter, optimizations, C extensions, Python} }@InProceedings{berlakovich_et_al:LIPIcs.ECOOP.2024.6 author = {Berlakovich, Felix and Brunthaler, Stefan}, title = {{Cross Module Quickening - The Curious Case of C Extensions}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {6:1--6:29}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.6}, URN = {urn:nbn:de:0030-drops-208557}, doi = {10.4230/LIPIcs.ECOOP.2024.6}, annote = {Keywords: interpreter, optimizations, C extensions, Python} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.7" - DOI: 10.4230/LIPIcs.ECOOP.2024.7
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.7/LIPIcs.ECOOP.2024.7.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.7" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.7" - HOBBIT: Hashed OBject Based InTegrity
Authors:Matthias Bernad and Stefan Brunthaler 
 AbstractC vulnerabilities usually hold verbatim for C++ programs. The counterfeit-object-oriented programming attack demonstrated that this relation is asymmetric, i.e., it only applies to C++. The problem pinpointed by this COOP attack is that C++ does not validate the integrity of its objects. By injecting malicious objects with manipulated virtual function table pointers, attackers can hijack control-flow of programs. The software security community addressed the COOP-problem in the years following its discovery, but together with the emergence of transient-execution attacks, such as Spectre, researchers also shifted their attention. We present Hobbit, a software-only solution to prevent COOP attacks by validating object integrity for virtual function pointer tables. Hobbit does not require any hardware specific features, scales to multi-million lines of C++ source code, and our LLVM-based implementation offers a configurable performance impact between 121.63% and 2.80% on compute-intensive SPEC CPU C++ benchmarks. Hobbit’s security analysis indicates strong resistance to brute forcing attacks and demonstrates additional benefits of using execute-only memory. 
 Cite asMatthias Bernad and Stefan Brunthaler. HOBBIT: Hashed OBject Based InTegrity. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 7:1-7:25, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{bernad_et_al:LIPIcs.ECOOP.2024.7 author = {Bernad, Matthias and Brunthaler, Stefan}, title = {{HOBBIT: Hashed OBject Based InTegrity}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {7:1--7:25}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.7}, URN = {urn:nbn:de:0030-drops-208566}, doi = {10.4230/LIPIcs.ECOOP.2024.7}, annote = {Keywords: software security, code-reuse attacks, language-based security, counterfeit-object-oriented programming, object integrity, compiler security} }@InProceedings{bernad_et_al:LIPIcs.ECOOP.2024.7 author = {Bernad, Matthias and Brunthaler, Stefan}, title = {{HOBBIT: Hashed OBject Based InTegrity}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {7:1--7:25}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.7}, URN = {urn:nbn:de:0030-drops-208566}, doi = {10.4230/LIPIcs.ECOOP.2024.7}, annote = {Keywords: software security, code-reuse attacks, language-based security, counterfeit-object-oriented programming, object integrity, compiler security} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.8" - DOI: 10.4230/LIPIcs.ECOOP.2024.8
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.8/LIPIcs.ECOOP.2024.8.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.8" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.8" - Understanding Concurrency Bugs in Real-World Programs with Kotlin Coroutines
Authors:Bob Brockbernd, Nikita Koval, Arie van Deursen, and Burcu Kulahcioglu Ozkan 
 AbstractKotlin language has recently become prominent for developing both Android and server-side applications. These programs are typically designed to be fast and responsive, with asynchrony and concurrency at their core. To enable developers to write asynchronous and concurrent code safely and concisely, Kotlin provides built-in coroutines support. However, developers unfamiliar with the coroutines concept may write programs with subtle concurrency bugs and face unexpected program behaviors. Besides the traditional concurrency bug patterns, such as data races and deadlocks, these bugs may exhibit patterns related to the coroutine semantics. Understanding these coroutine-specific bug patterns in real-world Kotlin applications is essential in avoiding common mistakes and writing correct programs. In this paper, we present the first study of real-world concurrency bugs related to Kotlin coroutines. We examined 55 concurrency bug cases selected from 7 popular open-source repositories that use Kotlin coroutines, including IntelliJ IDEA, Firefox, and Ktor, and analyzed their bug characteristics and root causes. We identified common bug patterns related to asynchrony and Kotlin’s coroutine semantics, presenting them with their root causes, misconceptions that led to the bugs, and strategies for their automated detection. Overall, this study provides insight into programming with Kotlin coroutines concurrency and its pitfalls, aiming to shed light on common bug patterns and foster further research and development of concurrency analysis tools for Kotlin programs. 
 Cite asBob Brockbernd, Nikita Koval, Arie van Deursen, and Burcu Kulahcioglu Ozkan. Understanding Concurrency Bugs in Real-World Programs with Kotlin Coroutines. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 8:1-8:20, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{brockbernd_et_al:LIPIcs.ECOOP.2024.8 author = {Brockbernd, Bob and Koval, Nikita and van Deursen, Arie and Ozkan, Burcu Kulahcioglu}, title = {{Understanding Concurrency Bugs in Real-World Programs with Kotlin Coroutines}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {8:1--8:20}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.8}, URN = {urn:nbn:de:0030-drops-208579}, doi = {10.4230/LIPIcs.ECOOP.2024.8}, annote = {Keywords: Kotlin, coroutines, concurrency, asynchrony, software bugs} }@InProceedings{brockbernd_et_al:LIPIcs.ECOOP.2024.8 author = {Brockbernd, Bob and Koval, Nikita and van Deursen, Arie and Ozkan, Burcu Kulahcioglu}, title = {{Understanding Concurrency Bugs in Real-World Programs with Kotlin Coroutines}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {8:1--8:20}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.8}, URN = {urn:nbn:de:0030-drops-208579}, doi = {10.4230/LIPIcs.ECOOP.2024.8}, annote = {Keywords: Kotlin, coroutines, concurrency, asynchrony, software bugs} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.9" - DOI: 10.4230/LIPIcs.ECOOP.2024.9
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.9/LIPIcs.ECOOP.2024.9.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.9" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.9" - A Language-Based Version Control System for Python
Authors:Luís Carvalho and João Costa Seco 
 AbstractWe extend prior work on a language-based approach to versioned software development to support versioned programs with mutable state and evolving method interfaces. Unlike the traditional approach of mainstream version control systems, where a textual diff represents each evolution step, we treat versions as programming elements. Each evolution step, merge operation, and version relationship is represented explicitly in a multifaceted code representation. This provides static guarantees for safe code reuse from previous versions and forward and backwards compatibility between versions, allowing clients to use newly introduced code without needing to refactor their program manually. By lifting versioning to the language level, we pave the way for tools that interact with software repositories to have more insight into a system’s behavior evolution. We instantiate our work in the Python programming language and demonstrate its applicability regarding common evolution and refactoring patterns found in different versions of popular Python packages. 
 Cite asLuís Carvalho and João Costa Seco. A Language-Based Version Control System for Python. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 9:1-9:27, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{carvalho_et_al:LIPIcs.ECOOP.2024.9 author = {Carvalho, Lu{\'\i}s and Costa Seco, Jo\~{a}o}, title = {{A Language-Based Version Control System for Python}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {9:1--9:27}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.9}, URN = {urn:nbn:de:0030-drops-208586}, doi = {10.4230/LIPIcs.ECOOP.2024.9}, annote = {Keywords: Software evolution, type theory} }@InProceedings{carvalho_et_al:LIPIcs.ECOOP.2024.9 author = {Carvalho, Lu{\'\i}s and Costa Seco, Jo\~{a}o}, title = {{A Language-Based Version Control System for Python}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {9:1--9:27}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.9}, URN = {urn:nbn:de:0030-drops-208586}, doi = {10.4230/LIPIcs.ECOOP.2024.9}, annote = {Keywords: Software evolution, type theory} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.10" - DOI: 10.4230/LIPIcs.ECOOP.2024.10
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.10/LIPIcs.ECOOP.2024.10.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.10" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.10" - Indirection-Bounded Call Graph Analysis
Authors:Madhurima Chakraborty, Aakash Gnanakumar, Manu Sridharan, and Anders Møller 
 AbstractCall graphs play a crucial role in analyzing the structure and behavior of programs. For JavaScript and other dynamically typed programming languages, static call graph analysis relies on approximating the possible flow of functions and objects, and producing usable call graphs for large, real-world programs remains challenging. In this paper, we propose a simple but effective technique that addresses performance issues encountered in call graph generation. We observe via a dynamic analysis that typical JavaScript program code exhibits small levels of indirection of object pointers and higher-order functions. We demonstrate that a widely used analysis algorithm, wave propagation, closely follows the levels of indirections, so that call edges discovered early are more likely to be true positives. By bounding the number of indirections covered by this analysis, in many cases it can find most true-positive call edges in less time. We also show that indirection-bounded analysis can similarly be incorporated into the field-based call graph analysis algorithm ACG. We have experimentally evaluated the modified wave propagation algorithm on 25 large Node.js-based JavaScript programs. Indirection-bounded analysis on average yields close to a 2X speed-up with only 5% reduction in recall and almost identical precision relative to the baseline analysis, using dynamically generated call graphs for the recall and precision measurements. To demonstrate the robustness of the approach, we also evaluated the modified ACG algorithm on 10 web-based and 4 mobile-based medium sized benchmarks, with similar results. 
 Cite asMadhurima Chakraborty, Aakash Gnanakumar, Manu Sridharan, and Anders Møller. Indirection-Bounded Call Graph Analysis. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 10:1-10:22, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{chakraborty_et_al:LIPIcs.ECOOP.2024.10 author = {Chakraborty, Madhurima and Gnanakumar, Aakash and Sridharan, Manu and M{\o}ller, Anders}, title = {{Indirection-Bounded Call Graph Analysis}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {10:1--10:22}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.10}, URN = {urn:nbn:de:0030-drops-208599}, doi = {10.4230/LIPIcs.ECOOP.2024.10}, annote = {Keywords: JavaScript, call graphs, points-to analysis} }@InProceedings{chakraborty_et_al:LIPIcs.ECOOP.2024.10 author = {Chakraborty, Madhurima and Gnanakumar, Aakash and Sridharan, Manu and M{\o}ller, Anders}, title = {{Indirection-Bounded Call Graph Analysis}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {10:1--10:22}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.10}, URN = {urn:nbn:de:0030-drops-208599}, doi = {10.4230/LIPIcs.ECOOP.2024.10}, annote = {Keywords: JavaScript, call graphs, points-to analysis} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.11" - DOI: 10.4230/LIPIcs.ECOOP.2024.11
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.11/LIPIcs.ECOOP.2024.11.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.11" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.11" - Regrading Policies for Flexible Information Flow Control in Session-Typed Concurrency
Authors:Farzaneh Derakhshan, Stephanie Balzer, and Yue Yao 
 AbstractNoninterference guarantees that an attacker cannot infer secrets by interacting with a program. Information flow control (IFC) type systems assert noninterference by tracking the level of information learned (pc) and disallowing communication to entities of lesser or unrelated level than the pc. Control flow constructs such as loops are at odds with this pattern because they necessitate downgrading the pc upon recursion to be practical. In a concurrent setting, however, downgrading is not generally safe. This paper utilizes session types to track the flow of information and contributes an IFC type system for message-passing concurrent processes that allows downgrading the pc upon recursion. To make downgrading safe, the paper introduces regrading policies. Regrading policies are expressed in terms of integrity labels, which are also key to safe composition of entities with different regrading policies. The paper develops the type system and proves progress-sensitive noninterference for well-typed processes, ruling out timing attacks that exploit the relative order of messages. The type system has been implemented in a type checker, which supports security-polymorphic processes. 
 Cite asFarzaneh Derakhshan, Stephanie Balzer, and Yue Yao. Regrading Policies for Flexible Information Flow Control in Session-Typed Concurrency. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 11:1-11:29, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{derakhshan_et_al:LIPIcs.ECOOP.2024.11 author = {Derakhshan, Farzaneh and Balzer, Stephanie and Yao, Yue}, title = {{Regrading Policies for Flexible Information Flow Control in Session-Typed Concurrency}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {11:1--11:29}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.11}, URN = {urn:nbn:de:0030-drops-208602}, doi = {10.4230/LIPIcs.ECOOP.2024.11}, annote = {Keywords: Regrading policies, session types, progress-sensitive noninterference} }@InProceedings{derakhshan_et_al:LIPIcs.ECOOP.2024.11 author = {Derakhshan, Farzaneh and Balzer, Stephanie and Yao, Yue}, title = {{Regrading Policies for Flexible Information Flow Control in Session-Typed Concurrency}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {11:1--11:29}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.11}, URN = {urn:nbn:de:0030-drops-208602}, doi = {10.4230/LIPIcs.ECOOP.2024.11}, annote = {Keywords: Regrading policies, session types, progress-sensitive noninterference} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.12" - DOI: 10.4230/LIPIcs.ECOOP.2024.12
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.12/LIPIcs.ECOOP.2024.12.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.12" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.12" - Mutation-Based Lifted Repair of Software Product Lines
Authors:Aleksandar S. Dimovski 
 AbstractThis paper presents a novel lifted repair algorithm for program families (Software Product Lines - SPLs) based on code mutations. The inputs of our algorithm are an erroneous SPL and a specification given in the form of assertions. We use variability encoding to transform the given SPL into a single program, called family simulator, which is translated into a set of SMT formulas whose conjunction is satisfiable iff the simulator (i.e., the input SPL) violates an assertion. We use a predefined set of mutations applied to feature and program expressions of the given SPL. The algorithm repeatedly mutates the erroneous family simulator and checks if it becomes (bounded) correct. Since mutating an expression corresponds to mutating a formula in the set of SMT formulas encoding the family simulator, the search for a correct mutant is reduced to searching an unsatisfiable set of SMT formulas. To efficiently explore the huge state space of mutants, we call SAT and SMT solvers in an incremental way. The outputs of our algorithm are all minimal repairs in the form of minimal number of (feature and program) expression replacements such that the repaired SPL is (bounded) correct with respect to a given set of assertions. We have implemented our algorithm in a prototype tool and evaluated it on a set of #ifdef-based C programs (i.e., annotative SPLs). The experimental results show that our approach is able to successfully repair various interesting SPLs. 
 Cite asAleksandar S. Dimovski. Mutation-Based Lifted Repair of Software Product Lines. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 12:1-12:24, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{dimovski:LIPIcs.ECOOP.2024.12 author = {Dimovski, Aleksandar S.}, title = {{Mutation-Based Lifted Repair of Software Product Lines}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {12:1--12:24}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.12}, URN = {urn:nbn:de:0030-drops-208613}, doi = {10.4230/LIPIcs.ECOOP.2024.12}, annote = {Keywords: Program repair, Software Product Lines, Code mutations, Variability encoding} }@InProceedings{dimovski:LIPIcs.ECOOP.2024.12 author = {Dimovski, Aleksandar S.}, title = {{Mutation-Based Lifted Repair of Software Product Lines}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {12:1--12:24}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.12}, URN = {urn:nbn:de:0030-drops-208613}, doi = {10.4230/LIPIcs.ECOOP.2024.12}, annote = {Keywords: Program repair, Software Product Lines, Code mutations, Variability encoding} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.13" - DOI: 10.4230/LIPIcs.ECOOP.2024.13
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.13/LIPIcs.ECOOP.2024.13.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.13" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.13" - Pure Methods for roDOT
Authors:Vlastimil Dort, Yufeng Li, Ondřej Lhoták, and Pavel Parízek 
 AbstractObject-oriented programming languages typically allow mutation of objects, but pure methods are common too. There is great interest in recognizing which methods are pure, because it eases analysis of program behavior and allows modifying the program without changing its behavior. The roDOT calculus is a formal calculus extending DOT with reference mutability. In this paper, we explore purity conditions in roDOT and pose a SEF guarantee, by which the type system guarantees that methods of certain types are side-effect free. We use the idea from ReIm to detect pure methods by argument types. Applying this idea to roDOT required just a few changes to the type system, but necessitated re-working a significant part of the soundness proof. In addition, we state a transformation guarantee, which states that in a roDOT program, calls to SEF methods can be safely reordered without changing the outcome of the program. We proved type soundness of the updated roDOT calculus, using multiple layers of typing judgments. We proved the SEF guarantee by applying the Immutability guarantee, and the transformation guarantee by applying the SEF guarantee within a framework for reasoning about safe transformations of roDOT programs. All proofs are mechanized in Coq. 
 Cite asVlastimil Dort, Yufeng Li, Ondřej Lhoták, and Pavel Parízek. Pure Methods for roDOT. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 13:1-13:29, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{dort_et_al:LIPIcs.ECOOP.2024.13 author = {Dort, Vlastimil and Li, Yufeng and Lhot\'{a}k, Ond\v{r}ej and Par{\'\i}zek, Pavel}, title = {{Pure Methods for roDOT}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {13:1--13:29}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.13}, URN = {urn:nbn:de:0030-drops-208624}, doi = {10.4230/LIPIcs.ECOOP.2024.13}, annote = {Keywords: type systems, DOT calculus, pure methods} }@InProceedings{dort_et_al:LIPIcs.ECOOP.2024.13 author = {Dort, Vlastimil and Li, Yufeng and Lhot\'{a}k, Ond\v{r}ej and Par{\'\i}zek, Pavel}, title = {{Pure Methods for roDOT}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {13:1--13:29}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.13}, URN = {urn:nbn:de:0030-drops-208624}, doi = {10.4230/LIPIcs.ECOOP.2024.13}, annote = {Keywords: type systems, DOT calculus, pure methods} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.14" - DOI: 10.4230/LIPIcs.ECOOP.2024.14
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.14/LIPIcs.ECOOP.2024.14.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.14" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.14" - The Performance Effects of Virtual-Machine Instruction Pointer Updates
Authors:M. Anton Ertl and Bernd Paysan 
 AbstractHow much performance do VM instruction-pointer (IP) updates cost and how much benefit do we get from optimizing them away? Two decades ago it had little effect on the hardware of the day, but on recent hardware the dependence chain of IP updates can become the critical path on processors with out-of-order execution. In particular, this happens if the VM instructions are light-weight and the application programs are loop-dominated. The present work presents several ways of reducing or eliminating the dependence chains from IP updates, either by breaking the dependence chains with the loop optimization or by reducing the number of IP updates (the c and ci optimizations) or their latency (the b optimization). Some benchmarks see speedups from these optimizations by factors > 2 on most recent cores, while other benchmarks and older cores see more modest results, often in the speedup ranges 1.1-1.3. 
 Cite asM. Anton Ertl and Bernd Paysan. The Performance Effects of Virtual-Machine Instruction Pointer Updates. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 14:1-14:26, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{ertl_et_al:LIPIcs.ECOOP.2024.14 author = {Ertl, M. Anton and Paysan, Bernd}, title = {{The Performance Effects of Virtual-Machine Instruction Pointer Updates}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {14:1--14:26}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.14}, URN = {urn:nbn:de:0030-drops-208634}, doi = {10.4230/LIPIcs.ECOOP.2024.14}, annote = {Keywords: virtual machine, interpreter, out-of-order execution} }@InProceedings{ertl_et_al:LIPIcs.ECOOP.2024.14 author = {Ertl, M. Anton and Paysan, Bernd}, title = {{The Performance Effects of Virtual-Machine Instruction Pointer Updates}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {14:1--14:26}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.14}, URN = {urn:nbn:de:0030-drops-208634}, doi = {10.4230/LIPIcs.ECOOP.2024.14}, annote = {Keywords: virtual machine, interpreter, out-of-order execution} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.15" - DOI: 10.4230/LIPIcs.ECOOP.2024.15
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.15/LIPIcs.ECOOP.2024.15.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.15" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.15" - Rose: Composable Autodiff for the Interactive Web
Authors:Sam Estep, Wode Ni, Raven Rothkopf, and Joshua Sunshine 
 AbstractReverse-mode automatic differentiation (autodiff) has been popularized by deep learning, but its ability to compute gradients is also valuable for interactive use cases such as bidirectional computer-aided design, embedded physics simulations, visualizing causal inference, and more. Unfortunately, the web is ill-served by existing autodiff frameworks, which use autodiff strategies that perform poorly on dynamic scalar programs, and pull in heavy dependencies that would result in unacceptable webpage sizes. This work introduces Rose, a lightweight autodiff framework for the web using a new hybrid approach to reverse-mode autodiff, blending conventional tracing and transformation techniques in a way that uses the host language for metaprogramming while also allowing the programmer to explicitly define reusable functions that comprise a larger differentiable computation. We demonstrate the value of the Rose design by porting two differentiable physics simulations, and evaluate its performance on an optimization-based diagramming application, showing Rose outperforming the state-of-the-art in web-based autodiff by multiple orders of magnitude. 
 Cite asSam Estep, Wode Ni, Raven Rothkopf, and Joshua Sunshine. Rose: Composable Autodiff for the Interactive Web. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 15:1-15:27, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{estep_et_al:LIPIcs.ECOOP.2024.15 author = {Estep, Sam and Ni, Wode and Rothkopf, Raven and Sunshine, Joshua}, title = {{Rose: Composable Autodiff for the Interactive Web}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {15:1--15:27}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.15}, URN = {urn:nbn:de:0030-drops-208642}, doi = {10.4230/LIPIcs.ECOOP.2024.15}, annote = {Keywords: Automatic differentiation, differentiable programming, compilers, web} }@InProceedings{estep_et_al:LIPIcs.ECOOP.2024.15 author = {Estep, Sam and Ni, Wode and Rothkopf, Raven and Sunshine, Joshua}, title = {{Rose: Composable Autodiff for the Interactive Web}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {15:1--15:27}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.15}, URN = {urn:nbn:de:0030-drops-208642}, doi = {10.4230/LIPIcs.ECOOP.2024.15}, annote = {Keywords: Automatic differentiation, differentiable programming, compilers, web} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.16" - DOI: 10.4230/LIPIcs.ECOOP.2024.16
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.16/LIPIcs.ECOOP.2024.16.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.16" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.16" - Mover Logic: A Concurrent Program Logic for Reduction and Rely-Guarantee Reasoning
Authors:Cormac Flanagan and Stephen N. Freund 
 AbstractRely-guarantee (RG) logic uses thread interference specifications (relies and guarantees) to reason about the correctness of multithreaded software. Unfortunately, RG logic requires each function postcondition to be "stabilized" or specialized to the behavior of other threads, making it difficult to write function specifications that are reusable at multiple call sites. This paper presents mover logic, which extends RG logic to address this problem via the notion of atomic functions. Atomic functions behave as if they execute serially without interference from concurrent threads, and so they can be assigned more general and reusable specifications that avoid the stabilization requirement of RG logic. Several practical verifiers (Calvin-R, QED, CIVL, Armada, Anchor, etc.) have demonstrated the modularity benefits of atomic function specifications. However, the complexity of these systems and their correctness proofs makes it challenging to understand and extend these systems. Mover logic formalizes the central ideas of reduction in a declarative program logic that provides a foundation for future work in this area. 
 Cite asCormac Flanagan and Stephen N. Freund. Mover Logic: A Concurrent Program Logic for Reduction and Rely-Guarantee Reasoning. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 16:1-16:29, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{flanagan_et_al:LIPIcs.ECOOP.2024.16 author = {Flanagan, Cormac and Freund, Stephen N.}, title = {{Mover Logic: A Concurrent Program Logic for Reduction and Rely-Guarantee Reasoning}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {16:1--16:29}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.16}, URN = {urn:nbn:de:0030-drops-208654}, doi = {10.4230/LIPIcs.ECOOP.2024.16}, annote = {Keywords: concurrent program verification, reduction, rely-guarantee reasoning, synchronization} }@InProceedings{flanagan_et_al:LIPIcs.ECOOP.2024.16 author = {Flanagan, Cormac and Freund, Stephen N.}, title = {{Mover Logic: A Concurrent Program Logic for Reduction and Rely-Guarantee Reasoning}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {16:1--16:29}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.16}, URN = {urn:nbn:de:0030-drops-208654}, doi = {10.4230/LIPIcs.ECOOP.2024.16}, annote = {Keywords: concurrent program verification, reduction, rely-guarantee reasoning, synchronization} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.17" - DOI: 10.4230/LIPIcs.ECOOP.2024.17
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.17/LIPIcs.ECOOP.2024.17.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.17" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.17" - Fair Join Pattern Matching for Actors
Authors:Philipp Haller, Ayman Hussein, Hernán Melgratti, Alceste Scalas, and Emilio Tuosto 
 AbstractJoin patterns provide a promising approach to the development of concurrent and distributed message-passing applications. Several variations and implementations have been presented in the literature - but various aspects remain under-explored: in particular, how to specify a suitable notion of message matching, how to implement it correctly and efficiently, and how to systematically evaluate the implementation performance. In this work we focus on actor-based programming, and study the application of join patterns with conditional guards (i.e., the most expressive and challenging version of join patterns in literature). We formalise a novel specification of fair and deterministic join pattern matching, ensuring that older messages are always consumed if they can be matched. We present a stateful, tree-based join pattern matching algorithm and prove that it correctly implements our fair and deterministic matching specification. We present a novel Scala 3 actor library (called JoinActors) that implements our join pattern formalisation, leveraging macros to provide an intuitive API. Finally, we evaluate the performance of our implementation, by introducing a systematic benchmarking approach that takes into account the nuances of join pattern matching (in particular, its sensitivity to input traffic and complexity of patterns and guards). 
 Cite asPhilipp Haller, Ayman Hussein, Hernán Melgratti, Alceste Scalas, and Emilio Tuosto. Fair Join Pattern Matching for Actors. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 17:1-17:28, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{haller_et_al:LIPIcs.ECOOP.2024.17 author = {Haller, Philipp and Hussein, Ayman and Melgratti, Hern\'{a}n and Scalas, Alceste and Tuosto, Emilio}, title = {{Fair Join Pattern Matching for Actors}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {17:1--17:28}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.17}, URN = {urn:nbn:de:0030-drops-208663}, doi = {10.4230/LIPIcs.ECOOP.2024.17}, annote = {Keywords: Concurrency, join patterns, join calculus, actor model} }@InProceedings{haller_et_al:LIPIcs.ECOOP.2024.17 author = {Haller, Philipp and Hussein, Ayman and Melgratti, Hern\'{a}n and Scalas, Alceste and Tuosto, Emilio}, title = {{Fair Join Pattern Matching for Actors}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {17:1--17:28}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.17}, URN = {urn:nbn:de:0030-drops-208663}, doi = {10.4230/LIPIcs.ECOOP.2024.17}, annote = {Keywords: Concurrency, join patterns, join calculus, actor model} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.18" - DOI: 10.4230/LIPIcs.ECOOP.2024.18
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.18/LIPIcs.ECOOP.2024.18.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.18" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.18" - A CFL-Reachability Formulation of Callsite-Sensitive Pointer Analysis with Built-In On-The-Fly Call Graph Construction
Authors:Dongjie He, Jingbo Lu, and Jingling Xue 
 AbstractIn object-oriented languages, the traditional CFL-reachability formulation for k-callsite-sensitive pointer analysis (kCFA) focuses on modeling field accesses and calling contexts, but it relies on a separate algorithm for call graph construction. This division can result in a loss of precision in kCFA, a problem that persists even when using the most precise call graphs, whether pre-constructed or generated on the fly. Moreover, pre-analyses based on this framework aiming to improve the efficiency of kCFA may inadvertently reduce its precision, due to the framework’s lack of native call graph construction, essential for precise analysis. Addressing this gap, this paper introduces a novel CFL-reachability formulation of kCFA for Java, uniquely integrating on-the-fly call graph construction. This advancement not only addresses the precision loss inherent in the traditional CFL-reachability-based approach but also enhances its overall applicability. In a significant secondary contribution, we present the first precision-preserving pre-analysis to accelerate kCFA. This pre-analysis leverages selective context sensitivity to improve the efficiency of kCFA without sacrificing its precision. Collectively, these contributions represent a substantial step forward in pointer analysis, offering both theoretical and practical advancements that could benefit future developments in the field. 
 Cite asDongjie He, Jingbo Lu, and Jingling Xue. A CFL-Reachability Formulation of Callsite-Sensitive Pointer Analysis with Built-In On-The-Fly Call Graph Construction. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 18:1-18:29, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{he_et_al:LIPIcs.ECOOP.2024.18 author = {He, Dongjie and Lu, Jingbo and Xue, Jingling}, title = {{A CFL-Reachability Formulation of Callsite-Sensitive Pointer Analysis with Built-In On-The-Fly Call Graph Construction}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {18:1--18:29}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.18}, URN = {urn:nbn:de:0030-drops-208674}, doi = {10.4230/LIPIcs.ECOOP.2024.18}, annote = {Keywords: Pointer Analysis, CFL Reachability, Call Graph Construction} }@InProceedings{he_et_al:LIPIcs.ECOOP.2024.18 author = {He, Dongjie and Lu, Jingbo and Xue, Jingling}, title = {{A CFL-Reachability Formulation of Callsite-Sensitive Pointer Analysis with Built-In On-The-Fly Call Graph Construction}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {18:1--18:29}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.18}, URN = {urn:nbn:de:0030-drops-208674}, doi = {10.4230/LIPIcs.ECOOP.2024.18}, annote = {Keywords: Pointer Analysis, CFL Reachability, Call Graph Construction} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.19" - DOI: 10.4230/LIPIcs.ECOOP.2024.19
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.19/LIPIcs.ECOOP.2024.19.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.19" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.19" - Fearless Asynchronous Communications with Timed Multiparty Session Protocols
Authors:Ping Hou, Nicolas Lagaillardie, and Nobuko Yoshida 
 AbstractSession types using affinity and exception handling mechanisms have been developed to ensure the communication safety of protocols implemented in concurrent and distributed programming languages. Nevertheless, current affine session types are inadequate for specifying real-world asynchronous protocols, as they are usually imposed by time constraints which enable timeout exceptions to prevent indefinite blocking while awaiting valid messages. This paper proposes the first formal integration of affinity, time constraints, timeouts, and time-failure handling based on multiparty session types for supporting reliability in asynchronous distributed systems. With this theory, we statically guarantee that asynchronous timed communication is deadlock-free, communication safe, while being fearless - never hindered by timeout errors or abrupt terminations. To implement our theory, we introduce MultiCrusty^T, a Rust toolchain designed to facilitate the implementation of safe affine timed protocols. MultiCrusty^T leverages generic types and the time library to handle timed communications, integrated with optional types for affinity. We evaluate MultiCrusty^T by extending diverse examples from the literature to incorporate time and timeouts. We also showcase the correctness by construction of our approach by implementing various real-world use cases, including protocols from the Internet of Remote Things domain and real-time systems. 
 Cite asPing Hou, Nicolas Lagaillardie, and Nobuko Yoshida. Fearless Asynchronous Communications with Timed Multiparty Session Protocols. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 19:1-19:30, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{hou_et_al:LIPIcs.ECOOP.2024.19 author = {Hou, Ping and Lagaillardie, Nicolas and Yoshida, Nobuko}, title = {{Fearless Asynchronous Communications with Timed Multiparty Session Protocols}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {19:1--19:30}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.19}, URN = {urn:nbn:de:0030-drops-208681}, doi = {10.4230/LIPIcs.ECOOP.2024.19}, annote = {Keywords: Session Types, Concurrency, Time Failure Handling, Affinity, Timeout, Rust} }@InProceedings{hou_et_al:LIPIcs.ECOOP.2024.19 author = {Hou, Ping and Lagaillardie, Nicolas and Yoshida, Nobuko}, title = {{Fearless Asynchronous Communications with Timed Multiparty Session Protocols}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {19:1--19:30}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.19}, URN = {urn:nbn:de:0030-drops-208681}, doi = {10.4230/LIPIcs.ECOOP.2024.19}, annote = {Keywords: Session Types, Concurrency, Time Failure Handling, Affinity, Timeout, Rust} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.20" - DOI: 10.4230/LIPIcs.ECOOP.2024.20
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.20/LIPIcs.ECOOP.2024.20.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.20" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.20" - Taking a Closer Look: An Outlier-Driven Approach to Compilation-Time Optimization
Authors:Florian Huemer, David Leopoldseder, Aleksandar Prokopec, Raphael Mosaner, and Hanspeter Mössenböck 
 AbstractImproving compilation time in optimizing compilers is challenging due to their large number of interconnected components. This includes compiler optimizations, compiler tiers, heuristics, and profiling information. Despite this complexity, research in compilation-time optimization is often guided by analyzing metrics of entire program runs, such as the total compilation time and overall memory footprint. This coarse-grained perspective hides relevant information, such as source program functions for which the compiler allocates a lot of memory or compiler optimizations with a high impact on the total compilation time. This leaves high-level metrics as the only reference point for driving optimization design. Consequently, compilation-time regressions in one program function that are obscured by improvements in other functions stay undetected, while the impacts of compiler changes on untouched parts of the compiler are mainly unknown. Furthermore, developers overlook long-standing compiler defects because their high-level metrics do not change over time. To address these limitations, we propose ICON, a new data-driven approach to compilation-time optimization that breaks up high-level metrics into individual source program functions, compiler optimizations, or even into individual instructions in the compiler source code. Our methodology enables an iterative in-depth compilation-time analysis, focusing on outliers to identify optimization opportunities. We show that outliers, both in terms of time spent in a particular compiler optimization, and in terms of individual compilations that take substantially longer, can reveal potential problems in the compiler implementation. We applied our approach to GraalVM and extracted data for multiple of its language runtimes. We analyzed the resulting data, present the first detailed look into the distribution of compilation time in the GraalVM compiler, a state-of-the-art multi-language compiler, and identified defects that led to regressions in overall compilation time or the compilation time of specific languages. We furthermore designed two optimizations based on the identified outliers that improve compilation time between 2.25% and 9.45%. We believe that our approach can guide compiler developers in finding usually overlooked optimization potential and defects, and focus future research efforts in making compilers more efficient. 
 Cite asFlorian Huemer, David Leopoldseder, Aleksandar Prokopec, Raphael Mosaner, and Hanspeter Mössenböck. Taking a Closer Look: An Outlier-Driven Approach to Compilation-Time Optimization. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 20:1-20:28, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{huemer_et_al:LIPIcs.ECOOP.2024.20 author = {Huemer, Florian and Leopoldseder, David and Prokopec, Aleksandar and Mosaner, Raphael and M\"{o}ssenb\"{o}ck, Hanspeter}, title = {{Taking a Closer Look: An Outlier-Driven Approach to Compilation-Time Optimization}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {20:1--20:28}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.20}, URN = {urn:nbn:de:0030-drops-208693}, doi = {10.4230/LIPIcs.ECOOP.2024.20}, annote = {Keywords: Compilation time, outliers, dynamic languages, virtual machines, GraalVM, ICON} }@InProceedings{huemer_et_al:LIPIcs.ECOOP.2024.20 author = {Huemer, Florian and Leopoldseder, David and Prokopec, Aleksandar and Mosaner, Raphael and M\"{o}ssenb\"{o}ck, Hanspeter}, title = {{Taking a Closer Look: An Outlier-Driven Approach to Compilation-Time Optimization}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {20:1--20:28}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.20}, URN = {urn:nbn:de:0030-drops-208693}, doi = {10.4230/LIPIcs.ECOOP.2024.20}, annote = {Keywords: Compilation time, outliers, dynamic languages, virtual machines, GraalVM, ICON} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.21" - DOI: 10.4230/LIPIcs.ECOOP.2024.21
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.21/LIPIcs.ECOOP.2024.21.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.21" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.21" - Learning Gradual Typing Performance
Authors:Mohammad Wahiduzzaman Khan, Sheng Chen, and Yi He 
 AbstractGradual typing has emerged as a promising typing discipline for reconciling static and dynamic typing, which have respective strengths and shortcomings. Thanks to its promises, gradual typing has gained tremendous momentum in both industry and academia. A main challenge in gradual typing is that, however, the performance of its programs can often be unpredictable, and adding or removing the type of a a single parameter may lead to wild performance swings. Many approaches have been proposed to optimize gradual typing performance, but little work has been done to aid the understanding of the performance landscape of gradual typing and navigating the migration process (which adds type annotations to make programs more static) to avert performance slowdowns. Motivated by this situation, this work develops a machine-learning-based approach to predict the performance of each possible way of adding type annotations to a program. On top of that, many supports for program migrations could be developed, such as finding the most performant neighbor of any given configuration. Our approach gauges runtime overheads of dynamic type checks inserted by gradual typing and uses that information to train a machine learning model, which is used to predict the running time of gradual programs. We have evaluated our approach on 12 Python benchmarks for both guarded and transient semantics. For guarded semantics, our evaluation results indicate that with only 40 training instances generated from each benchmark, the predicted times for all other instances differ on average by 4% from the measured times. For transient semantics, the time difference ratio is higher but the time difference is often within 0.1 seconds. 
 Cite asMohammad Wahiduzzaman Khan, Sheng Chen, and Yi He. Learning Gradual Typing Performance. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 21:1-21:27, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{khan_et_al:LIPIcs.ECOOP.2024.21 author = {Khan, Mohammad Wahiduzzaman and Chen, Sheng and He, Yi}, title = {{Learning Gradual Typing Performance}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {21:1--21:27}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.21}, URN = {urn:nbn:de:0030-drops-208706}, doi = {10.4230/LIPIcs.ECOOP.2024.21}, annote = {Keywords: Gradual typing performance, type migration, performance prediction, machine learning} }@InProceedings{khan_et_al:LIPIcs.ECOOP.2024.21 author = {Khan, Mohammad Wahiduzzaman and Chen, Sheng and He, Yi}, title = {{Learning Gradual Typing Performance}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {21:1--21:27}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.21}, URN = {urn:nbn:de:0030-drops-208706}, doi = {10.4230/LIPIcs.ECOOP.2024.21}, annote = {Keywords: Gradual typing performance, type migration, performance prediction, machine learning} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.22" - DOI: 10.4230/LIPIcs.ECOOP.2024.22
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.22/LIPIcs.ECOOP.2024.22.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.22" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.22" - Constrictor: Immutability as a Design Concept
Authors:Elad Kinsbruner, Shachar Itzhaky, and Hila Peleg 
 AbstractMany object-oriented applications in algorithm design rely on objects never changing during their lifetime. This is often tackled by marking object references as read-only, e.g., using the const keyword in C++. In other languages like Python or Java where such a concept does not exist, programmers rely on best practices that are entirely unenforced. While reliance on best practices is obviously too permissive, const-checking is too restrictive: it is possible for a method to mutate the internal state while still satisfying the property we expect from an "immutable" object in this setting. We would therefore like to enforce the immutability of an object’s abstract state. We check an object’s immutability through a view of its abstract state: for instances of an immutable class, the view does not change when running any of the class’s methods, even if some of the internal state does change. If all methods of a class are verified as non-mutating, we can deem the entire class view-immutable. We present an SMT-based algorithm to check view-immutability, and implement it in our linter/verifier, Constrictor. We evaluate Constrictor on 51 examples of immutability-related design violations. Our evaluation shows that Constrictor is effective at catching a variety of prototypical design violations, and does so in seconds. We also explore Constrictor with two real-world case studies. 
 Cite asElad Kinsbruner, Shachar Itzhaky, and Hila Peleg. Constrictor: Immutability as a Design Concept. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 22:1-22:29, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{kinsbruner_et_al:LIPIcs.ECOOP.2024.22 author = {Kinsbruner, Elad and Itzhaky, Shachar and Peleg, Hila}, title = {{Constrictor: Immutability as a Design Concept}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {22:1--22:29}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.22}, URN = {urn:nbn:de:0030-drops-208715}, doi = {10.4230/LIPIcs.ECOOP.2024.22}, annote = {Keywords: Immutability, Design Enforcement, SMT, Liskov Substitution Principle, Object-oriented Programming} }@InProceedings{kinsbruner_et_al:LIPIcs.ECOOP.2024.22 author = {Kinsbruner, Elad and Itzhaky, Shachar and Peleg, Hila}, title = {{Constrictor: Immutability as a Design Concept}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {22:1--22:29}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.22}, URN = {urn:nbn:de:0030-drops-208715}, doi = {10.4230/LIPIcs.ECOOP.2024.22}, annote = {Keywords: Immutability, Design Enforcement, SMT, Liskov Substitution Principle, Object-oriented Programming} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.23" - DOI: 10.4230/LIPIcs.ECOOP.2024.23
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.23/LIPIcs.ECOOP.2024.23.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.23" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.23" - InferType: A Compiler Toolkit for Implementing Efficient Constraint-Based Type Inference
Authors:Senxi Li, Tetsuro Yamazaki, and Shigeru Chiba 
 AbstractSupporting automatic type inference is in demand in modern language development. It is a challenging task but without appropriate supporting toolkits. This paper presents InferType, a Java library that helps implement constraint-based type inference. A compiler writer uses InferType’s classes and methods to describe type constraints and typing rules for type inference. InferType then performs constraint solving by translation to the Z3 SMT solver. InferType is equipped with our developed optimization technique. It reduces the search space for type variables by pre-computing the structures of those type variables for mitigating the performance bottleneck of constraint solving with deeply nested types. We use InferType to implement type inference for a subset of Python, and conduct experiments to evaluate how the developed optimization technique can affect the performance of type inference. Our results show that InferType’s optimization can greatly mitigate the performance bottleneck for programs with deeply nested types, and can potentially improve the performance for large nested types. 
 Cite asSenxi Li, Tetsuro Yamazaki, and Shigeru Chiba. InferType: A Compiler Toolkit for Implementing Efficient Constraint-Based Type Inference. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 23:1-23:28, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{li_et_al:LIPIcs.ECOOP.2024.23 author = {Li, Senxi and Yamazaki, Tetsuro and Chiba, Shigeru}, title = {{InferType: A Compiler Toolkit for Implementing Efficient Constraint-Based Type Inference}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {23:1--23:28}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.23}, URN = {urn:nbn:de:0030-drops-208728}, doi = {10.4230/LIPIcs.ECOOP.2024.23}, annote = {Keywords: Domain Specific Languages, Compilation, Static Analysis, Type Inference, Constraint Solving, SMT Solver} }@InProceedings{li_et_al:LIPIcs.ECOOP.2024.23 author = {Li, Senxi and Yamazaki, Tetsuro and Chiba, Shigeru}, title = {{InferType: A Compiler Toolkit for Implementing Efficient Constraint-Based Type Inference}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {23:1--23:28}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.23}, URN = {urn:nbn:de:0030-drops-208728}, doi = {10.4230/LIPIcs.ECOOP.2024.23}, annote = {Keywords: Domain Specific Languages, Compilation, Static Analysis, Type Inference, Constraint Solving, SMT Solver} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.24" - DOI: 10.4230/LIPIcs.ECOOP.2024.24
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.24/LIPIcs.ECOOP.2024.24.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.24" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.24" - Qafny: A Quantum-Program Verifier
Authors:Liyi Li, Mingwei Zhu, Rance Cleaveland, Alexander Nicolellis, Yi Lee, Le Chang, and Xiaodi Wu 
 AbstractBecause of the probabilistic/nondeterministic behavior of quantum programs, it is highly advisable to verify them formally to ensure that they correctly implement their specifications. Formal verification, however, also traditionally requires significant effort. To address this challenge, we present Qafny, an automated proof system based on the program verifier Dafny and designed for verifying quantum programs. At its core, Qafny uses a type-guided quantum proof system that translates quantum operations to classical array operations modeled within a classical separation logic framework. We prove the soundness and completeness of our proof system and implement a prototype compiler that transforms Qafny programs and specifications into Dafny for automated verification purposes. We then illustrate the utility of Qafny’s automated capabilities in efficiently verifying important quantum algorithms, including quantum-walk algorithms, Grover’s algorithm, and Shor’s algorithm. 
 Cite asLiyi Li, Mingwei Zhu, Rance Cleaveland, Alexander Nicolellis, Yi Lee, Le Chang, and Xiaodi Wu. Qafny: A Quantum-Program Verifier. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 24:1-24:31, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{li_et_al:LIPIcs.ECOOP.2024.24 author = {Li, Liyi and Zhu, Mingwei and Cleaveland, Rance and Nicolellis, Alexander and Lee, Yi and Chang, Le and Wu, Xiaodi}, title = {{Qafny: A Quantum-Program Verifier}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {24:1--24:31}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.24}, URN = {urn:nbn:de:0030-drops-208735}, doi = {10.4230/LIPIcs.ECOOP.2024.24}, annote = {Keywords: Quantum Computing, Automated Verification, Separation Logic} }@InProceedings{li_et_al:LIPIcs.ECOOP.2024.24 author = {Li, Liyi and Zhu, Mingwei and Cleaveland, Rance and Nicolellis, Alexander and Lee, Yi and Chang, Le and Wu, Xiaodi}, title = {{Qafny: A Quantum-Program Verifier}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {24:1--24:31}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.24}, URN = {urn:nbn:de:0030-drops-208735}, doi = {10.4230/LIPIcs.ECOOP.2024.24}, annote = {Keywords: Quantum Computing, Automated Verification, Separation Logic} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.25" - DOI: 10.4230/LIPIcs.ECOOP.2024.25
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.25/LIPIcs.ECOOP.2024.25.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.25" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.25" - Compositional Symbolic Execution for Correctness and Incorrectness Reasoning
Authors:Andreas Lööw, Daniele Nantes-Sobrinho, Sacha-Élie Ayoun, Caroline Cronjäger, Petar Maksimović, and Philippa Gardner 
 AbstractThe introduction of separation logic has led to the development of symbolic execution techniques and tools that are (functionally) compositional with function specifications that can be used in broader calling contexts. Many of the compositional symbolic execution tools developed in academia and industry have been grounded on a formal foundation, but either the function specifications are not validated with respect to the underlying separation logic of the theory, or there is a large gulf between the theory and the implementation of the tool. We introduce a formal compositional symbolic execution engine which creates and uses function specifications from an underlying separation logic and provides a sound theoretical foundation for, and indeed was partially inspired by, the Gillian symbolic execution platform. This is achieved by providing an axiomatic interface which describes the properties of the consume and produce operations used in the engine to update compositionally the symbolic state, for example when calling function specifications. This consume-produce technique is used by VeriFast, Viper, and Gillian, but has not been previously characterised independently of the tool. As part of our result, we give consume and produce operations inspired by the Gillian implementation that satisfy the properties described by our axiomatic interface. A surprising property is that our engine semantics provides a common foundation for both correctness and incorrectness reasoning, with the difference in the underlying engine only amounting to the choice to use satisfiability or validity. We use this property to extend the Gillian platform, which previously only supported correctness reasoning, with incorrectness reasoning and automatic true bug-finding using incorrectness bi-abduction. We evaluate our new Gillian platform by using the Gillian instantiation to C. This instantiation is the first tool grounded on a common formal compositional symbolic execution engine to support both correctness and incorrectness reasoning. 
 Cite asAndreas Lööw, Daniele Nantes-Sobrinho, Sacha-Élie Ayoun, Caroline Cronjäger, Petar Maksimović, and Philippa Gardner. Compositional Symbolic Execution for Correctness and Incorrectness Reasoning. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 25:1-25:28, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{loow_et_al:LIPIcs.ECOOP.2024.25 author = {L\"{o}\"{o}w, Andreas and Nantes-Sobrinho, Daniele and Ayoun, Sacha-\'{E}lie and Cronj\"{a}ger, Caroline and Maksimovi\'{c}, Petar and Gardner, Philippa}, title = {{Compositional Symbolic Execution for Correctness and Incorrectness Reasoning}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {25:1--25:28}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.25}, URN = {urn:nbn:de:0030-drops-208741}, doi = {10.4230/LIPIcs.ECOOP.2024.25}, annote = {Keywords: separation logic, incorrectness logic, symbolic execution, bi-abduction} }@InProceedings{loow_et_al:LIPIcs.ECOOP.2024.25 author = {L\"{o}\"{o}w, Andreas and Nantes-Sobrinho, Daniele and Ayoun, Sacha-\'{E}lie and Cronj\"{a}ger, Caroline and Maksimovi\'{c}, Petar and Gardner, Philippa}, title = {{Compositional Symbolic Execution for Correctness and Incorrectness Reasoning}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {25:1--25:28}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.25}, URN = {urn:nbn:de:0030-drops-208741}, doi = {10.4230/LIPIcs.ECOOP.2024.25}, annote = {Keywords: separation logic, incorrectness logic, symbolic execution, bi-abduction} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.26" - DOI: 10.4230/LIPIcs.ECOOP.2024.26
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.26/LIPIcs.ECOOP.2024.26.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.26" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.26" - Matching Plans for Frame Inference in Compositional Reasoning
Authors:Andreas Lööw, Daniele Nantes-Sobrinho, Sacha-Élie Ayoun, Petar Maksimović, and Philippa Gardner 
 AbstractThe use of function specifications to reason about function calls and the manipulation of user-defined predicates are two essential ingredients of modern compositional verification tools based on separation logic. To execute these operations successfully, these tools must be able to solve the frame inference problem, that is, to understand which parts of the state are relevant for the operation at hand. We introduce matching plans, a concept that is used in the Gillian verification platform to automate frame inference efficiently. We extract matching plans and their automation machinery from the Gillian implementation and present them in a tool-agnostic way, making the Gillian approach available to the broader verification community as a verification-tool design pattern. 
 Cite asAndreas Lööw, Daniele Nantes-Sobrinho, Sacha-Élie Ayoun, Petar Maksimović, and Philippa Gardner. Matching Plans for Frame Inference in Compositional Reasoning. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 26:1-26:20, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{loow_et_al:LIPIcs.ECOOP.2024.26 author = {L\"{o}\"{o}w, Andreas and Nantes-Sobrinho, Daniele and Ayoun, Sacha-\'{E}lie and Maksimovi\'{c}, Petar and Gardner, Philippa}, title = {{Matching Plans for Frame Inference in Compositional Reasoning}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {26:1--26:20}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.26}, URN = {urn:nbn:de:0030-drops-208751}, doi = {10.4230/LIPIcs.ECOOP.2024.26}, annote = {Keywords: Compositional reasoning, separation logic, frame inference} }@InProceedings{loow_et_al:LIPIcs.ECOOP.2024.26 author = {L\"{o}\"{o}w, Andreas and Nantes-Sobrinho, Daniele and Ayoun, Sacha-\'{E}lie and Maksimovi\'{c}, Petar and Gardner, Philippa}, title = {{Matching Plans for Frame Inference in Compositional Reasoning}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {26:1--26:20}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.26}, URN = {urn:nbn:de:0030-drops-208751}, doi = {10.4230/LIPIcs.ECOOP.2024.26}, annote = {Keywords: Compositional reasoning, separation logic, frame inference} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.27" - DOI: 10.4230/LIPIcs.ECOOP.2024.27
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.27/LIPIcs.ECOOP.2024.27.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.27" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.27" - The Fault in Our Stars: Designing Reproducible Large-scale Code Analysis Experiments
Authors:Petr Maj, Stefanie Muroya, Konrad Siek, Luca Di Grazia, and Jan Vitek 
 AbstractLarge-scale software repositories are a source of insights for software engineering. They offer an unmatched window into the software development process at scale. Their sheer number and size holds the promise of broadly applicable results. At the same time, that very size presents practical challenges for scaling tools and algorithms to millions of projects. A reasonable approach is to limit studies to representative samples of the population of interest. Broadly applicable conclusions can then be obtained by generalizing to the entire population. The contribution of this paper is a standardized experimental design methodology for choosing the inputs of studies working with large-scale repositories. We advocate for a methodology that clearly lays out what the population of interest is, how to sample it, and that fosters reproducibility. Along the way, we discourage researchers from using extrinsic attributes of projects such as stars, that measure some unclear notion of popularity. 
 Cite asPetr Maj, Stefanie Muroya, Konrad Siek, Luca Di Grazia, and Jan Vitek. The Fault in Our Stars: Designing Reproducible Large-scale Code Analysis Experiments. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 27:1-27:23, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{maj_et_al:LIPIcs.ECOOP.2024.27 author = {Maj, Petr and Muroya, Stefanie and Siek, Konrad and Di Grazia, Luca and Vitek, Jan}, title = {{The Fault in Our Stars: Designing Reproducible Large-scale Code Analysis Experiments}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {27:1--27:23}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.27}, URN = {urn:nbn:de:0030-drops-208769}, doi = {10.4230/LIPIcs.ECOOP.2024.27}, annote = {Keywords: software, mining code repositories, source code analysis} }@InProceedings{maj_et_al:LIPIcs.ECOOP.2024.27 author = {Maj, Petr and Muroya, Stefanie and Siek, Konrad and Di Grazia, Luca and Vitek, Jan}, title = {{The Fault in Our Stars: Designing Reproducible Large-scale Code Analysis Experiments}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {27:1--27:23}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.27}, URN = {urn:nbn:de:0030-drops-208769}, doi = {10.4230/LIPIcs.ECOOP.2024.27}, annote = {Keywords: software, mining code repositories, source code analysis} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.28" - DOI: 10.4230/LIPIcs.ECOOP.2024.28
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.28/LIPIcs.ECOOP.2024.28.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.28" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.28" - Static Basic Block Versioning
Authors:Olivier Melançon, Marc Feeley, and Manuel Serrano 
 AbstractBasic Block Versioning (BBV) is a compilation technique for optimizing program execution. It consists in duplicating and specializing basic blocks of code according to the execution contexts of the blocks, up to a version limit. BBV has been used in Just-In-Time (JIT) compilers for reducing the dynamic type checks of dynamic languages. Our work revisits the BBV technique to adapt it to Ahead-of-Time (AOT) compilation. This Static BBV (SBBV) raises new challenges, most importantly how to ensure the convergence of the algorithm when the specializations of the basic blocks are not based on profiled variable values and how to select the good specialization contexts. SBBV opens new opportunities for more precise optimizations as the compiler can explore multiple versions and only keep those within the version limit that yield better generated code. In this paper, we present the main SBBV algorithm and its use to optimize the dynamic type checks, array bound checks, and mixed-type arithmetic operators often found in dynamic languages. We have implemented SBBV in two AOT compilers for the Scheme programming language that we have used to evaluate the technique’s effectiveness. On a suite of benchmarks, we have observed that even with a low limit of 2 versions, SBBV greatly reduces the number of dynamic type tests (by 54% and 62% on average) and accelerates the execution time (by about 10% on average). Previous work has needed a higher version limit to achieve a similar level of optimization. We also observe a small impact on compilation time and code size (a decrease in some cases). 
 Cite asOlivier Melançon, Marc Feeley, and Manuel Serrano. Static Basic Block Versioning. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 28:1-28:27, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{melancon_et_al:LIPIcs.ECOOP.2024.28 author = {Melan\c{c}on, Olivier and Feeley, Marc and Serrano, Manuel}, title = {{Static Basic Block Versioning}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {28:1--28:27}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.28}, URN = {urn:nbn:de:0030-drops-208770}, doi = {10.4230/LIPIcs.ECOOP.2024.28}, annote = {Keywords: Compiler, Ahead-of-Time Compilation, Optimization, Dynamic Languages} }@InProceedings{melancon_et_al:LIPIcs.ECOOP.2024.28 author = {Melan\c{c}on, Olivier and Feeley, Marc and Serrano, Manuel}, title = {{Static Basic Block Versioning}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {28:1--28:27}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.28}, URN = {urn:nbn:de:0030-drops-208770}, doi = {10.4230/LIPIcs.ECOOP.2024.28}, annote = {Keywords: Compiler, Ahead-of-Time Compilation, Optimization, Dynamic Languages} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.29" - DOI: 10.4230/LIPIcs.ECOOP.2024.29
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.29/LIPIcs.ECOOP.2024.29.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.29" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.29" - Generalizing Shape Analysis with Gradual Types
Authors:Zeina Migeed, James Reed, Jason Ansel, and Jens Palsberg 
 AbstractTensors are multi-dimensional data structures that can represent the data processed by machine learning tasks. Tensor programs tend to be short and readable, and they can leverage libraries and frameworks such as TensorFlow and PyTorch, as well as modern hardware such as GPUs and TPUs. However, tensor programs also tend to obscure shape information, which can cause shape errors that are difficult to find. Such shape errors can be avoided by a combination of shape annotations and shape analysis, but such annotations are burdensome to come up with manually. In this paper, we use gradual typing to reduce the barrier of entry. Gradual typing offers a way to incrementally introduce type annotations into programs. From there, we focus on tool support for type migration, which is a concept that closely models code-annotation tasks and allows us to do shape reasoning and utilize it for different purposes. We develop a comprehensive gradual typing theory to reason about tensor shapes. We then ask three fundamental questions about a gradually typed tensor program. (1) Does the program have a static migration? (2) Given a program and some arithmetic constraints on shapes, can we migrate the program according to the constraints? (3) Can we eliminate branches that depend on shapes? We develop novel tools to address the three problems. For the third problem, there are currently two PyTorch tools that aim to eliminate branches. They do so by eliminating them for just a single input. Our tool is the first to eliminate branches for an infinite class of inputs, using static shape information. Our tools help prevent bugs, alleviate the burden on the programmer of annotating the program, and improves the process of program transformation. 
 Cite asZeina Migeed, James Reed, Jason Ansel, and Jens Palsberg. Generalizing Shape Analysis with Gradual Types. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 29:1-29:28, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{migeed_et_al:LIPIcs.ECOOP.2024.29 author = {Migeed, Zeina and Reed, James and Ansel, Jason and Palsberg, Jens}, title = {{Generalizing Shape Analysis with Gradual Types}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {29:1--29:28}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.29}, URN = {urn:nbn:de:0030-drops-208786}, doi = {10.4230/LIPIcs.ECOOP.2024.29}, annote = {Keywords: Tensor Shapes, Gradual Types, Migration} }@InProceedings{migeed_et_al:LIPIcs.ECOOP.2024.29 author = {Migeed, Zeina and Reed, James and Ansel, Jason and Palsberg, Jens}, title = {{Generalizing Shape Analysis with Gradual Types}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {29:1--29:28}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.29}, URN = {urn:nbn:de:0030-drops-208786}, doi = {10.4230/LIPIcs.ECOOP.2024.29}, annote = {Keywords: Tensor Shapes, Gradual Types, Migration} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.30" - DOI: 10.4230/LIPIcs.ECOOP.2024.30
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.30/LIPIcs.ECOOP.2024.30.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.30" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.30" - Verifying Lock-Free Search Structure Templates
Authors:Nisarg Patel, Dennis Shasha, and Thomas Wies 
 AbstractWe present and verify template algorithms for lock-free concurrent search structures that cover a broad range of existing implementations based on lists and skiplists. Our linearizability proofs are fully mechanized in the concurrent separation logic Iris. The proofs are modular and cover the broader design space of the underlying algorithms by parameterizing the verification over aspects such as the low-level representation of nodes and the style of data structure maintenance. As a further technical contribution, we present a mechanization of a recently proposed method for reasoning about future-dependent linearization points using hindsight arguments. The mechanization builds on Iris' support for prophecy reasoning and user-defined ghost resources. We demonstrate that the method can help to reduce the proof effort compared to direct prophecy-based proofs. 
 Cite asNisarg Patel, Dennis Shasha, and Thomas Wies. Verifying Lock-Free Search Structure Templates. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 30:1-30:28, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{patel_et_al:LIPIcs.ECOOP.2024.30 author = {Patel, Nisarg and Shasha, Dennis and Wies, Thomas}, title = {{Verifying Lock-Free Search Structure Templates}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {30:1--30:28}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.30}, URN = {urn:nbn:de:0030-drops-208797}, doi = {10.4230/LIPIcs.ECOOP.2024.30}, annote = {Keywords: skiplists, lock-free, separation logic, linearizability, future-dependent linearization points, hindsight reasoning} }@InProceedings{patel_et_al:LIPIcs.ECOOP.2024.30 author = {Patel, Nisarg and Shasha, Dennis and Wies, Thomas}, title = {{Verifying Lock-Free Search Structure Templates}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {30:1--30:28}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.30}, URN = {urn:nbn:de:0030-drops-208797}, doi = {10.4230/LIPIcs.ECOOP.2024.30}, annote = {Keywords: skiplists, lock-free, separation logic, linearizability, future-dependent linearization points, hindsight reasoning} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.31" - DOI: 10.4230/LIPIcs.ECOOP.2024.31
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.31/LIPIcs.ECOOP.2024.31.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.31" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.31" - Ozone: Fully Out-of-Order Choreographies
Authors:Dan Plyukhin, Marco Peressotti, and Fabrizio Montesi 
 AbstractChoreographic programming is a paradigm for writing distributed applications. It allows programmers to write a single program, called a choreography, that can be compiled to generate correct implementations of each process in the application. Although choreographies provide good static guarantees, they can exhibit high latency when messages or processes are delayed. This is because processes in a choreography typically execute in a fixed, deterministic order, and cannot adapt to the order that messages arrive at runtime. In non-choreographic code, programmers can address this problem by allowing processes to execute out of order - for instance by using futures or reactive programming. However, in choreographic code, out-of-order process execution can lead to serious and subtle bugs, called communication integrity violations (CIVs). In this paper, we develop a model of choreographic programming for out-of-order processes that guarantees absence of CIVs and deadlocks. As an application of our approach, we also introduce an API for safe non-blocking communication via futures in the choreographic programming language Choral. The API allows processes to execute out of order, participate in multiple choreographies concurrently, and to handle unordered data messages. We provide an illustrative evaluation of our API, showing that out-of-order execution can reduce latency and increase throughput by overlapping communication with computation. 
 Cite asDan Plyukhin, Marco Peressotti, and Fabrizio Montesi. Ozone: Fully Out-of-Order Choreographies. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 31:1-31:28, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{plyukhin_et_al:LIPIcs.ECOOP.2024.31 author = {Plyukhin, Dan and Peressotti, Marco and Montesi, Fabrizio}, title = {{Ozone: Fully Out-of-Order Choreographies}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {31:1--31:28}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.31}, URN = {urn:nbn:de:0030-drops-208800}, doi = {10.4230/LIPIcs.ECOOP.2024.31}, annote = {Keywords: Choreographic programming, Asynchrony, Concurrency} }@InProceedings{plyukhin_et_al:LIPIcs.ECOOP.2024.31 author = {Plyukhin, Dan and Peressotti, Marco and Montesi, Fabrizio}, title = {{Ozone: Fully Out-of-Order Choreographies}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {31:1--31:28}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.31}, URN = {urn:nbn:de:0030-drops-208800}, doi = {10.4230/LIPIcs.ECOOP.2024.31}, annote = {Keywords: Choreographic programming, Asynchrony, Concurrency} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.32" - DOI: 10.4230/LIPIcs.ECOOP.2024.32
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.32/LIPIcs.ECOOP.2024.32.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.32" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.32" - Tenspiler: A Verified-Lifting-Based Compiler for Tensor Operations
Authors:Jie Qiu, Colin Cai, Sahil Bhatia, Niranjan Hasabnis, Sanjit A. Seshia, and Alvin Cheung 
 AbstractTensor processing infrastructures such as deep learning frameworks and specialized hardware accelerators have revolutionized how computationally intensive code from domains such as deep learning and image processing is executed and optimized. These infrastructures provide powerful and expressive abstractions while ensuring high performance. However, to utilize them, code must be written specifically using the APIs / ISAs of such software frameworks or hardware accelerators. Importantly, given the fast pace of innovation in these domains, code written today quickly becomes legacy as new frameworks and accelerators are developed, and migrating such legacy code manually is a considerable effort. To enable developers in leveraging such DSLs while preserving their current programming paradigm, we present Tenspiler, a verified-lifting-based compiler that uses program synthesis to translate sequential programs written in general-purpose programming languages (e.g., C++ or Python code that does not leverage any specialized framework or accelerator) into tensor operations. Central to Tenspiler is our carefully crafted yet simple intermediate language, named TensIR, that expresses tensor operations. TensIR enables efficient lifting, verification, and code generation. Unlike classical pattern-matching-based compilers, Tenspiler uses program synthesis to translate input code into TensIR, which is then compiled to the target API / ISA. Currently, Tenspiler already supports six DSLs, spanning a broad spectrum of software and hardware environments. Furthermore, we show that new backends can be easily supported by Tenspiler by adding simple pattern-matching rules for TensIR. Using 10 real-world code benchmark suites, our experimental evaluation shows that by translating code to be executed on 6 different software frameworks and hardware devices, Tenspiler offers on average 105× kernel and 9.65× end-to-end execution time improvement over the fully-optimized sequential implementation of the same benchmarks. 
 Cite asJie Qiu, Colin Cai, Sahil Bhatia, Niranjan Hasabnis, Sanjit A. Seshia, and Alvin Cheung. Tenspiler: A Verified-Lifting-Based Compiler for Tensor Operations. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 32:1-32:28, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{qiu_et_al:LIPIcs.ECOOP.2024.32 author = {Qiu, Jie and Cai, Colin and Bhatia, Sahil and Hasabnis, Niranjan and Seshia, Sanjit A. and Cheung, Alvin}, title = {{Tenspiler: A Verified-Lifting-Based Compiler for Tensor Operations}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {32:1--32:28}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.32}, URN = {urn:nbn:de:0030-drops-208817}, doi = {10.4230/LIPIcs.ECOOP.2024.32}, annote = {Keywords: Program Synthesis, Code Transpilation, Tensor DSLs, Verification} }@InProceedings{qiu_et_al:LIPIcs.ECOOP.2024.32 author = {Qiu, Jie and Cai, Colin and Bhatia, Sahil and Hasabnis, Niranjan and Seshia, Sanjit A. and Cheung, Alvin}, title = {{Tenspiler: A Verified-Lifting-Based Compiler for Tensor Operations}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {32:1--32:28}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.32}, URN = {urn:nbn:de:0030-drops-208817}, doi = {10.4230/LIPIcs.ECOOP.2024.32}, annote = {Keywords: Program Synthesis, Code Transpilation, Tensor DSLs, Verification} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.33" - DOI: 10.4230/LIPIcs.ECOOP.2024.33
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.33/LIPIcs.ECOOP.2024.33.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.33" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.33" - Compiling with Arrays
Authors:David Richter, Timon Böhler, Pascal Weisenburger, and Mira Mezini 
 AbstractLinear algebra computations are foundational for neural networks and machine learning, often handled through arrays. While many functional programming languages feature lists and recursion, arrays in linear algebra demand constant-time access and bulk operations. To bridge this gap, some languages represent arrays as (eager) functions instead of lists. In this paper, we connect this idea to a formal logical foundation by interpreting functions as the usual negative types from polarized type theory, and arrays as the corresponding dual positive version of the function type. Positive types are defined to have a single elimination form whose computational interpretation is pattern matching. Just like (positive) product types bind two variables during pattern matching, (positive) array types bind variables with multiplicity during pattern matching. We follow a similar approach for Booleans by introducing conditionally-defined variables. The positive formulation for the array type enables us to combine typed partial evaluation and common subexpression elimination into an elegant algorithm whose result enjoys a property we call maximal fission, which we argue can be beneficial for further optimizations. For this purpose, we present the novel intermediate representation indexed administrative normal form (A_{i}NF), which relies on the formal logical foundation of the positive formulation for the array type to facilitate maximal loop fission and subsequent optimizations. A_{i}NF is normal with regard to commuting conversion for both let-bindings and for-loops, leading to flat and maximally fissioned terms. We mechanize the translation and normalization from a simple surface language to A_{i}NF, establishing that the process terminates, preserves types, and produces maximally fissioned terms. 
 Cite asDavid Richter, Timon Böhler, Pascal Weisenburger, and Mira Mezini. Compiling with Arrays. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 33:1-33:24, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{richter_et_al:LIPIcs.ECOOP.2024.33 author = {Richter, David and B\"{o}hler, Timon and Weisenburger, Pascal and Mezini, Mira}, title = {{Compiling with Arrays}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {33:1--33:24}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.33}, URN = {urn:nbn:de:0030-drops-208823}, doi = {10.4230/LIPIcs.ECOOP.2024.33}, annote = {Keywords: array languages, functional programming, domain-specific languages, normalization by evaluation, common subexpression elimination, polarity, positive function type, intrinsic types} }@InProceedings{richter_et_al:LIPIcs.ECOOP.2024.33 author = {Richter, David and B\"{o}hler, Timon and Weisenburger, Pascal and Mezini, Mira}, title = {{Compiling with Arrays}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {33:1--33:24}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.33}, URN = {urn:nbn:de:0030-drops-208823}, doi = {10.4230/LIPIcs.ECOOP.2024.33}, annote = {Keywords: array languages, functional programming, domain-specific languages, normalization by evaluation, common subexpression elimination, polarity, positive function type, intrinsic types} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.34" - DOI: 10.4230/LIPIcs.ECOOP.2024.34
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.34/LIPIcs.ECOOP.2024.34.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.34" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.34" - Pipit on the Post: Proving Pre- and Post-Conditions of Reactive Systems
Authors:Amos Robinson and Alex Potanin 
 AbstractSynchronous languages such as Lustre and Scade are used to implement safety-critical control systems; proving such programs correct and having the proved properties apply to the compiled code is therefore equally critical. We introduce Pipit, a small synchronous language embedded in F*, designed for verifying control systems and executing them in real-time. Pipit includes a verified translation to transition systems; by reusing F*’s existing proof automation, certain safety properties can be automatically proved by k-induction on the transition system. Pipit can also generate executable code in a subset of F* which is suitable for compilation and real-time execution on embedded devices. The executable code is deterministic and total and preserves the semantics of the original program. 
 Cite asAmos Robinson and Alex Potanin. Pipit on the Post: Proving Pre- and Post-Conditions of Reactive Systems. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 34:1-34:28, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{robinson_et_al:LIPIcs.ECOOP.2024.34 author = {Robinson, Amos and Potanin, Alex}, title = {{Pipit on the Post: Proving Pre- and Post-Conditions of Reactive Systems}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {34:1--34:28}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.34}, URN = {urn:nbn:de:0030-drops-208836}, doi = {10.4230/LIPIcs.ECOOP.2024.34}, annote = {Keywords: Lustre, streaming, reactive, verification} }@InProceedings{robinson_et_al:LIPIcs.ECOOP.2024.34 author = {Robinson, Amos and Potanin, Alex}, title = {{Pipit on the Post: Proving Pre- and Post-Conditions of Reactive Systems}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {34:1--34:28}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.34}, URN = {urn:nbn:de:0030-drops-208836}, doi = {10.4230/LIPIcs.ECOOP.2024.34}, annote = {Keywords: Lustre, streaming, reactive, verification} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.35" - DOI: 10.4230/LIPIcs.ECOOP.2024.35
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.35/LIPIcs.ECOOP.2024.35.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.35" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.35" - Partial Redundancy Elimination in Two Iterative Data Flow Analyses
Authors:Reshma Roy, Sreekala S, and Vineeth Paleri 
 AbstractPartial Redundancy Elimination (PRE) is a powerful and well-known code optimization. The idea to combine Common Subexpression Elimination and Loop Invariant Code Motion optimizations into a single optimization was originally conceived by Morel and Renvoise. Their algorithm is bidirectional in nature and was not complete and optimal. Later, Knoop et al. proposed the first complete and optimal algorithm, Lazy Code Motion (LCM), which takes four unidirectional data flow analyses. In a recent paper, Roy et al. proposed an algorithm for PRE that uses three iterative data flow analyses. Here, we propose an efficient algorithm for PRE, which takes only two iterative data flow analyses followed by two computation passes over the program. The algorithm is both computationally and lifetime optimal. The proposed algorithm computes the information required for performing the transformation in two passes over the program without considering safety. The two iterative data flow analyses are required for making the transformation safe. The use of well-known data flow analyses, i.e., available expressions analysis and anticipated expressions analysis, makes the algorithm simple to understand and easy to prove its correctness. The proposed algorithm is more efficient than the existing algorithms since it takes only two iterative data flow analyses. The efficiency of the proposed algorithm is demonstrated by implementing it in LLVM Compiler Infrastructure and comparing the time taken with other selected best-known algorithms. 
 Cite asReshma Roy, Sreekala S, and Vineeth Paleri. Partial Redundancy Elimination in Two Iterative Data Flow Analyses. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 35:1-35:19, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{roy_et_al:LIPIcs.ECOOP.2024.35 author = {Roy, Reshma and S, Sreekala and Paleri, Vineeth}, title = {{Partial Redundancy Elimination in Two Iterative Data Flow Analyses}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {35:1--35:19}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.35}, URN = {urn:nbn:de:0030-drops-208840}, doi = {10.4230/LIPIcs.ECOOP.2024.35}, annote = {Keywords: Static Analysis, Data Flow Analysis, Code Optimization, Partial Redundancy Elimination} }@InProceedings{roy_et_al:LIPIcs.ECOOP.2024.35 author = {Roy, Reshma and S, Sreekala and Paleri, Vineeth}, title = {{Partial Redundancy Elimination in Two Iterative Data Flow Analyses}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {35:1--35:19}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.35}, URN = {urn:nbn:de:0030-drops-208840}, doi = {10.4230/LIPIcs.ECOOP.2024.35}, annote = {Keywords: Static Analysis, Data Flow Analysis, Code Optimization, Partial Redundancy Elimination} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.36" - DOI: 10.4230/LIPIcs.ECOOP.2024.36
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.36/LIPIcs.ECOOP.2024.36.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.36" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.36" - Scaling Interprocedural Static Data-Flow Analysis to Large C/C++ Applications: An Experience Report
Authors:Fabian Schiebel, Florian Sattler, Philipp Dominik Schubert, Sven Apel, and Eric Bodden 
 AbstractInterprocedural data-flow analysis is important for computing precise information on whole programs. In theory, the popular algorithmic framework interprocedural distributive environments (IDE) provides a tool to solve distributive interprocedural data-flow problems efficiently. Yet, unfortunately, available state-of-the-art implementations of the IDE framework start to run into scalability issues for programs with several thousands of lines of code, depending on the static analysis domain. Since the IDE framework is a basic building block for many static program analyses, this presents a serious limitation. In this paper, we report on our experience with making the IDE algorithm scale to C/C++ applications with up to 500 000 lines of code. We analyze the IDE algorithm and its state-of-the-art implementations to identify their weaknesses related to scalability at both a conceptual and implementation level. Based on this analysis, we propose several optimizations to overcome these weaknesses, aiming at a sweet spot between reducing running time and memory consumption. As a result, we provide an improved IDE solver that implements our optimizations within the PhASAR static analysis framework. Our evaluation on real-world C/C++ applications shows that applying the optimizations speeds up the analysis on average by up to 7×, while also reducing memory consumption by 7× on average as well. For the first time, these optimizations allow us to analyze programs with several hundreds of thousands of lines of LLVM-IR code in reasonable time and space. 
 Cite asFabian Schiebel, Florian Sattler, Philipp Dominik Schubert, Sven Apel, and Eric Bodden. Scaling Interprocedural Static Data-Flow Analysis to Large C/C++ Applications: An Experience Report. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 36:1-36:28, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{schiebel_et_al:LIPIcs.ECOOP.2024.36 author = {Schiebel, Fabian and Sattler, Florian and Schubert, Philipp Dominik and Apel, Sven and Bodden, Eric}, title = {{Scaling Interprocedural Static Data-Flow Analysis to Large C/C++ Applications: An Experience Report}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {36:1--36:28}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.36}, URN = {urn:nbn:de:0030-drops-208859}, doi = {10.4230/LIPIcs.ECOOP.2024.36}, annote = {Keywords: Interprocedural data-flow analysis, IDE, LLVM, C/C++} }@InProceedings{schiebel_et_al:LIPIcs.ECOOP.2024.36 author = {Schiebel, Fabian and Sattler, Florian and Schubert, Philipp Dominik and Apel, Sven and Bodden, Eric}, title = {{Scaling Interprocedural Static Data-Flow Analysis to Large C/C++ Applications: An Experience Report}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {36:1--36:28}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.36}, URN = {urn:nbn:de:0030-drops-208859}, doi = {10.4230/LIPIcs.ECOOP.2024.36}, annote = {Keywords: Interprocedural data-flow analysis, IDE, LLVM, C/C++} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.37" - DOI: 10.4230/LIPIcs.ECOOP.2024.37
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.37/LIPIcs.ECOOP.2024.37.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.37" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.37" - Java Bytecode Normalization for Code Similarity Analysis
Authors:Stefan Schott, Serena Elisa Ponta, Wolfram Fischer, Jonas Klauke, and Eric Bodden 
 AbstractAnalyzing the similarity of two code fragments has many applications, including code clone, vulnerability and plagiarism detection. Most existing approaches for similarity analysis work on source code. However, in scenarios like plagiarism detection, copyright violation detection or Software Bill of Materials creation source code is often not available and thus similarity analysis has to be performed on binary formats. Java bytecode is a binary format executable by the Java Virtual Machine and obtained from the compilation of Java source code. Performing similarity detection on bytecode is challenging because different compilers can compile the same source code to syntactically vastly different bytecode. In this work we assess to what extent one can nonetheless enable similarity detection by bytecode normalization, a procedure to transform Java bytecode into a representation that is identical for the same original source code, irrespective of the Java compiler and Java version used during compilation. Our manual study revealed 16 classes of compilation differences that various compilation environments may induce. Based on these findings, we implemented bytecode normalization in a tool jNorm. It uses Jimple as intermediate representation, applies common code optimizations and transforms all classes of compilation difference to a normalized form, thus achieving a representation of the bytecode that is identical despite different compilation environments. Our evaluation, performed on more than 300 popular Java projects, shows that solely the act of incrementing a compiler version may cause differences in 46% of all resulting bytecode files. By applying bytecode normalization, one can remove more than 99% of these differences, thus acting as a crucial enabler for subsequent applications of bytecode similarity analysis. 
 Cite asStefan Schott, Serena Elisa Ponta, Wolfram Fischer, Jonas Klauke, and Eric Bodden. Java Bytecode Normalization for Code Similarity Analysis. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 37:1-37:29, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{schott_et_al:LIPIcs.ECOOP.2024.37 author = {Schott, Stefan and Ponta, Serena Elisa and Fischer, Wolfram and Klauke, Jonas and Bodden, Eric}, title = {{Java Bytecode Normalization for Code Similarity Analysis}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {37:1--37:29}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.37}, URN = {urn:nbn:de:0030-drops-208865}, doi = {10.4230/LIPIcs.ECOOP.2024.37}, annote = {Keywords: Bytecode, Java Compiler, Code Similarity Analysis} }@InProceedings{schott_et_al:LIPIcs.ECOOP.2024.37 author = {Schott, Stefan and Ponta, Serena Elisa and Fischer, Wolfram and Klauke, Jonas and Bodden, Eric}, title = {{Java Bytecode Normalization for Code Similarity Analysis}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {37:1--37:29}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.37}, URN = {urn:nbn:de:0030-drops-208865}, doi = {10.4230/LIPIcs.ECOOP.2024.37}, annote = {Keywords: Bytecode, Java Compiler, Code Similarity Analysis} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.38" - DOI: 10.4230/LIPIcs.ECOOP.2024.38
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.38/LIPIcs.ECOOP.2024.38.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.38" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.38" - Optimizing Layout of Recursive Datatypes with Marmoset: Or, Algorithms + Data Layouts = Efficient Programs
Authors:Vidush Singhal, Chaitanya Koparkar, Joseph Zullo, Artem Pelenitsyn, Michael Vollmer, Mike Rainey, Ryan Newton, and Milind Kulkarni 
 AbstractWhile programmers know that memory representation of data structures can have significant effects on performance, compiler support to optimize the layout of those structures is an under-explored field. Prior work has optimized the layout of individual, non-recursive structures without considering how collections of those objects in linked or recursive data structures are laid out. This work introduces Marmoset, a compiler that optimizes the layouts of algebraic datatypes, with a special focus on producing highly optimized, packed data layouts where recursive structures can be traversed with minimal pointer chasing. Marmoset performs an analysis of how a recursive ADT is used across functions to choose a global layout that promotes simple, strided access for that ADT in memory. It does so by building and solving a constraint system to minimize an abstract cost model, yielding a predicted efficient layout for the ADT. Marmoset then builds on top of Gibbon, a prior compiler for packed, mostly-serial representations, to synthesize optimized ADTs. We show experimentally that Marmoset is able to choose optimal layouts across a series of microbenchmarks and case studies, outperforming both Gibbon’s baseline approach, as well as MLton, a Standard ML compiler that uses traditional pointer-heavy representations. 
 Cite asVidush Singhal, Chaitanya Koparkar, Joseph Zullo, Artem Pelenitsyn, Michael Vollmer, Mike Rainey, Ryan Newton, and Milind Kulkarni. Optimizing Layout of Recursive Datatypes with Marmoset: Or, Algorithms + Data Layouts = Efficient Programs. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 38:1-38:28, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{singhal_et_al:LIPIcs.ECOOP.2024.38 author = {Singhal, Vidush and Koparkar, Chaitanya and Zullo, Joseph and Pelenitsyn, Artem and Vollmer, Michael and Rainey, Mike and Newton, Ryan and Kulkarni, Milind}, title = {{Optimizing Layout of Recursive Datatypes with Marmoset: Or, Algorithms + Data Layouts = Efficient Programs}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {38:1--38:28}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.38}, URN = {urn:nbn:de:0030-drops-208875}, doi = {10.4230/LIPIcs.ECOOP.2024.38}, annote = {Keywords: Tree traversals, Compilers, Data layout optimization, Dense data layout} }@InProceedings{singhal_et_al:LIPIcs.ECOOP.2024.38 author = {Singhal, Vidush and Koparkar, Chaitanya and Zullo, Joseph and Pelenitsyn, Artem and Vollmer, Michael and Rainey, Mike and Newton, Ryan and Kulkarni, Milind}, title = {{Optimizing Layout of Recursive Datatypes with Marmoset: Or, Algorithms + Data Layouts = Efficient Programs}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {38:1--38:28}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.38}, URN = {urn:nbn:de:0030-drops-208875}, doi = {10.4230/LIPIcs.ECOOP.2024.38}, annote = {Keywords: Tree traversals, Compilers, Data layout optimization, Dense data layout} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.39" - DOI: 10.4230/LIPIcs.ECOOP.2024.39
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.39/LIPIcs.ECOOP.2024.39.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.39" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.39" - Formalizing, Mechanizing, and Verifying Class-Based Refinement Types
Authors:Ke Sun, Di Wang, Sheng Chen, Meng Wang, and Dan Hao 
 AbstractRefinement types have been extensively used in class-based languages to specify and verify fine-grained logical specifications. Despite the advances in practical aspects such as applicability and usability, two fundamental issues persist. First, the soundness of existing class-based refinement type systems is inadequately explored, casting doubts on their reliability. Second, the expressiveness of existing systems is limited, restricting the depiction of semantic properties related to object-oriented constructs. This work tackles these issues through a systematic framework. We formalize a declarative class-based refinement type calculus (named RFJ), that is expressive and concise. We rigorously develop the soundness meta-theory of this calculus, followed by its mechanization in Coq. Finally, to ensure the calculus’s verifiability, we propose an algorithmic verification approach based on a fragment of first-order logic (named LFJ), and implement this approach as a type checker. 
 Cite asKe Sun, Di Wang, Sheng Chen, Meng Wang, and Dan Hao. Formalizing, Mechanizing, and Verifying Class-Based Refinement Types. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 39:1-39:30, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{sun_et_al:LIPIcs.ECOOP.2024.39 author = {Sun, Ke and Wang, Di and Chen, Sheng and Wang, Meng and Hao, Dan}, title = {{Formalizing, Mechanizing, and Verifying Class-Based Refinement Types}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {39:1--39:30}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.39}, URN = {urn:nbn:de:0030-drops-208881}, doi = {10.4230/LIPIcs.ECOOP.2024.39}, annote = {Keywords: Refinement Types, Program Verification, Object-oriented Programming} }@InProceedings{sun_et_al:LIPIcs.ECOOP.2024.39 author = {Sun, Ke and Wang, Di and Chen, Sheng and Wang, Meng and Hao, Dan}, title = {{Formalizing, Mechanizing, and Verifying Class-Based Refinement Types}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {39:1--39:30}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.39}, URN = {urn:nbn:de:0030-drops-208881}, doi = {10.4230/LIPIcs.ECOOP.2024.39}, annote = {Keywords: Refinement Types, Program Verification, Object-oriented Programming} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.40" - DOI: 10.4230/LIPIcs.ECOOP.2024.40
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.40/LIPIcs.ECOOP.2024.40.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.40" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.40" - Information Flow Control in Cyclic Process Networks
Authors:Bas van den Heuvel, Farzaneh Derakhshan, and Stephanie Balzer 
 AbstractProtection of confidential data is an important security consideration of today’s applications. Of particular concern is to guard against unintentional leakage to a (malicious) observer, who may interact with the program and draw inference from made observations. Information flow control (IFC) type systems address this concern by statically ruling out such leakage. This paper contributes an IFC type system for message-passing concurrent programs, the computational model of choice for many of today’s applications such as cloud computing and IoT applications. Such applications typically either implicitly or explicitly codify protocols according to which message exchange must happen, and to statically ensure protocol safety, behavioral type systems such as session types can be used. This paper marries IFC with session typing and contributes over prior work in the following regards: (1) support of realistic cyclic process networks as opposed to the restriction to tree-shaped networks, (2) more permissive, yet entirely secure, IFC control, exploiting cyclic process networks, and (3) considering deadlocks as another form of side channel, and asserting deadlock-sensitive noninterference (DSNI) for well-typed programs. To prove DSNI, the paper develops a novel logical relation that accounts for cyclic process networks. The logical relation is rooted in linear logic, but drops the tree-topology restriction imposed by prior work. 
 Cite asBas van den Heuvel, Farzaneh Derakhshan, and Stephanie Balzer. Information Flow Control in Cyclic Process Networks. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 40:1-40:30, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{vandenheuvel_et_al:LIPIcs.ECOOP.2024.40 author = {van den Heuvel, Bas and Derakhshan, Farzaneh and Balzer, Stephanie}, title = {{Information Flow Control in Cyclic Process Networks}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {40:1--40:30}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.40}, URN = {urn:nbn:de:0030-drops-208891}, doi = {10.4230/LIPIcs.ECOOP.2024.40}, annote = {Keywords: Cyclic process networks, linear session types, logical relations, deadlock-sensitive noninterference} }@InProceedings{vandenheuvel_et_al:LIPIcs.ECOOP.2024.40 author = {van den Heuvel, Bas and Derakhshan, Farzaneh and Balzer, Stephanie}, title = {{Information Flow Control in Cyclic Process Networks}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {40:1--40:30}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.40}, URN = {urn:nbn:de:0030-drops-208891}, doi = {10.4230/LIPIcs.ECOOP.2024.40}, annote = {Keywords: Cyclic process networks, linear session types, logical relations, deadlock-sensitive noninterference} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.41" - DOI: 10.4230/LIPIcs.ECOOP.2024.41
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.41/LIPIcs.ECOOP.2024.41.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.41" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.41" - Refinements for Multiparty Message-Passing Protocols: Specification-Agnostic Theory and Implementation
Authors:Martin Vassor and Nobuko Yoshida 
 AbstractMultiparty message-passing protocols are notoriously difficult to design, due to interaction mismatches that lead to errors such as deadlocks. Existing protocol specification formats have been developed to prevent such errors (e.g. multiparty session types (MPST)). In order to further constrain protocols, specifications can be extended with refinements, i.e. logical predicates to control the behaviour of the protocol based on previous values exchanged. Unfortunately, existing refinement theories and implementations are tightly coupled with specification formats. This paper proposes a framework for multiparty message-passing protocols with refinements and its implementation in Rust. Our work decouples correctness of refinements from the underlying model of computation, which results in a specification-agnostic framework. Our contributions are threefold. First, we introduce a trace system which characterises valid refined traces, i.e. a sequence of sending and receiving actions correct with respect to refinements. Second, we give a correct model of computation named refined communicating system (RCS), which is an extension of communicating automata systems with refinements. We prove that RCS only produce valid refined traces. We show how to generate RCS from mainstream protocol specification formats, such as refined multiparty session types (RMPST) or refined choreography automata. Third, we illustrate the flexibility of the framework by developing both a static analysis technique and an improved model of computation for dynamic refinement evaluation. Finally, we provide a Rust toolchain for decentralised RMPST, evaluate our implementation with a set of benchmarks from the literature, and observe that refinement overhead is negligible. 
 Cite asMartin Vassor and Nobuko Yoshida. Refinements for Multiparty Message-Passing Protocols: Specification-Agnostic Theory and Implementation. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 41:1-41:29, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{vassor_et_al:LIPIcs.ECOOP.2024.41 author = {Vassor, Martin and Yoshida, Nobuko}, title = {{Refinements for Multiparty Message-Passing Protocols: Specification-Agnostic Theory and Implementation}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {41:1--41:29}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.41}, URN = {urn:nbn:de:0030-drops-208906}, doi = {10.4230/LIPIcs.ECOOP.2024.41}, annote = {Keywords: Message-Passing Concurrency, Session Types, Specification} }@InProceedings{vassor_et_al:LIPIcs.ECOOP.2024.41 author = {Vassor, Martin and Yoshida, Nobuko}, title = {{Refinements for Multiparty Message-Passing Protocols: Specification-Agnostic Theory and Implementation}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {41:1--41:29}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.41}, URN = {urn:nbn:de:0030-drops-208906}, doi = {10.4230/LIPIcs.ECOOP.2024.41}, annote = {Keywords: Message-Passing Concurrency, Session Types, Specification} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.42" - DOI: 10.4230/LIPIcs.ECOOP.2024.42
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.42/LIPIcs.ECOOP.2024.42.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.42" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.42" - Failure Transparency in Stateful Dataflow Systems
Authors:Aleksey Veresov, Jonas Spenger, Paris Carbone, and Philipp Haller 
 AbstractFailure transparency enables users to reason about distributed systems at a higher level of abstraction, where complex failure-handling logic is hidden. This is especially true for stateful dataflow systems, which are the backbone of many cloud applications. In particular, this paper focuses on proving failure transparency in Apache Flink, a popular stateful dataflow system. Even though failure transparency is a critical aspect of Apache Flink, to date it has not been formally proven. Showing that the failure transparency mechanism is correct, however, is challenging due to the complexity of the mechanism itself. Nevertheless, this complexity can be effectively hidden behind a failure transparent programming interface. To show that Apache Flink is failure transparent, we model it in small-step operational semantics. Next, we provide a novel definition of failure transparency based on observational explainability, a concept which relates executions according to their observations. Finally, we provide a formal proof of failure transparency for the implementation model; i.e., we prove that the failure-free model correctly abstracts from the failure-related details of the implementation model. We also show liveness of the implementation model under a fair execution assumption. These results are a first step towards a verified stack for stateful dataflow systems. 
 Cite asAleksey Veresov, Jonas Spenger, Paris Carbone, and Philipp Haller. Failure Transparency in Stateful Dataflow Systems. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 42:1-42:31, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{veresov_et_al:LIPIcs.ECOOP.2024.42 author = {Veresov, Aleksey and Spenger, Jonas and Carbone, Paris and Haller, Philipp}, title = {{Failure Transparency in Stateful Dataflow Systems}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {42:1--42:31}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.42}, URN = {urn:nbn:de:0030-drops-208911}, doi = {10.4230/LIPIcs.ECOOP.2024.42}, annote = {Keywords: Failure transparency, stateful dataflow, operational semantics, checkpoint recovery} }@InProceedings{veresov_et_al:LIPIcs.ECOOP.2024.42 author = {Veresov, Aleksey and Spenger, Jonas and Carbone, Paris and Haller, Philipp}, title = {{Failure Transparency in Stateful Dataflow Systems}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {42:1--42:31}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.42}, URN = {urn:nbn:de:0030-drops-208911}, doi = {10.4230/LIPIcs.ECOOP.2024.42}, annote = {Keywords: Failure transparency, stateful dataflow, operational semantics, checkpoint recovery} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.43" - DOI: 10.4230/LIPIcs.ECOOP.2024.43
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.43/LIPIcs.ECOOP.2024.43.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.43" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.43" - Inductive Predicate Synthesis Modulo Programs
Authors:Scott Wesley, Maria Christakis, Jorge A. Navas, Richard Trefler, Valentin Wüstholz, and Arie Gurfinkel 
 AbstractA growing trend in program analysis is to encode verification conditions within the language of the input program. This simplifies the design of analysis tools by utilizing off-the-shelf verifiers, but makes communication with the underlying solver more challenging. Essentially, the analysis tools operates at the level of input programs, whereas the solver operates at the level of problem encodings. To bridge this gap, the verifier must pass along proof-rules from the analysis tool to the solver. For example, an analysis tool for concurrent programs built on an inductive program verifier might need to declare Owicki-Gries style proof-rules for the underlying solver. Each such proof-rule further specifies how a program should be verified, meaning that the problem of passing proof-rules is a form of invariant synthesis. Similarly, many program analysis tasks reduce to the synthesis of pure, loop-free Boolean functions (i.e., predicates), relative to a program. From this observation, we propose Inductive Predicate Synthesis Modulo Programs (IPS-MP) which extends high-level languages with minimal synthesis features to guide analysis. In IPS-MP, unknown predicates appear under assume and assert statements, acting as specifications modulo the program semantics. Existing synthesis solvers are inefficient at IPS-MP as they target more general problems. In this paper, we show that IPS-MP admits an efficient solution in the Boolean case, despite being generally undecidable. Moreover, we show that IPS-MP reduces to the satisfiability of constrained Horn clauses, which is less general than existing synthesis problems, yet expressive enough to encode verification tasks. We provide reductions from challenging verification tasks - such as parameterized model checking - to IPS-MP. We realize these reductions with an efficient IPS-MP-solver based on SeaHorn, and describe a real-world application to smart-contract verification. 
 Cite asScott Wesley, Maria Christakis, Jorge A. Navas, Richard Trefler, Valentin Wüstholz, and Arie Gurfinkel. Inductive Predicate Synthesis Modulo Programs. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 43:1-43:30, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{wesley_et_al:LIPIcs.ECOOP.2024.43 author = {Wesley, Scott and Christakis, Maria and Navas, Jorge A. and Trefler, Richard and W\"{u}stholz, Valentin and Gurfinkel, Arie}, title = {{Inductive Predicate Synthesis Modulo Programs}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {43:1--43:30}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.43}, URN = {urn:nbn:de:0030-drops-208926}, doi = {10.4230/LIPIcs.ECOOP.2024.43}, annote = {Keywords: Software Verification, Invariant Synthesis, Model-Checking} }@InProceedings{wesley_et_al:LIPIcs.ECOOP.2024.43 author = {Wesley, Scott and Christakis, Maria and Navas, Jorge A. and Trefler, Richard and W\"{u}stholz, Valentin and Gurfinkel, Arie}, title = {{Inductive Predicate Synthesis Modulo Programs}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {43:1--43:30}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.43}, URN = {urn:nbn:de:0030-drops-208926}, doi = {10.4230/LIPIcs.ECOOP.2024.43}, annote = {Keywords: Software Verification, Invariant Synthesis, Model-Checking} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.44" - DOI: 10.4230/LIPIcs.ECOOP.2024.44
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.44/LIPIcs.ECOOP.2024.44.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.44" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.44" - Type Tailoring
Authors:Ashton Wiersdorf, Stephen Chang, Matthias Felleisen, and Ben Greenman 
 AbstractType systems evolve too slowly to keep up with the quick evolution of libraries - especially libraries that introduce abstractions. Type tailoring offers a lightweight solution by equipping the core language with an API for modifying the elaboration of surface code into the internal language of the typechecker. Through user-programmable elaboration, tailoring rules appear to improve the precision and expressiveness of the underlying type system. Furthermore, type tailoring cooperates with the host type system by expanding to code that the host then typechecks. In the context of a hygienic metaprogramming system, tailoring rules can even harmoniously compose with one another. Type tailoring has emerged as a theme across several languages and metaprogramming systems, but never with direct support and rarely in the same shape twice. For example, both OCaml and Typed Racket enable forms of tailoring, but in quite different ways. This paper identifies key dimensions of type tailoring systems and tradeoffs along each dimension. It demonstrates the usefulness of tailoring with examples that cover sized vectors, database queries, and optional types. Finally, it outlines a vision for future research at the intersection of types and metaprogramming. 
 Cite asAshton Wiersdorf, Stephen Chang, Matthias Felleisen, and Ben Greenman. Type Tailoring. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 44:1-44:27, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{wiersdorf_et_al:LIPIcs.ECOOP.2024.44 author = {Wiersdorf, Ashton and Chang, Stephen and Felleisen, Matthias and Greenman, Ben}, title = {{Type Tailoring}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {44:1--44:27}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.44}, URN = {urn:nbn:de:0030-drops-208933}, doi = {10.4230/LIPIcs.ECOOP.2024.44}, annote = {Keywords: Types, Metaprogramming, Macros, Partial Evaluation} }@InProceedings{wiersdorf_et_al:LIPIcs.ECOOP.2024.44 author = {Wiersdorf, Ashton and Chang, Stephen and Felleisen, Matthias and Greenman, Ben}, title = {{Type Tailoring}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {44:1--44:27}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.44}, URN = {urn:nbn:de:0030-drops-208933}, doi = {10.4230/LIPIcs.ECOOP.2024.44}, annote = {Keywords: Types, Metaprogramming, Macros, Partial Evaluation} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.45" - DOI: 10.4230/LIPIcs.ECOOP.2024.45
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.45/LIPIcs.ECOOP.2024.45.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.45" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.45" - Higher-Order Specifications for Deductive Synthesis of Programs with Pointers
Authors:David Young, Ziyi Yang, Ilya Sergey, and Alex Potanin 
 AbstractSynthetic Separation Logic (SSL) is a formalism that powers SuSLik, the state-of-the-art approach for the deductive synthesis of provably-correct programs in C-like languages that manipulate heap-based linked data structures. Despite its expressivity, SSL suffers from two shortcomings that hinder its utility. First, its main specification component, inductive predicates, only admits first-order definitions of data structure shapes, which leads to the proliferation of "boiler-plate" predicates for specifying common patterns. Second, SSL requires concrete definitions of data structures to synthesise programs that manipulate them, which results in the need to change a specification for a synthesis task every time changes are introduced into the layout of the involved structures. We propose to significantly lift the level of abstraction used in writing Separation Logic specifications for synthesis - both simplifying the approach and making the specifications more usable and easy to read and follow. We avoid the need to repetitively re-state low-level representation details throughout the specifications - allowing the reuse of different implementations of the same data structure by abstracting away the details of a specific layout used in memory. Our novel high-level front-end language called Pika significantly improves the expressiveness of SuSLik. We implemented a layout-agnostic synthesiser from Pika to SuSLik enabling push-button synthesis of C programs with in-place memory updates, along with the accompanying full proofs that they meet Separation Logic-style specifications, from high-level specifications that resemble ordinary functional programs. Our experiments show that our tool can produce C code that is comparable in its performance characteristics and is sometimes faster than Haskell. 
 Cite asDavid Young, Ziyi Yang, Ilya Sergey, and Alex Potanin. Higher-Order Specifications for Deductive Synthesis of Programs with Pointers. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 45:1-45:26, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{young_et_al:LIPIcs.ECOOP.2024.45 author = {Young, David and Yang, Ziyi and Sergey, Ilya and Potanin, Alex}, title = {{Higher-Order Specifications for Deductive Synthesis of Programs with Pointers}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {45:1--45:26}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.45}, URN = {urn:nbn:de:0030-drops-208946}, doi = {10.4230/LIPIcs.ECOOP.2024.45}, annote = {Keywords: Program Synthesis, Separation Logic, Functional Programming} }@InProceedings{young_et_al:LIPIcs.ECOOP.2024.45 author = {Young, David and Yang, Ziyi and Sergey, Ilya and Potanin, Alex}, title = {{Higher-Order Specifications for Deductive Synthesis of Programs with Pointers}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {45:1--45:26}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.45}, URN = {urn:nbn:de:0030-drops-208946}, doi = {10.4230/LIPIcs.ECOOP.2024.45}, annote = {Keywords: Program Synthesis, Separation Logic, Functional Programming} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.46" - DOI: 10.4230/LIPIcs.ECOOP.2024.46
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.46/LIPIcs.ECOOP.2024.46.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.46" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.46" - {CtChecker}: A Precise, Sound and Efficient Static Analysis for Constant-Time Programming
Authors:Quan Zhou, Sixuan Dang, and Danfeng Zhang 
 AbstractTiming channel attacks are emerging as real-world threats to computer security. In cryptographic systems, an effective countermeasure against timing attacks is the constant-time programming discipline. However, strictly enforcing the discipline manually is both time-consuming and error-prone. While various tools exist for analyzing/verifying constant-time programs, they sacrifice at least one feature among precision, soundness and efficiency. In this paper, we build CtChecker, a sound static analysis for constant-time programming. Under the hood, CtChecker uses a static information flow analysis to identify violations of constant-time discipline. Despite the common wisdom that sound, static information flow analysis lacks precision for real-world applications, we show that by enabling field-sensitivity, context-sensitivity and partial flow-sensitivity, CtChecker reports fewer false positives compared with existing sound tools. Evaluation on real-world cryptographic systems shows that CtChecker analyzes 24K lines of source code in under one minute. Moreover, CtChecker reveals that some repaired code generated by program rewriters supposedly remove timing channels are still not constant-time. 
 Cite asQuan Zhou, Sixuan Dang, and Danfeng Zhang. {CtChecker}: A Precise, Sound and Efficient Static Analysis for Constant-Time Programming. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 46:1-46:26, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{zhou_et_al:LIPIcs.ECOOP.2024.46 author = {Zhou, Quan and Dang, Sixuan and Zhang, Danfeng}, title = {{\{CtChecker\}: A Precise, Sound and Efficient Static Analysis for Constant-Time Programming}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {46:1--46:26}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.46}, URN = {urn:nbn:de:0030-drops-208951}, doi = {10.4230/LIPIcs.ECOOP.2024.46}, annote = {Keywords: Information flow control, static analysis, side channel, constant-time programming} }@InProceedings{zhou_et_al:LIPIcs.ECOOP.2024.46 author = {Zhou, Quan and Dang, Sixuan and Zhang, Danfeng}, title = {{\{CtChecker\}: A Precise, Sound and Efficient Static Analysis for Constant-Time Programming}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {46:1--46:26}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.46}, URN = {urn:nbn:de:0030-drops-208951}, doi = {10.4230/LIPIcs.ECOOP.2024.46}, annote = {Keywords: Information flow control, static analysis, side channel, constant-time programming} }Document 
 href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.47" - DOI: 10.4230/LIPIcs.ECOOP.2024.47
href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol313-ecoop2024/LIPIcs.ECOOP.2024.47/LIPIcs.ECOOP.2024.47.pdf" - 
href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.47" - 

href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.47" - Defining Name Accessibility Using Scope Graphs
Authors:Aron Zwaan and Casper Bach Poulsen 
 AbstractMany programming languages allow programmers to regulate accessibility; i.e., annotating a declaration with keywords such as export and private to indicate where it can be accessed. Despite the importance of name accessibility for, e.g., compilers, editor auto-completion and tooling, and automated refactorings, few existing type systems provide a formal account of name accessibility. We present a declarative, executable, and language-parametric model for name accessibility, which provides a formal specification of name accessibility in Java, C#, C++, Rust, and Eiffel. We achieve this by defining name accessibility as a predicate on resolution paths through scope graphs. Since scope graphs are a language-independent model of name resolution, our model provides a uniform approach to defining different accessibility policies for different languages. Our model is implemented in Statix, a logic language for executable type system specification using scope graphs. We evaluate its correctness on a test suite that compares it with the C#, Java, and Rust compilers, and show we can synthesize access modifiers in programs with holes accurately. 
 Cite asAron Zwaan and Casper Bach Poulsen. Defining Name Accessibility Using Scope Graphs. In 38th European Conference on Object-Oriented Programming (ECOOP 2024). Leibniz International Proceedings in Informatics (LIPIcs), Volume 313, pp. 47:1-47:29, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2024) 
 Copy BibTex To Clipboard 
  
 @InProceedings{zwaan_et_al:LIPIcs.ECOOP.2024.47 author = {Zwaan, Aron and Bach Poulsen, Casper}, title = {{Defining Name Accessibility Using Scope Graphs}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {47:1--47:29}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.47}, URN = {urn:nbn:de:0030-drops-208961}, doi = {10.4230/LIPIcs.ECOOP.2024.47}, annote = {Keywords: access modifier, visibility, scope graph, name resolution} }@InProceedings{zwaan_et_al:LIPIcs.ECOOP.2024.47 author = {Zwaan, Aron and Bach Poulsen, Casper}, title = {{Defining Name Accessibility Using Scope Graphs}}, booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)}, pages = {47:1--47:29}, series = {Leibniz International Proceedings in Informatics (LIPIcs)}, ISBN = {978-3-95977-341-6}, ISSN = {1868-8969}, year = {2024}, volume = {313}, editor = {Aldrich, Jonathan and Salvaneschi, Guido}, publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}, address = {Dagstuhl, Germany}, URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.47}, URN = {urn:nbn:de:0030-drops-208961}, doi = {10.4230/LIPIcs.ECOOP.2024.47}, annote = {Keywords: access modifier, visibility, scope graph, name resolution} }Filters 
 163Authors 
 Show AllCollapse 
 Show All 
 A 
 Aceto, Luca 
 Aldrich, Jonathan 
 Ansel, Jason 
 Apel, Sven 
 Arvay, Barnabas 
 Arzt, Steven 
 Attard, Duncan Paul 
 Ayoun, Sacha-Élie 
 B 
 Bacchiani, Lorenzo 
 Bach Poulsen, Casper 
 Balzer, Stephanie 
 Berlakovich, Felix 
 Bernad, Matthias 
 Bhatia, Sahil 
 Bodden, Eric 
 Böhler, Timon 
 Bravetti, Mario 
 Brockbernd, Bob 
 Brunthaler, Stefan 
 C 
 Cai, Colin 
 Carbone, Paris 
 Carvalho, Luís 
 Chakraborty, Madhurima 
 Chang, Le 
 Chang, Stephen 
 Chen, Sheng 
 Cheung, Alvin 
 Chiba, Shigeru 
 Christakis, Maria 
 Cleaveland, Rance 
 Costa Seco, João 
 Cronjäger, Caroline 
 D 
 Dang, Sixuan 
 Derakhshan, Farzaneh 
 Di Grazia, Luca 
 Dimovski, Aleksandar S. 
 Doan, Thi Thu Ha 
 Dort, Vlastimil 
 E 
 Ertl, M. Anton 
 Estep, Sam 
 F 
 Feeley, Marc 
 Felleisen, Matthias 
 Fischer, Wolfram 
 Flanagan, Cormac 
 Francalanza, Adrian 
 Freund, Stephen N. 
 G 
 Gardner, Philippa 
 Giunti, Marco 
 Gnanakumar, Aakash 
 Gorla, Daniele 
 Greenman, Ben 
 Gurfinkel, Arie 
 H 
 Haller, Philipp 
 Hao, Dan 
 Hasabnis, Niranjan 
 He, Dongjie 
 He, Yi 
 Hou, Ping 
 Huemer, Florian 
 Hussein, Ayman 
 I 
 Ingólfsdóttir, Anna 
 Itzhaky, Shachar 
 K 
 Khan, Mohammad Wahiduzzaman 
 Kinsbruner, Elad 
 Klauke, Jonas 
 Koparkar, Chaitanya 
 Koval, Nikita 
 Kulkarni, Milind 
 L 
 Lagaillardie, Nicolas 
 Lee, Yi 
 Leopoldseder, David 
 Lhoták, Ondřej 
 Li, Liyi 
 Li, Senxi 
 Li, Yufeng 
 Lööw, Andreas 
 Lu, Jingbo 
 Lybech, Stian 
 M 
 Maj, Petr 
 Maksimović, Petar 
 Melançon, Olivier 
 Melgratti, Hernán 
 Mezini, Mira 
 Migeed, Zeina 
 Miltenberger, Marc 
 Montesi, Fabrizio 
 Mosaner, Raphael 
 Mössenböck, Hanspeter 
 Mota, João 
 Møller, Anders 
 Muroya, Stefanie 
 N 
 Nantes-Sobrinho, Daniele 
 Näumann, Julius 
 Navas, Jorge A. 
 Newton, Ryan 
 Ni, Wode 
 Nicolellis, Alexander 
 O 
 Ozkan, Burcu Kulahcioglu 
 P 
 Paleri, Vineeth 
 Palsberg, Jens 
 Parízek, Pavel 
 Patel, Nisarg 
 Paysan, Bernd 
 Peleg, Hila 
 Pelenitsyn, Artem 
 Peressotti, Marco 
 Plyukhin, Dan 
 Ponta, Serena Elisa 
 Potanin, Alex 
 Prokopec, Aleksandar 
 Q 
 Qiu, Jie 
 R 
 Rainey, Mike 
 Ravara, António 
 Reed, James 
 Richter, David 
 Robinson, Amos 
 Rothkopf, Raven 
 Roy, Reshma 
 S 
 S, Sreekala 
 Salvaneschi, Guido 
 Sattler, Florian 
 Scalas, Alceste 
 Schiebel, Fabian 
 Schott, Stefan 
 Schubert, Philipp Dominik 
 Sergey, Ilya 
 Serrano, Manuel 
 Seshia, Sanjit A. 
 Shasha, Dennis 
 Siek, Konrad 
 Singhal, Vidush 
 Spenger, Jonas 
 Sridharan, Manu 
 Sun, Ke 
 Sunshine, Joshua 
 T 
 Thiemann, Peter 
 Trefler, Richard 
 Tuosto, Emilio 
 V 
 van den Heuvel, Bas 
 van Deursen, Arie 
 Vassor, Martin 
 Veresov, Aleksey 
 Vitek, Jan 
 Vollmer, Michael 
 W 
 Wang, Di 
 Wang, Meng 
 Weisenburger, Pascal 
 Wesley, Scott 
 Wiersdorf, Ashton 
 Wies, Thomas 
 Wu, Xiaodi 
 Wüstholz, Valentin 
 X 
 Xue, Jingling 
 Y 
 Yamazaki, Tetsuro 
 Yang, Ziyi 
 Yao, Yue 
 Yoshida, Nobuko 
 Young, David 
 Z 
 Zhang, Danfeng 
 Zhou, Quan 
 Zhu, Mingwei 
 Zullo, Joseph 
 Zwaan, Aron 
  
 68Subjects 
 Show AllCollapse 
 Show All 
 Computer systems organization 
 Computer systems organization → Real-time languages 
 Computer systems organization → Superscalar architectures 
 Computing methodologies 
 Computing methodologies → Concurrent computing methodologies 
 Computing methodologies → Concurrent programming languages 
 Computing methodologies → Learning linear models 
 Computing methodologies → Machine learning 
 Computing methodologies → Neural networks 
 Computing methodologies → Symbolic and algebraic manipulation 
 General and reference 
 General and reference → General conference proceedings 
 General and reference → Measurement 
 General and reference → Performance 
 Information systems 
 Information systems → Data layout 
 Information systems → Web applications 
 Security and privacy 
 Security and privacy → Information flow control 
 Security and privacy → Logic and verification 
 Security and privacy → Software security engineering 
 Software and its engineering 
 Software and its engineering 
 Software and its engineering → Automated static analysis 
 Software and its engineering → Automatic programming 
 Software and its engineering → Checkpoint / restart 
 Software and its engineering → Compilers 
 Software and its engineering → Concurrent programming languages 
 Software and its engineering → Distributed programming languages 
 Software and its engineering → Domain specific languages 
 Software and its engineering → Dynamic analysis 
 Software and its engineering → Dynamic compilers 
 Software and its engineering → Extensible languages 
 Software and its engineering → Formal language definitions 
 Software and its engineering → Formal software verification 
 Software and its engineering → Functional languages 
 Software and its engineering → General programming languages 
 Software and its engineering → Interpreters 
 Software and its engineering → Just-in-time compilers 
 Software and its engineering → Language features 
 Software and its engineering → Object oriented languages 
 Software and its engineering → Runtime environments 
 Software and its engineering → Software defect analysis 
 Software and its engineering → Software design engineering 
 Software and its engineering → Software notations and tools 
 Software and its engineering → Software performance 
 Software and its engineering → Software product lines 
 Software and its engineering → Software testing and debugging 
 Software and its engineering → Software usability 
 Software and its engineering → Software verification 
 Software and its engineering → Software verification and validation 
 Software and its engineering → Source code generation 
 Software and its engineering → Specialized application languages 
 Software and its engineering → Specification languages 
 Software and its engineering → Virtual machines 
 Theory of computation 
 Theory of computation → Abstraction 
 Theory of computation → Assertions 
 Theory of computation → Automated reasoning 
 Theory of computation → Concurrency 
 Theory of computation → Linear logic 
 Theory of computation → Logic and verification 
 Theory of computation → Object oriented constructs 
 Theory of computation → Operational semantics 
 Theory of computation → Process calculi 
 Theory of computation → Program analysis 
 Theory of computation → Program constructs 
 Theory of computation → Program semantics 
 Theory of computation → Program specifications 
 Theory of computation → Program verification 
 Theory of computation → Quantum information theory 
 Theory of computation → Separation logic 
 Theory of computation → Shared memory algorithms 
 Theory of computation → Type structures 
 Theory of computation → Type theory 
 Questions / Remarks / FeedbackXFeedback for Dagstuhl Publishing 
  
 SendThanks for your feedback! 
 Feedback submitted 
 OKCould not send message 
 Please try again later or send anE-mail 
 OKAbout DROPS 
 Schloss Dagstuhl - Leibniz Center for Informatics has been operating the Dagstuhl Research Online Publication Server (short: DROPS) since 2004. DROPS enables publication of the latest research findings in a fast, uncomplicated manner, in addition to providing unimpeded, open access to them. All the requisite metadata on each publication is administered in accordance with general guidelines pertaining to online publications (cf. Dublin Core). This enables the online publications to be authorized for citation and made accessible to a wide readership on a permanent basis. Access is free of charge for readers following the open access idea which fosters unimpeded access to scientific publications. 
 More about DROPS 
 Instructions for Authors 
 Dagstuhl Series 
 href="https://submission.dagstuhl.de/series/details/lipics#author" - LIPIcs 
 href="https://submission.dagstuhl.de/series/details/oasics#author" - OASIcs 
 href="https://submission.dagstuhl.de/series/details/dfu#author" - Dagstuhl Follow-Ups 
 Dagstuhl Journals 
 href="https://submission.dagstuhl.de/series/details/darts#author" - DARTS – Dagstuhl Artifacts Series 
 href="https://submission.dagstuhl.de/series/details/dagrep#author" - Dagstuhl Reports 
 href="https://submission.dagstuhl.de/series/details/dagman#author" - Dagstuhl Manifestos 
 href="https://submission.dagstuhl.de/series/details/lites#author" - LITES 
 href="https://submission.dagstuhl.de/series/details/tgdk#author" - TGDK – Transactions on Graph Data and Knowledge 
 Instructions for Editors 
 Dagstuhl Series 
 href="https://submission.dagstuhl.de/series/details/lipics#editor" - LIPIcs 
 href="https://submission.dagstuhl.de/series/details/oasics#editor" - OASIcs 
 href="https://submission.dagstuhl.de/series/details/dfu#editor" - Dagstuhl Follow-Ups 
 Dagstuhl Journals 
 href="https://submission.dagstuhl.de/series/details/darts#editor" - DARTS – Dagstuhl Artifacts Series 
 href="https://submission.dagstuhl.de/series/details/dagrep#editor" - Dagstuhl Reports 
 href="https://submission.dagstuhl.de/series/details/dagman#editor" - Dagstuhl Manifestos 
 href="https://submission.dagstuhl.de/series/details/lites#editor" - LITES 
 href="https://submission.dagstuhl.de/series/details/tgdk#editor" - TGDK – Transactions on Graph Data and Knowledge 
 © 2023-2024Schloss Dagstuhl – LZI GmbHAbout DROPSImprintPrivacyContact

